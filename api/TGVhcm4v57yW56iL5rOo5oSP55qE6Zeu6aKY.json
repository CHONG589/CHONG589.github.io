{"title":"编程注意的问题","date":"2024-01-28T13:28:43.000Z","date_formatted":{"ll":"2024年1月28日","L":"2024/01/28","MM-DD":"01-28"},"updated":"2024-03-11T12:47:54.313Z","content":"<p>我们平时编程时经常会忽略一些细节，导致项目出现问题，且有些很难发现。</p>\n<span id=\"more\"></span>\n<h4 id=\"1.-头文件正确包含的重要性\">1. 头文件正确包含的重要性<a title=\"#1.-头文件正确包含的重要性\" href=\"#1.-头文件正确包含的重要性\"></a></h4>\n<p>在程序中使用 <strong>malloc 函数</strong> 时，在程序开头未写头文件 <strong><code>#include&lt;stdlib.h&gt;</code></strong>，这时 gcc 没有看到 malloc 函数头文件的时候，也就看不到它的原型，那它会<strong>默认 malloc 的返回值为 int 型</strong>，如以下程序。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(void)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    int *p = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    p = malloc(sizeof(int));</span><br><span class=\"line\">    if(p == NULL)</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>默认 malloc 函数的返回值为 int 型后，而程序中接收的是 int* 型指针，这样就会报错。有人会这样解决问题：<code>p = (int*)malloc(sizeof(int));</code>,使用强制转换类型，有时有些编译器不会报错，但是以后经过移植或换个环境等的时候，这个问题就会出现，导致很难找出来。通过 man malloc 查看可知：</p>\n<p><img src=\"/Learn/%E7%BC%96%E7%A8%8B%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98.htm/malloc.png\" alt=\"malloc函数\" class=\"φcx\"></p>\n<p>malloc 函数返回的是 void* 类型的值，而 void 可以转变为大部分的类型，所以可以这样写 <code>p = malloc(sizeof(int))</code></p>\n<p>以后使用 gcc 编译时可以用参数 -Wall ,它会显示全部错误，你只要按照出现的错误一个个解决，后面出现的大部分错误都是来源于这，因为你不把这些错误用 -Wall 打印出来，gcc 有些错误在你编译时没有非常严重的错误，它是会忽略的。</p>\n<p>例：<code>gcc hello.c -Wall</code></p>\n<h4 id=\"2.-以函数为单位来进行程序编写\">2. 以函数为单位来进行程序编写<a title=\"#2.-以函数为单位来进行程序编写\" href=\"#2.-以函数为单位来进行程序编写\"></a></h4>\n<h4 id=\"3.-声明部分-+-实现部分\">3. 声明部分 + 实现部分<a title=\"#3.-声明部分-+-实现部分\" href=\"#3.-声明部分-+-实现部分\"></a></h4>\n<h4 id=\"4.-对于宏定义的理解\">4. 对于宏定义的理解<a title=\"#4.-对于宏定义的理解\" href=\"#4.-对于宏定义的理解\"></a></h4>\n<p><code>#define</code> 处理在程序的预处理阶段，占编译时间，特点是，一改全改。缺点：<strong>不检查语法</strong>，只是单纯的宏体与宏名之间的替换。例如以下程序：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#define ADD 2 + 3</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        printf(&quot;%d\\n&quot;,ADD * ADD);</span><br><span class=\"line\"></span><br><span class=\"line\">        exit(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>结果为：11</p>\n<p>明显结果不是我们想要的 25，我们用 gcc 的预编译命令 <code>gcc -E defind.c</code> 查看</p>\n<p><code>printf(&quot;%d\\n&quot;,ADD * ADD);</code><br>\n<code>printf(&quot;%d\\n&quot;,2+3 * 2+3);</code></p>\n<p>从这里可知宏定义就只是在预编译时单纯的将宏体替换宏名。这里想要正确输出，则要这样定义：<code>#define ADD (2+3)</code></p>\n<p>带参数形式的使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#define MAX(a,b)   (a &gt; b ? a : b)</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        int i = 5, j = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">        printf(&quot;%d\\n&quot;,MAX(i,j));</span><br><span class=\"line\"></span><br><span class=\"line\">        exit(0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出为：5<br>\n但是逻辑上 a 和 b 也应该各自加上括号，因为传参时的数要考虑到运算的优先级,因为无论是 a 还是 b 在这里都是单独的个体，且可以是 a = 1 + 3 的形式，这样组合起来就要考虑优先级问题，1 + 3 是要自己单独运算的。</p>\n<p><code>#define MAX(a,b)   ((a) &gt; (b) ? (a) : (b))</code></p>\n<p>当程序改成如下后</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#define MAX(a,b)   ((a) &gt; (b) ? (a) : (b))</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        int i = 5, j = 3;       </span><br><span class=\"line\">       </span><br><span class=\"line\">        printf(&quot;i = %d\\tj = %d\\n&quot;,i,j);</span><br><span class=\"line\">        printf(&quot;%d\\n&quot;,MAX(i++,j++));</span><br><span class=\"line\">        printf(&quot;i = %d\\tj = %d\\n&quot;,i,j);</span><br><span class=\"line\"></span><br><span class=\"line\">        exit(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>将参数改成 i++ 和 j++。结果输出如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = 5\tj = 3</span><br><span class=\"line\">6</span><br><span class=\"line\">i = 7\tj = 4</span><br></pre></td></tr></table></figure>\n<p>理论上 i = 5 和 j = 3 先进行比较，然后各自自增，i 大，则第二行的输出结果为 i 自增后的结果6（先比较后自增），第三行应为 i = 6，j = 4.可结果不是。<br>\n预编译的结果为</p>\n<p><code>printf(&quot;%d\\n&quot;,((i++) &gt; (j++) ? (i++) : (j++))); </code></p>\n<p>根据这串语句可知，i 和 j 先比较，然后各自自增，由于 i 大，则执行 ？ 后面的 i++，这样 i 就再次自增了一次，所以第三行的 i 为自增了两次的。</p>\n<p>解决方法：像函数的参数一样，用变量接收自增后的结果，而不是在比较完后，又将参数 i++ 执行一次，而是执行的是 i++的结果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define MAX(a,b)   (&#123;</span><br><span class=\"line\">                        int A = a, B = b;</span><br><span class=\"line\">                        ((A) &gt; (B) ? (A) : (B));</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">i = 5\tj = 3</span><br><span class=\"line\">5</span><br><span class=\"line\">i = 6\tj = 4</span><br></pre></td></tr></table></figure>\n<p>预编译结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">printf(&quot;%d\\n&quot;,(&#123;int A = i++, B = j++; ((A) &gt; (B) ? (A) : (B));&#125;));</span><br></pre></td></tr></table></figure>\n<p>这样用变量接收后，则在比较完后执行时就不是执行 i++了，而是执行 A 这个值。<br>\n有时参数未必都是 int 型，则可以</p>\n<p><code>#define MAX(a,b)   (&#123;typeof(a) A = a, B = b; ((A) &gt; (B) ? (A) : (B));&#125;) </code></p>\n<p>用 a 的类型定义 A , B。用 typeof() 函数获取类型。</p>\n","link":"Learn/编程注意的问题","comments":true,"plink":"https://CHONG589.github.io/Learn/编程注意的问题/","reward":true,"copyright":{"published":"2024年1月28日","updated":"2024年3月11日","author":"Chong","link":"<a href=\"https://CHONG589.github.io/Learn/编程注意的问题/\" title=\"编程注意的问题\">https://CHONG589.github.io/Learn/编程注意的问题/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}