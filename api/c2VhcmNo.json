[{"title":"函数中指针传参问题","date":"2024-02-16T07:51:58.000Z","date_formatted":{"ll":"2024年2月16日","L":"2024/02/16","MM-DD":"02-16"},"author":"Chong","updated":"2025-04-10T08:00:47.894Z","content":"在函数中进行指针传参时，尤其要注意指针传过去后，在函数里的操作是不是在本指针下进行，有可能是在指针的复制品中进行的，函数执行完后，把里面的变量等被销毁，这样就相当于对传过来的指针什么操作都没有做。\n\n下面有几个关于这个的例子\n\n例一：\n\n123456789101112131415161718void func (int **p, int n) &#123;    // 这就相当于将分配内存的首地址给了 main 中的 p;    *p = malloc (n);                if (p = NULL)        exit (1);    return ;&#125;int main () &#123;    int num = 100;    int *p = NULL;    // 传指针变量所在的地址    func (&amp;p, num);             free (p);    exit (0);&#125;\n\n例二：\n\n1234567891011121314151617void sqlist_create1 (sqlist **ptr) &#123;    *ptr = malloc (sizeof (**ptr));    if (*ptr == NULL)        return ;      (*ptr) -&gt; last = -1;    return ;&#125;sqlist *list = NULL;datatype arr[] = &#123;12, 23, 34, 45, 56&#125;;datatype arr1[] = &#123;78, 89, 56, 23, 10&#125;;sqlist_create (&amp;list);if (list == NULL) &#123;\tfprintf (stderr, &quot;sqlist_create () failed!\\n&quot;);\texit (1);&#125;   \n\n例三：\n\n有头节点的链表创造\n123456789list *list_create () &#123;    list *me;    me = malloc (sizeof (*me));    if (me == NULL)        return NULL;    me -&gt; next = NULL;    return me;&#125;\n从这里可知，无论是有头节点还是无头节点，在创造链表的函数中，都有这个问题，要么是要把函数里创造好的链表传回来，要么就是用二级指针传参过去，即当在 main 函数中定义了一个指针后，不能只是这样将一个空指针传过去，这样只会是在函数中复制一个复制品，用二级指针则意味着是操作的就是这个指针。即指针为空时，要注意传参问题。\n12345678910111213141516171819202122// 注意：在操作无头节点时，函数的传参形式尤其要注意，比如在这里，me 是有可能被 free () 掉的，// 如果最后，没将 me = q; me 就会丢失掉（即链表丢失），main 函数里调用 show 就会出现段错误，// 因为 me 已经被释放掉，你再访问就段错误了。而带头节点的就不会有此类问题，因为头指针一直都是// 指着头节点的，而头节点无论怎么样都不会被释放掉或者是改变，在操作时会跳过头节点操作。node_st *jose_kill (node_st *me, int n) &#123;    node_st *p, *q = me;    int i;      while (q -&gt; next != q) &#123;        for (i = 1; i &lt; n; i++) &#123;            p = q;            q = q -&gt; next;        &#125;        printf (&quot;delete: %d\\n&quot;, q -&gt; data);        p -&gt; next = q -&gt; next;        free (q);        q = p -&gt; next;         &#125;    me = q;    return me;&#125;\n这里的问题就是在 kill 的过程中会把 me 指向的节点 free () 掉，要把 me 重新指向后返回来，至于为什么还要返回，是因为当 me free () 后， me 就相当于空指针，什么都没有，则在实参传过来的什么都没指向，而最后将 me = q; 对它操作同上面的原理一样，要返回来。\n而关于销毁链表的函数不用，一是因为在一个一个销毁的过程中也没丢失头指针的指向，二是因为最后返回来的本来就是什么都没有的，只要把指针指向的空间 free () 掉就行。\n对于有头节点的删除节点不会有这个问题，始终有头节点在那，而无头结点的删除可能要注意一下。\n","thumbnail":"2024/函数中指针传参问题/./nsurlprotocol.png","plink":"https://CHONG589.github.io/2024/函数中指针传参问题/"},{"title":"重定义 typedef","date":"2024-02-06T06:36:57.000Z","date_formatted":{"ll":"2024年2月6日","L":"2024/02/06","MM-DD":"02-06"},"author":"Chong","updated":"2025-04-10T08:00:57.410Z","content":"typedef 与 define 的区别\n12345#define IP int *IP p, q;    --&gt; int *p, q;typedef int *IP;IP p, q;    --&gt; int *p, *q;\ndefine 只是简单的替换，typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。\ntypedef 的本质\n1234567891011typedef int ARR[6];         --&gt; int [6] -&gt; ARR;  // int [6] 为数组的本质ARR a; --&gt; int a[6];// ------------------------------------------------------typedef int FUNC (int);     --&gt; int (int)   FUNC;FUNC f; --&gt; int f(int); typedef int *FUNCP (int);FUNC p; --&gt; int *p (int);\n","thumbnail":"2024/重定义-typedef/./xcode-clean.png","plink":"https://CHONG589.github.io/2024/重定义-typedef/"},{"title":"段错误","date":"2024-02-06T05:10:50.000Z","date_formatted":{"ll":"2024年2月6日","L":"2024/02/06","MM-DD":"02-06"},"author":"Chong","updated":"2025-04-10T08:00:34.820Z","content":"段错误（Segmentation Fault）是一种常见的运行时错误，通常发生在访问未分配的内存或者试图读写不允许访问的内存区域时。虽然段错误本身是一个简单的错误，但却可能导致程序不可预测的行为，甚至是崩溃，在Linux中也会导致许多软件无法正常运行。\n\n段错误的原因\n未分配的内存\n当程序试图访问未经分配的内存区域时，会触发段错误。这可能是因为 忘记分配内存 或者 试图访问已经释放的内存。\n12int *ptr;*ptr = 10;      // 未分配内存\n定义了指针要为其分配内存才能使用，我们平时直接指向变量、数组等，好像并没有分配内存也直接用了，其实你在定义变量、数组后，已经为变量，数组分配了空间，你让指针指向它们，是可以直接使用的。\n内存越界\n尝试访问数组或其他数据结构的超出边界的元素，导致访问了不允许访问的内存区域。\n空指针引用\n试图使用空指针访问内存中的数据，导致段错误。\n12int *ptr = NULL;int value = *ptr; // 空指针引用，导致段错误\n还有在释放了内存后，通常将指针指向 NULL, 防止之后访问该指针，如果之后又访问了该指针就会报段错误\n12345678910111213141516int main () &#123;    int *p = NULL;    p = malloc (sizeof (int));          if (p == NULL) &#123;        printf (&quot;malloc () error!&quot;);        exit (1);                              &#125;    *p = 11;    printf(&quot;%d\\n&quot;, *p);    free (p);                       // 释放空间    p = NULL;                       // 防止后面访问                                  exit (0);&#125;\n栈溢出\n当递归函数调用层级太深或者局部变量占用过多栈空间时，可能导致栈溢出，触发段错误。\n未初始化的指针\n使用未初始化的指针进行内存访问，会引发段错误。\n内存保护\n一些操作系统或硬件平台会对某些内存区域进行保护，试图修改这些区域的内容会导致段错误。\n12const char *str = &quot;Hello, World!&quot;;str[0] = &#x27;h&#x27;; // 尝试修改只读内存，导致段错误\n文件操作错误\n尝试读写一个不可访问的文件或者试图操作不存在的文件也可能引发段错误。\n","thumbnail":"2024/段错误/./apple.png","plink":"https://CHONG589.github.io/2024/段错误/"},{"title":"动态内存管理","date":"2024-02-05T08:40:25.000Z","date_formatted":{"ll":"2024年2月5日","L":"2024/02/05","MM-DD":"02-05"},"author":"Chong","updated":"2025-04-10T08:00:25.243Z","content":"内存分配相关函数\n在头文件 #include &lt;stdlib.h&gt; 中\n123456// 一个成员 size 大小空间，共分配给 nmemb 个成员void *calloc (size_t nmemb, size_t size);   void *malloc (size_t size);void free (void *ptr);// 已分配的空间不够，重新分配 size 大小的空间(size 包含了原先的大小)void *realloc (void *ptr, size_t size);     \n原则：谁申请，谁释放\n123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main () &#123;    int *p = NULL;    // 没必要这样 p = (int *)malloc (sizeof (int)); 加一个强制转换    // void * 适合任何类型    p = malloc (sizeof (int));          if (p == NULL) &#123;\t    // 分配失败，结束进程        printf (&quot;malloc () error!&quot;);        exit (1);                               &#125;    *p = 11;    printf(&quot;%d\\n&quot;, *p);    free (p);                 exit (0);&#125;\n相关面试题\n1234567891011121314151617void func (int *p, int n) &#123;    p = malloc (n);    if (p = NULL)        exit (1);    return ;&#125;int main () &#123;    int num = 100;    int *p = NULL;    func (p, num);    free (p);    exit (0);&#125;\n这段程序的问题：\nmain 中 p 指向了 NULL( NULL 在地址为 0 的位置)，然后传给形参，使 func 中的 p 也指向了 NULL ，即指向了地址为 0 的位置。\n然后 func 中为它的 p 分配了内存(计算机找到对应需要的连续空间，并把该空间的首地址给 func 中的 p)，这时其实两个 p 已经指向了不同的空间了(因为传参时形参是复制了一份实参的值,这里复制了指针的地址,使之也指向了 NULL,这时是两个指针，只不过是指向了同一个地址，但之后为另一个指针分配了空间，使 func 里的 p 指向了另一个空间)。\n在调用的函数运行完后，在该函数中的变量，指针变量会自动释放，因为这些变量只在该函数中存在，所以这样的话，func 中的 p 存的首地址就丢失了，但 func 里分配的空间。\n又没释放，在 main 中释放的是一个空指针，这就导致了内存泄漏。\n改进方法：\n第一种：采用二级指针\n123456789101112131415161718void func (int **p, int n) &#123;    *p = malloc (n);            // 这就相当于将分配内存的首地址给了 main 中的 p;    if (p = NULL)        exit (1);    return ;&#125;int main () &#123;    int num = 100;    int *p = NULL;    func (&amp;p, num);         // 传指针变量所在的地址    free (p);    exit (0);&#125;\n第二种方法\n123456789101112131415161718void *func (int *p, int n) &#123;    p = malloc (n);    if (p = NULL)        exit (1);    return p;&#125;int main () &#123;    int num = 100;    int *p = NULL;    p = func (p, num);    free (p);    exit (0);&#125;\n有关 free 的理解：\n有时我们在已经释放的内存中再进行操作，如 free § 后，又进行 *p = 123;, 这是很严重的错误，因为这个空间很可能其他设备已经在使用。\n意识：在 free § 后，再 p = NULL;如果我们后面又对 p 进行了操作，程序会报段错误，这样就防止了污染其它空间。\n","thumbnail":"2024/动态内存管理/./thumb.png","plink":"https://CHONG589.github.io/2024/动态内存管理/"},{"title":"构造类型","date":"2024-02-04T09:47:18.000Z","date_formatted":{"ll":"2024年2月4日","L":"2024/02/04","MM-DD":"02-04"},"author":"Chong","updated":"2024-12-25T07:07:25.000Z","content":"结构体\n产生及意义\n类型描述(不占存储空间)，描述是怎样一个结构，是一个类型，如 int、char\n12345struct 结构体名 &#123;\t数组类型 成员1；\t数据类型 成员2；\t......  &#125;；\n嵌套定义\n123456789101112struct birthday_st &#123;\tint year;\tint month;\tint day;&#125;;struct student_st &#123;\tint id;\tchar name[NAMESIZE];\tstruct birthday_st birth;\tint math;\tint chinese;&#125;;\n或\n1234567891011struct student_st &#123;\tint id;\tchar name[NAMESIZE];\tstruct birthday_st &#123;\t\tint year;\t\tint month;\t\tint day;\t&#125;birth;\tint math;\tint chinese;&#125;;\n定义变量(变量、数组、指针)、初始化及成员引用\n\n\n成员引用：变量名.成员名\n像上面 struct birthday_st birth 定义变量的方式，这个变量名 birth 存的只是结构体的首地址。\n\n\n成员引用：指针 -&gt; 成员名 (*指针).成员名\n\n\n占用内存空间大小\n内存对齐\n函数传参（值，地址）\n一般不用结构体的值(即整个结构体)传参，因为当结构体里的成员很多时，定义形参时也要相对应的大小，内存开销大，所以我们一般传指针，形参只需定义指针即可，而指针变量大小在同一机器中时是固定。\n共用体\n产生及意义\n共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。\n类型描述\n123456union [union tag] &#123;member definition;member definition;...member definition;&#125; [one or more union variables];\nunion tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。\n嵌套定义\n练习：对一个具有 32 位值的高 16 位和低 16 位进行相加\n\n方法一：根据共用体和结构体的特性进行解决\n\n1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;union &#123;\tstruct &#123;\t\tuint16_t i;\t\tuint16_t j;\t&#125;x;\tuint32_t y;&#125;a;int main () &#123;\ta.y = 0x11223344;\tprintf(&quot;%x&quot;, a.x.i + a.x.j);\texit (0);&#125;\n\n方法二：用位运算解决\n\n123456789#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;int main () &#123;\tuint32_t i = 0x11223344;\tprintf(&quot;%x\\n&quot;, (i &gt;&gt; 16) + i &amp; 0xffff);\texit (0);&#125;\n定义变量（变量、数组、指针），初始化及成员引用\n跟结构体一样\n占用内存空间大小\n共用体占用的内存应足够存储共用体中最大的成员\n函数传参（值，地址）\n位域\nC 语言的位域（bit-field）是一种特殊的结构体成员，允许我们按位对成员进行定义，指定其占用的位数。\n1234struct &#123;\tint i;\tint j;&#125;a;\n这种结构需要 8 字节的内存空间，但在实际上，在每个变量中，我们只存储 0 或 1，在这种情况下，C 语言提供了一种更好的利用内存空间的方式。如果您在结构内使用这样的变量，您可以定义变量的宽度来告诉编译器，您将只使用这些字节。例如，上面的结构可以重写成：\n1234struct &#123;\tint i: 1;\tint j: 1;&#125;a;\n现在，上面的结构中，a 变量将占用 4 个字节的内存空间(内存对齐的原因)，但是只有 2 位被用来存储值。如果您用了 32 个变量，每一个变量宽度为 1 位，那么 a 结构将使用 4 个字节，但只要您再多用一个变量，如果使用了 33 个变量，那么它将分配内存的下一段来存储第 33 个变量，这个时候就开始使用 8 个字节。\n枚举\n枚举是 C 语言中的一种基本数据类型，用于定义一组具有离散值的常量，它可以让数据更简洁，更易读。枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性。\n定义一个枚举类型，需要使用 enum 关键字，后面跟着枚举类型的名称，以及用大括号 {} 括起来的一组枚举常量。每个枚举常量可以用一个标识符来表示，也可以为它们指定一个整数值，如果没有指定，那么默认从 0 开始递增。枚举语法定义格式为：\n123enum　枚举名　&#123;    枚举元素1,枚举元素2,……&#125;;\n接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：\n1234567#define MON  1#define TUE  2#define WED  3#define THU  4#define FRI  5#define SAT  6#define SUN  7\n这个看起来代码量就比较多，接下来我们看看使用枚举的方式：\n123enum DAY &#123;      MON=1, TUE, WED, THU, FRI, SAT, SUN&#125;;\n注意：第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。\n可以用 enum 当成宏来使用，enum 在预处理后，里面的值不会替换，这样在查看哪里错的时候，这样才能更直观的知道这个变量是干嘛的，而不是被替换成了值。\n","thumbnail":"2024/构造类型/./thumb.png","plink":"https://CHONG589.github.io/2024/构造类型/"},{"title":"函数","date":"2024-02-02T14:01:05.000Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"author":"Chong","updated":"2025-04-10T07:58:27.725Z","content":"定义\n\n数据类型 函数名 (形参说明)\n\n123int main(int argc, char *argv[]) &#123;    return 0;&#125;\nargc 是一个计数器，计算从终端传了多少个参数过来。argv[] 是一个列表，用来保存传过来的参数。\n函数的传参\n\n值传参\n地址传参\n全局变量\n\n函数的调用\n嵌套调用\n递归调用 (面试常考，非常考验编程功底)\n阶乘\n1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int func(int n) &#123;\tif (n &lt; 0)\t\treturn -1;\t\t//递归出口\tif (n == 0 || n == 1)\t\treturn 1;\treturn n * func (n - 1);&#125;int main() &#123;\tint n;\tint res;\t\tscanf(&quot;%d&quot;,&amp;n);\tres = func(n);\tprintf(&quot;%d! = %d\\n&quot;,n,res);\t\texit(0);&#125;\n斐波那契数列\n1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//1, 1, 2, 3, 5, 8, 13, 21, 34......//n = (n - 1) + (n - 2)//(n == 1 || n == 2)  ---&gt;   return 1;  int fib(int n) &#123;\tif (n &lt; 0)\t\treturn -1;\tif (n == 1 || n == 2)\t\treturn 1;\t\treturn fib(n - 1) + fib(n - 2);&#125;int main() &#123;\tint n;\tint res;\tprintf(&quot;请输入你要求的斐波那契数列的项数：\\n&quot;);\tscanf(&quot;%d&quot;,&amp;n);\tres = fib(n);\tprintf(&quot;fib[%d] = %d\\n&quot;,n,res);\texit(0);&#125;\n函数与数组\n数组传参方式\n传参时传的是数组的首地址，所以还要传数组的大小。\n1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void print_arr(int *p, int n) &#123;\tint i;\t\tfor (i = 0; i &lt; n; i++)\t\tprintf(&quot;%d &quot;, p[i]);\tprintf(&quot;\\n&quot;);&#125;int main () &#123;\tint a[] = &#123;1, 2, 3, 6, 6, 7&#125;;\tprint_arr(a, sizeof(a) / sizeof(*a));\texit(0);&#125;\n在 print_arr 函数中，接收数组的是一个指针变量，也就是接收的是数组首地址，实际上这个函数是不知道数组的大小的，只知道数组首地址，而在定义函数时用 sizeof(p) / sizeof(*p) 是不可行的，sizeof§ 肯定是 8 字节 (在 64 位机器中)，这是固定的，这算出来的是接收地址的指针变量的大小，并不是数组的大小。所以在传参时要传数组的大小。\n1void print_arr (int p[], int n)\n数组退化成指针：定义时这样写成数组的形式，看似好像是把整个数组传过去了，实则不然，它的含义仍然是指针变量，跟上面是一样的。\n所以在形参中定义成数组的形式和在 main 函数中定义时是不一样的，作为形参时，它就是指针变量。\n1234567int a[N] = &#123;1, 2, 4, 5, 6&#125;;int *p = a;//下面是传入实参时，形参对应接收的类型实参： a      *a     a[0]    &amp;a[3]    p[i]    p      *p       p+1\t\t\t\t   *(a+0)           *(p+i)         *(p+0)形参：int *   int    int     int *    int     int*   int      int*     \n数组逆序实现\n123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void func (int *a, int n)&#123;\tint i, j, tmp, mid;\tmid = (n - 1) / 2;\tfor(i = 0; i &lt;= mid; i++)&#123;\t\tj = n - 1 -i;\t\ttmp = a[i];\t\ta[i] = a[j];\t\ta[j] = tmp;\t&#125;&#125;int main () &#123;\tint a[] = &#123;1, 3, 5, 7, 9, 0&#125;;\t//puts(a);     puts 是用于输出 char * \tint i;\tfor(i = 0; i &lt; sizeof(a) / sizeof(*a); i++)\t\tprintf(&quot;%d &quot;, a[i]);\tprintf(&quot;\\n&quot;);\tfunc(a, sizeof(a) / sizeof(*a));\tfor(i = 0; i &lt; sizeof(a) / sizeof(*a); i++)\t\tprintf(&quot;%d &quot;, a[i]);\tprintf(&quot;\\n&quot;);\texit(0);&#125;\n函数与二维数组\n方式一：\n1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M   3#define N   4void print_arr (int *p, int n) &#123;\tint i;\tfor(i = 0; i &lt; n; i++)&#123;\t\tprintf(&quot;%d &quot;, p[i]);\t&#125;\tprintf(&quot;\\n&quot;);&#125;//如果 print_arr 直接传 a，那么在形参中定义时是这样：int (*p)[N]。int main () &#123;\tint a[M][N] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;;\t\tprint_arr(&amp;a[0][0], M * N);\texit(0);&#125;\n注意这里函数的形参采用的是一级指针接收，传入的实参不能直接传 a, a 为二维数组，为行指针，一级指针只能在列指针中移动，所以实参应转化为列指针 &amp;a[0][0] 传入, 把二维数组当成一个大的一维数组，个数为 M * N 。这里 &amp;a[0][0] 还可以为 *a 、a[0]、*(a + 0)。\n方式二：\n1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M   3#define N   4//二维数组 a 的本质就是一个数组指针，指向数组的指针//void print_arr(int p[][N], int m, int n)void print_arr (int (*p)[N], int m, int n) &#123;      \tint i, j;\t//结果为：8，所以也是一个指针变量，不过这个指向的是一个数组，数组大小为 N 个元素\tprintf(&quot;sizeof(p) = %d\\n&quot;, sizeof(p));   \tfor(i = 0; i &lt; m; i++)&#123;\t\tfor(j = 0; j &lt; n; j++)&#123;\t\t\tprintf(&quot;%4d &quot;, *(*(p + i) + j)); \t\t\t//printf(&quot;%4d &quot;, p[i][j]);     \t\t&#125;\t\tprintf(&quot;\\n&quot;);\t&#125;\tprintf(&quot;\\n&quot;);&#125;int main () &#123;\tint a[M][N] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;;\tprintf(&quot;sizeof(a) = %d\\n&quot;,sizeof(a));      // 结果为 48\tprint_arr(a, M, N);\texit(0);&#125;\n如果想在实参中传入一个二维数组，而不是把它当成一维数组传入，那么在函数定义时的形参中要有与二维数组相对应的类型，前面已学过 二维数组的本质就是数组指针，所以要接收一个二维数组，就应该在形参中用数组指针接收，a + 1 和 p + 1 效果是一样的，都是行指针。int (*p)[N] 中 N 为二维数组的列数。将二维数组接收过来后，对应的行数和列数也接收过来了，接下来就跟平时处理二维数组时一样。\n同样，跟一维数组一样，传过来的数组，接收的是首地址，同样不知道大小，所以还要传大小参数。\n123456int a[M][N] = &#123;&#125;;int *p = *a;int (*q)[N] = a;实参：a[i][j]  *(a+i)+j   a[i]+j   p[i]   *p    q[i][j]    *q       q           p+3\t\t\t\t\t\t\t\t\t\t\t形参：int       int*       int*    int    int    int       int*   int (*)[N]    int*    \n练习题\n求每个学生的平均成绩\n1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M   3#define N   5void print_arr (float (*p)[N], int m, int n) &#123;\tint i, j;\tprintf(&quot;  科目一  科目二  科目三   科目四  平均\\n&quot;);\tfor(i = 0; i &lt; m; i++)&#123;\t\tfor(j = 0; j &lt; n; j++)&#123;\t\t\tprintf(&quot;%7.2f &quot;, *(*(p + i) + j));\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t&#125;\tprintf(&quot;\\n&quot;);&#125;// 求每个学生的平均成绩，并把平均成绩写在后面void average (float (*p)[N], int m, int n) &#123;\tint i, j;\tfor(i = 0; i &lt; m; i++)&#123;\t\tfloat tmp = 0;\t\tfor(j = 0; j &lt; n; j++)&#123;\t\t\ttmp += p[i][j]; \t\t&#125;\t\tp[i][4] = tmp / (N - 1);\t&#125;&#125;int main () &#123;\tfloat a[M][N] = &#123;&#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;, &#123;9, 10, 11, 12&#125;&#125;;\t\taverage(a, M, N);\tprint_arr(a, M, N);\texit(0);&#125;\n\n求总平均成绩和把指定学生的四科成绩打印出来\n12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M   3#define N   4float average_scope(int *p, int n) &#123;\tfloat sum = 0;\tint i;\tfor(i = 0; i &lt; n; i++) &#123;\t\tsum += p[i];\t&#125;\treturn sum / n;&#125;void find_num(int (*p)[N], int num) &#123;\tint i;\tfor(i = 0; i &lt; N; i++) &#123;\t\tprintf(&quot;%d &quot;, *(*(p + num) + i));\t&#125;\tprintf(&quot;\\n&quot;);&#125;int main () &#123;\tint a[M][N] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;;\tint i, j;\tfloat ave;\tint num = 0;\tave = average_scope(*a, M * N);\tprintf(&quot;ave = %.2f\\n&quot;, ave);\tfind_num(a, num);\texit(0);&#125;\n函数与字符数组\n[[05_字符串]]\n函数与指针\n指针函数 (返回值为指针)\n根据 Type name 可知，指针函数是定义函数，所以为\n\n定义形式：返回值 函数名 (形参)  如：int *fun (int)\n\n用途：例如前面 find_num 的实现，它只让你找到第几个学生的成绩，并没有让你输出，你却遍历输出那个学生的成绩，显然不是最完美的解决方案，这时就可以用返回一个指向函数的指针。\n理论上的实现方式 (返回了整个数组)：\n123int (*)[N] find_num (int (*p)[N], int num) &#123;    return (p + num);&#125;\n把指针 p 移动到第 num 的学生的位置，由于 p 为行指针，所以理论上要这样写返回值就也要为对应的类型，即也要行指针，所以返回值为 int (*)[N]，但是我们就只是想要得到第 num 行的那些数据，根本不需整个二维数组的形式返回来，只需在 num 行使用列指针即可，所以可以这样：\n1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M   3#define N   4int * find_num (int (*p)[N], int num) &#123;    if (num &gt; M - 1)        return NULL;       // 不能写 -1，因为返回类型为指针    return *(p + num);     // 也可 p[num];&#125;int main () &#123;    int a[M][N] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;;    int i, j;    int num = 0;    int *res;    res = find_num(a, num);    if (res != NULL) &#123;        for(i = 0; i &lt; N; i++)            printf(&quot;%d &quot;, res[i]);        printf(&quot;\\n&quot;);    &#125;    else &#123;        printf(&quot;Can not find!\\n&quot;);    &#125;    exit(0);&#125;\n函数指针\n记忆：整型指针为指针指向整型，那么函数指针自然就是指向函数的指针。\n根据 Type name 可知，函数指针是定义指针，所以为\n\n定义形式：类型 (*指针名)(形参)  如: `int (*p)(int);\n\n\n类型：int (int) --&gt; 函数和形参的类型，即返回类型。\nname:  *p ，即定义指针\n两个合起来就为 int (*p)(int);，即函数指针。\n\n1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int add (int a, int b) &#123;    return a + b;&#125;int main () &#123;    int a = 3, b = 5;    int ret;    int (*p) (int, int);    p = add;            // 也可 p = &amp;add; 函数名跟数组名一样，就是个地址    //ret = add(a, b);  // 原来的写法    ret = p(a, b);    printf (&quot;%d\\n&quot;, ret);      exit(0);&#125;\n函数指针数组\n\n指针数组：数组中每个元素就是一个指针，如：int *arr[N]\n函数指针：指向函数的指针，如：int (*p)(int) \n函数指针数组：数组中每个元素都是一个指向函数的指针\n\n可以理解为定义指针数组，返回值为一个函数，也可以理解为定义一个数组，返回值为函数指针。\n\n定义：类型 (*数组名[下标])  (形参) 如：int (*arr[N]) (int);\n类型：int (int) --&gt; 函数和形参的类型\nname: *arr[N] \n两个合起来就为 int (*arr[N])(int);\n\n指向指针函数的函数指针数组\n这样理解：其实就是函数指针数组，只不过将这个返回值是函数改成返回值为指向函数的指针。\n\n指针数组：*arr[N]\n指针函数：int *func(int)\n将指针函数改为匿名函数，即 int *(int)，将它作为返回值，即：int *(*arr[N])(int)\n\n总结\n自己的理解：为什么不能直接调用函数，而是特地定义指针来，因为函数名是地址常量，函数指针是指针变量，有区别，就跟前面学的指针变量跟数组名一样的区别。\n老师讲解：传参时如果传一个函数名过去(因为可能要用到某函数，将此函数传过去用)，这时形参就要定义一个同类型的来接收。\n\n传整形数     ----&gt;    整型指针接收\n传数组名     ----&gt;    指针接收\n函数名         ----&gt;    指向函数的指针来接收\n\n如：快速排序的封装\n1void qsort (void *base, size_t nmemb, size_t size, int (*compar) (const void *, const void *));\n此方式定义为函数指针，返回值为函数，总之就是为了满足传参的要求，这些函数叫 回调函数。\n\n数组指针：像整型指针为指向整型的指针，而数组指针则为指向数组的指针。\n\n1234Type nameType ---&gt; 数组 ---&gt; int[N]name ---&gt; 指针 ---&gt; *pType name ---&gt; int (*p)[N];\n\n指针数组：数组中每个元素就是一个指针。\n\n123Type ---&gt; int *name ---&gt; arr[N]Type name ---&gt; int *arr[N]\n\n指针函数：定义函数\n\n1234返回值 函数名 （形参）返回值 ---&gt; int *函数名 ---&gt; funcint *func(int)\n\n函数指针：指向函数的指针，定义指针\n\n1234Type nameType ---&gt; int (int)name ---&gt; *pint (*p) (int)\n\n函数指针数组：数组中每个元素都是一个指向函数的指针\n\n12345指针数组：int *arr[N]函数指针：int (*p) (int)只需将函数指针的指针名改为数组的形式就可int (*arr[N])(int)\n\n指向指针函数的函数指针数组\n\n1int *(*func[N])(int)\n","thumbnail":"2024/函数/./thumb.png","plink":"https://CHONG589.github.io/2024/函数/"},{"title":"指针与变量","date":"2024-02-02T13:55:50.000Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"author":"Chong","updated":"2025-04-10T07:59:20.531Z","content":"1. 变量与地址\n12int i = 1;int *p = &amp;i;\np 就是一个指针变量，用来存放变量 i 的地址值，所以我们平常所说的定义一个指针指向一个值，其实就是定义一个指针变量来存放这个值的地址。\n1int **q = &amp;p;\np 是一个指针变量，q 是用来存放指针变量 p 的地址值的变量，即定义时一个 * 指存放地址的变量，** 指是用来存放指针变量的地址的变量。要满足两边的类型相同。\n1234int *p;float *q;double *d;char *c;\n不管定义的是什么类型的指针变量 (即我们通常说的指针)，是几级的指针，以及定义的结构体类型的指针，其在某一个平台上所占的空间是确定的大小，在 64 位的机器上占 8 个字节。\n不同类型的指针，其在运算时，如 *p 在做取值运算时，若 p 为 char ，则取一个字节，int 时，则取四个字节，所以什么类型的数据，要对应什么类型的指针，不然在取值时取得的大小与实际不符。\n2. 指针与指针变量(上面也有解释)\n\n指针：就是一个地址，是常量，不会变的。\n指针变量：用来存放指针的变量，可以改变。\n我们常说的某指针指向谁，哪个指针又指向谁，是指改变指针变量的值。\n\n3. 直接访问与间接访问\n123456789int i = 1;int *p = &amp;i;    int **q = &amp;p; i --&gt; 1                        q --&gt; 0x3000 --&gt; &amp;p&amp;i --&gt; 0x2000                   &amp;q --&gt; 0x4000  p --&gt; 0x2000    --&gt; &amp;i         *q --&gt; *(&amp;p)  --&gt; &amp;i&amp;p --&gt; 0x3000                  **q --&gt; *(*q)  --&gt; *(&amp;i) --&gt; 1*p --&gt; *(0x2000) --&gt; 1\n\n4. 空指针与野指针\n\n野指针：int *p = 0x2000; 这种直接赋地址的形式，因为你不知道这块地址是否可用，通常很危险。\n空指针：int *p = NULL; NULL 即为位于地址 0 的位置，0 号地址不分配给任何进程，指针定义出来后暂时还不知道指向哪里时，则将它指向 NULL；\n\n5. 空类型\n1void *q = NULL;     \n\n任何类型的指针值都能够把自己的值赋给 void *， void * 也能够把当前自己的值赋给任何类型的指针。当自己不知道要用到什么类型的值时使用。\n\n6. 定义与初始化的书写规则\n7. 指针运算\n1*     &amp;   关系运算   ++   --\n*p++：等同于：*p;  p += 1;\n解析: 但是，因为 ++ 后置 的时候，本身含义就是先运算后增加1（运算指的是 p++ 作为一个整体与前面的 * 进行运算；增加 1 指的是 p + 1），所以实际上 *p++ 符号 整体对外表现的值 是 *p 的值，运算完成后  p 再加 1。\n*++p：等同于 p += 1; *p;\n解析： 由于 ++ 在 p 的前面，++ 前置的含义是，先 p 加1，得到一个新的 p（它的值是原来 p 的值加1）。然后这个新的 p 再与前面的  * 结合。\n8. 指针与数组\n指针与一维数组\n123456int a[3] = &#123;1,2,3&#125;;int *p = a;int i;a[i] = *(a + i) = *(p + i) = p[i];&amp;a[i] = a + i = p + i = &amp;p[i];\n这样看来指针 (指针变量) 好像是等价于一维数组的，但是它们是不完全等价的，首先，a 是地址，是一个常量，p 是指针变量，是一个变量，a++ 是不能运算的 (a = a + 1)，常量不能出现在运算符左边进行赋值操作，但 p++ 可以 。\n12p++    --&gt;  p = p + 1        --&gt; p 的指向已经改变p + 1  --&gt;  p 的指向未改变  \n指针与二维数组\n二维数组结合指针的理解\na[i][j] 相当于是数组名为 a[i]，然后取第 j 个元素，即为 a[i][j]，用指针的形式表示为：*(*(a + i) + j)。\n(a + i) 是先按行移动指针，移动的 1 就是一行，即一行 j 个元素，移到第 i 行的首地址，此时 (a + i) 还只是 a[i] 的函数名（地址），即在第 i 个数组的函数名地址，a + i 只是一个地址，要取 a[i]，还要加 *，即 *(a + i)（具体可参考 二维数组的二次分配），而 a[i] 又为 a[i][j] 的函数名，即地址，a[i] + j 为 a[i][j] 的地址，* 取值后成为 a[i][j]。\n二维数组的二次分配解析：二维数组的行指针就是一个二级指针用于存储一级指针的地址，所以在分配行指针时大小就是一个指针变量的大小，它是存一级指针的地址。二维数组 a[i][j] 中，(a + i) 表示的就是取第 i 个二级指针变量里存的地址（就是一级指针的地址），而 *(a + i) 就是取一级指针里的内容，即变量的地址（为 a[i] ）。\n123int a[2][3] = &#123;1,2,3,4,5,6&#125;;int i, j;int *p;\np = a 是不允许的，因为 p 是在列指针上移动的，而 a 是在行指针上移动的，即 p + 1 和 a + 1 所表达的含义不一样，a + 1 是指加一行，p + 1 是加一个元素。\np = *a 即为 *(a + 0) 此种形式是可以的，此时 *a 取的是数组元素的地址,而不是存储元素地址的地址，使之在数组在列指针上移动，即每加 1 为一个元素大小。\n1234p = *a;for(int i = 0; i &lt; 6; i++)\tprintf(&quot;%d &quot;,p[i]);printf(&quot;\\n&quot;);\n二维数组也可以用这种方式输出。\n9. 指针数组与数组指针(工作常用，指针函数、数组指针)\n数组指针：像整型指针为指向整型的指针，而数组指针则为指向数组的指针。\n\n【存储类型】 数据类型  (*指针名)[下标]  = 值\n\n1int (*p)[3]; --&gt; type name; --&gt; int[3] *p;\ntype 可以是 int char double，以及结构体类型，上面这种为数组类型。int *p；p 每加一，移动一个 int 大小，而 int (*p)[3] 即 int[3] *p 移动三个 int 大小。是数组间移动。\n1234int a[2][3] = &#123;1,2,3,4,5,6&#125;;int i,j;int *p = *a;int (*q)[3] = a;\n这种形式定义的 q 每加一，和 a 加一是一样的，q 加一，移动三个 int型元素大小，和二维数组的行指针一样。但要注意 区别：a 是常量，q 是变量，二维数组的本质就是一个数组指针。\n\n【存储类型】 数据类型  * 数组名【下标】  = 值；\n\n1int *arr[3];  --&gt;  TYPE NAME;\n","thumbnail":"2024/指针与变量/./thumb.png","plink":"https://CHONG589.github.io/2024/指针与变量/"},{"title":"字符数组","date":"2024-02-02T13:50:00.000Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"author":"Chong","updated":"2025-04-10T08:00:03.120Z","content":"概念\nC 语言本身没有内置的字符串类型，字符串本质上是一种特殊类型的数组，它的组成元素类型为 char，除此之外不受制与数组长度的限制，以'\\0'作为结束标志，作为字符串结束的标志。（ \\0 作为一个特殊字符，它的 ASCII 值为 0，但是它不是'0'字符，'0'字符的 ASCII 值为 48）\n字符串字面量 (字符串常量)\n字符串字面量形如 &quot;string&quot;，也被称为字符串常量，编译器会将它末尾自动添加上字符串结尾标志 \\0。通常存储在内存的 ​​只读数据段​​（.rodata 只读数据段 或 .text 程序代码段）中，与程序的生命周期一致。说以静态形式存储在程序中也是对的。\n初始化\n使用字符串数组初始化\n字符串列表初始化\n12345//必须显式添加 &#x27;\\0&#x27;char a[] = &#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;!&#x27;, &#x27;\\0&#x27;&#125;;//不建议这样初始化：char a[] = &#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;!&#x27;&#125;;\n因为如果是逐个字符初始化数组，比如 char str[] = &#123;'h', 'e', 'l', 'l', 'o'&#125;;，这时候数组的长度是 5，没有 '\\0' 结束符。这时候如果当作字符串使用，比如用 printf 打印，可能会导致越界访问，因为函数会一直找直到遇到 '\\0' 才停止。\n如果这样写：char str[] = &quot;hello&quot;;，这时候数组的长度会自动计算为 6，包括结尾的 '\\0'。这是因为用双引号的 字符串字面量 初始化数组时，编译器会自动添加结束符。所以这种情况下，即使不指定长度，数组会有 '\\0'。\n当指定数组大小，但是数组大小要足够，要预留 '\\0' 的位置时，这样即使没有显示的添加 '\\0'，编译器会自动在后面补 '\\0'。\n1234char a[6] = &quot;hello&quot;;//后面未初始化的部分会被自动设为 &#x27;\\0&#x27;char a1[10] = &quot;hello&quot;;\n字面量的形式初始化数组\n1char a[] = &quot;hello!&quot;;\n这种情况下，数组会自动包含 \\0，长度是字符数加 1。\n使用指针指向字符串字面量初始化\nstr 是一个指针，指向存储在 ​​只读内存区​​ 的字符串字面量。末尾自动包含 \\0，可作为字符串安全使用。\n1char *str = &quot;hello&quot;;\n动态内存分配\n12char *str = malloc(6 *sizeof(char));strcpy(str, &quot;hello&quot;);\n字符串数组和指针\n\n\n字符串数组形式：字符串常量存储在只读内存区中，使用字符串数组来对它进行存储时，编译器会自动将 字符串常量的内容（包括结尾的\\0）拷贝到数组所在的存储空间（栈或静态存储区，取决于数组的作用域）。\n\n\n指针形式：这种方法就是将字符串常量的首地址赋值给指针变量，即指针指向这个字符串，并没有拷贝，而是直接指向那段内存，但是不可以更改里面的内容，因为是只读数据段。\n\n\n注意问题\n12345char str[11] = &#123;&quot;hello world&quot;&#125;;char *s; s = &quot;china&quot;;//不能这样str = &quot;zeng chong&quot;\n解释一下这几句都做了什么：\n首先在内存的只读数据段为 “hello world” 分配了内存，该内存只读，不能修改，然后在栈中为 char 型数组分配内存，大小为 11，然后将只读数据段中的字符串字面量的内容 “hello world&quot; 拷贝到数组 str 中（大小足够）。然后是第二句，在栈中分配了一个 char 型指针变量，在只读数据段为 ”china“ 分配内存，再让 s 指向 “china”。\n至于第三句为什么不行？因为 str 数组是分配在了栈中，数组的地址固定的，我们可以改变数组中的内容，相当于编译器在栈中分配了一个房子，房子容量是 11 个人，我们可以改变里面住谁（元素），但是在作用域内，房子地址已经分配在那里了，我们就不可以更改它的地址了，而第三句是将在只读数据段中的字面量地址赋值给数组，相当于改变数组的地址，这样显然是不行的。\n所以 s = str 是可以的，可以改变指针 s 的指向，但是 str = s 不行。\nchar *s = &quot;china&quot;; 的本质是一个指针变量，只占八个字节(64位机器中)，用来保存第一个字符的地址(str 就是一个地址)，它可以用 printf(&quot;%c&quot;,s[i]); 逐个输出字符，或 printf(&quot;%c&quot;,*s++); s[i] 就是 *(s + i)；例：\n1234char str[] = &quot;hello&quot;;printf(&quot;%d %d\\n&quot;,sizeof(str),strlen(str));strcpy(str,&quot;world&quot;);puts(str);\nsizeof(str)为 6 字节，strlen(str) 为 5 字节，而 puts(str) 输出为 world，正确输出。strcpy 是将 “world” 复制到数组 str 的地址空间中。\n1234char *s = &quot;hello&quot;;printf(&quot;%d %d\\n&quot;,sizeof(s),strlen(s));strcpy(s,&quot;world&quot;);puts(s);\n这段程序会报段错误（Segmentation Fault），为什么数组 str 不会，而用指针 s 就会，这就要理解内存分配的问题了，要使用内存，必须先分配了才能使用。\n这其实跟上面是一样的道理的，首先，在栈空间中分配了一个指针变量，然后字面量 “hello” 被分配在常量区中，然后将常量区的首地址赋给了 s，即 s 指向了 “hello”，s 指向的空间是位于常量区的，你更改不了它内存中的值，所以你这样会报错。\n如果 s 指向的是堆中的内存 (事先已经分配好了，再让 s 指向它)，或者通过 s = malloc(10); 在堆中分配内存，然后这时就可以调用 strcpy 就可以成功。\n实现自己的 memcpy。\n首先 strcpy 是复制字符串的，而 memcpy 是内存拷贝的，任意类型的数据都能进行拷贝。\n1void * memcpy ( void * destination, const void * source, size_t num );\n\n参数中除了要复制的字节数 num，其他的参数类型基本都是 void *，返回值也是 void *。\n该函数是从 source 的位置开始向后复制 num 个字节 的数据到 destination 的内存位置。\n该函数在遇到 '\\0' 的时候并不会停下来。\nsource 和 destination 不能有任何的重叠。\n\nvoid * 不能直接解引用，那么 **如何复制呢？**答案是进行类型强转，转换成char *，一个一个字节地复制过去。\n12345678910void *myMemcpy(void *dest, const void *src, size_t num) &#123;    assert(dest);    assert(src);    char *pDest = dest;    const char *pSrc = src;    while(num--) &#123;        *pDest++ = *pSrc++;    &#125;    return dest;&#125;\nmemmove 实现\nmemcpy 如果 src 和 dest 中有内存重叠的情况是不能拷贝成功的，下面是会出现的几种情况。\n1234567891011121314151617181920211. 如下所示，src &lt; dest &amp;&amp; src + n &gt; dest 时，有内存重叠，这样拷贝是不成功的，\t需要从后往前拷贝。----------------------------       ======&gt;&gt; 从后往前拷贝 |        |src     dest2. dest &lt; src &amp;&amp; dest + n &gt; src 时，虽然这样也有重叠，但是这样从前往后拷贝是\t不会出错的。----------------------------       ======&gt;&gt; 从前往后拷贝 |        |dest     src3. src + n &lt; dest 的情况，即 src &lt; dest ，没有重叠-----------------------------      ======&gt;&gt; 两种都可以 |                  |src                dest4. dest + n &lt; src 的情况，即 dest &lt; src ，没有重叠-----------------------------      ======&gt;&gt; 两种都可以 |                  |dest               src\n可以看到有四种情况，只有一种情况是只能用从后往前拷贝的，我们可以将 src &lt; dest 的情况都归类为从后往前拷贝，因为第三种情况两种拷贝方式都可以，然后其它情况就是从前往后拷贝的情况，即 src &gt;= dest。\n12345678910111213141516void *memmove(void *dest, const void *src, size_t n) &#123;    assert(dest);    assert(src);    char *pDest = (char *)dest;    char *pSrc = (char *)src;    if(src &lt; dest) &#123;\t    //从后往前拷贝\t    while(n--) &#123;\t\t    *(dest + n) = *(src + n);\t    &#125;    &#125;    else &#123;\t    //从前往后拷贝\t    *dest++ = *src++;    &#125;&#125;\nstrcpy 函数实现\n1char *strcpy(char *dest, const char *src);\n\n确保目标字符串 dest 有足够的空间来存储源字符串 src 的内容。\n调用 strcpy 函数，将源字符串 src 的内容(包括 ‘\\0’ )复制到目标字符串 dest 中。\n返回目标字符串 dest 的地址。\n\nstrcpy 函数并不会检查目标字符串 dest 的容量是否足够，因此在使用 strcpy 函数时，务必确保目标字符串有足够的空间来存储源字符串的内容，以免发生缓冲区溢出的问题。\n12345678char *myStrcpy(char *dest, const char *src) &#123;\tassert(dst != NULL &amp;&amp; src != NULL);\tchar *ret = dest&#x27;\t//拷贝的内容包括 &#x27;\\0&#x27;，遇到 &#x27;\\0&#x27; 后，\t//先赋值给 dest，然后判断为 0，跳出循环。\twhile((*dest++ = *src++) != &#x27;\\0&#x27;) ;\treturn ret;&#125;\nstrncpy 实现\n1234567891011121314char *mystrncpy (char *dest, const char *src, size_t n) &#123;\tint i;\t\tfor (i = 0; i &lt; n &amp;&amp; (dest[i] = src[i]); i++) &#123;\t\t//(dest[i] = src[i]) 作用是一边拷贝到 dest 中，一边用作判断，\t\t//当 (dest[i] = src[i])的值为 \\0 即在 &amp;&amp; 运算中式子不成立，\t\t//跳出循环,因为 有时 src 的长度会小于 n ，即 src 不够长, 那\t\t//就只拷贝 src 那么长的\t&#125;\t\tfor (; i &lt; n; i++)\t\tdest[i] = &#x27;\\0&#x27;;\t\treturn dest;&#125;\n若 src 没有 n 那么长，经过 (dest[i] = src[i]) 将 \\0 复制到了 dest 中，且判断跳出循环，这时 \\0 是赋值到了字符串中的，当 src &gt; n 时，是因为 i &lt; n 这个条件不满足导致跳出，\\0 并无拷贝，最后应该将 dest[i] = '\\0'。\n","thumbnail":"2024/字符串/./thumb.png","plink":"https://CHONG589.github.io/2024/字符串/"},{"title":"二维数组","date":"2024-02-02T12:18:01.000Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"author":"Chong","updated":"2024-12-25T06:58:35.000Z","content":"二维数组的分配\n假设要为一个 m * n 的数组分配内存空间\n1. 一次分配\n\n这种分配就是把它当作一维数组来分配，通过 i 和 j 的值，计算出具体位置。该分配的内存必须是连续的。\n1234567int *arr = (int *)malloc(sizeof(int) * m * n);for(int i = 0; i &lt; m; i ++)&#123;    for(int j = 0; j &lt; n; j ++)&#123;        arr[i * n + j] = 1;    &#125;&#125;\n注意每个元素的下标和 i 、j 的关系\n#2. 二次分配\n\n首先分配一个指针数组 *arr[i],以行为单位，一行表示一个指针，该指针数组中的每个元素都是一个数组指针，该指针又指向一个一维数组。后面再对该数组指针分配内存空间(即对一维数组分配)，这种二维内存的分配是分两次来分配的，因此分配的内存是不连续的。\n12345678// 为指针数组分配内存int **arr = (int **)malloc(sizeof(int *) * m);// 为每个指向数组的指针分配空间，即每个指针只需一个指针变量接收，共有 m 个。// 再为每个指针数组分配内存空间for(int i = 0; i &lt; m; i ++)&#123;    arr[i] = (int *)malloc(sizeof(int) * n);&#125;\n","thumbnail":"2024/二维数组/./thumb.png","plink":"https://CHONG589.github.io/2024/二维数组/"},{"title":"环境变量","date":"2024-01-31T15:03:55.000Z","date_formatted":{"ll":"2024年1月31日","L":"2024/01/31","MM-DD":"01-31"},"author":"Chong","updated":"2024-12-25T07:38:18.000Z","content":"我们平时在装有些软件时，要配置环境变量，那么为什么要配置？它起什么作用？\n\n什么是环境变量\n是在操作系统中一个具有特定名字的对象，它包含了一个或多个应用程序所将使用到的信息, 例如: 如系统临时文件夹位置、系统文件夹位置、某些应用软件文件的路径等等…\n当要求系统运行一个程序但是又没有告诉它这个程序所在的完整路径时，系统默认会在当前目录下面寻找这个程序,如果找不到就会到环境变量中的 path 中指定的路径去找, 所以我们用户可以通过设置环境变量，来更好的运行程序!\n例：当我们在 cmd 命令行窗口中输入 qq 时：\n\n提示\n1&#x27;qq&#x27; is not recognized as an internal or external command\n所以这种方式不能打开 QQ 程序的，如果我们非要在 cmd 中打开 QQ 程序，我们要进入并且找到这个程序的 bin 目录下的 qq.exe 执行程序！\n我电脑中的 QQ 路径为：D:\\Program Files (x86)\\QQ\\QQ\\Bin\n在 cmd 中进入该路径且输入QQ.exe\n\n所以我们是可以通过命令行中进入到执行程序的位置进行打开该程序，这个效果跟你在桌面点击快捷方式是一个效果。如果关掉 cmd 后重新打开，再次输入 QQ 其实又是同样的问题，这就意味着你要从 cmd 打开 QQ 必须每次按照刚才的步骤进行打开，并且你还必须要切换到这个 QQ 的 bin 目录下才行，这样就很麻烦了（当然这只是个例子，我们完全可以通过快捷方式打开程序）。\n那么有没有办法让我们在随便哪个目录中都可以直接使用 cmd 输入一个 QQ 就可以打开的办法呢?\n这时就要使用到环境变量！你只要把刚刚那个 bin 目录的路径添加到环境变量中的系统变量下的 path 就可以了，这里的 path 也就是环境变量中用来指定可执行文件的绝对路径，这里配置了很多路径，彼此之间用分号隔开!这里操作以 windows 10 为例，步骤如下：\n右键点击此电脑 ---&gt; 属性 ---&gt; 高级系统设置 ---&gt; 环境变量\n\n然后找到系统环境变量 ---&gt; Path ---&gt; 编辑 ---&gt; 新建\n\n\n复制你 QQ 安装目录下的 bin 路径到新建的对话框中\n\n\n最后全部点击确定即可！这时你就可以在 cmd 中的任意目录、任意盘符下进行打开这个应用程序了！\n总之，环境变量 的主要作用就是规定了某些系统文件的所在位置！\n用户变量和系统变量的区别\n\n\n用户变量：在环境变量中的用户变量配置只会当前所登录的系统用户生效, 也就是说登录的系统用户可以对他自己所配置的环境变量参数进行增删改 , 不同用户的用户变量之间是独立存在的,并且互不干扰的\n\n\n系统环境变量：在环境变量中系统变量的配置会对所有用户都会有效, 也就是说如果系统变量被修改了，那么任何一个用户都将受到影响!但是只有管理员账户才有权限进行系统变量的设置, 普通系统用户是不能够去修改系统变量的\n\n\n如何自定义环境变量命令\n当我们想通过 cmd 来运行一个自己定义的命令时，就会出现不是内部或外部命令，也不是可运行的程序 或批处理文件的提示信息!\n但是如果我们在cmd中输入一个 shutdown 命令则可以完全正常执行!\n\n这个原因也很简单,正因为 shutdown 在环境变量中定义了它这个命令所在的路径,而test这个命令则没有!\nshutdown命令的默认路径是在 C:\\Windows\\System32 目录下, 包括一些常见的cmd命令其实都在这个目录下\n\n而 C:\\Windows\\System32 这个路径也是默认安装系统的时候就被定义在了环境变量当中, 就跟之前定义 QQ 应用程序也是一个道理！\n所以根据这个道理我们也可以自定义一个环境变量来进行调用！要知道变量就是一个可变化的量 我们就利用这个特点来自己定义一个系统变量然后调用它来打开某个应用程序\n我这里要打开微信，当然你完全可以依照之前的办法在 path 中把微信的 WeChat.exe 路径加入到其中, 但是这样子做不够灵活！我们可以先在系统变量中定义一个 weixin 然后值设置为微信目录地址！\n\n\n设置好后，我们现在就可以对它进行调用！在 path 中把刚刚自定义好的 weixin 这个变量加入到其中，格式为 %变量名%\n\n这样一来以后你只需要去修改变量的值 path 中就会自动获取到了！接下来就可以去 cmd 中尝试一下打开这个应用程序\n！！！但是这样在 cmd 中用 weixin 启动不成功，即使在变量值中改成 D:\\Program Files (x86)\\WeChat\\WeChat 也还是不行，网上查了一些原因也没解决\n为什么编程开发要配置环境变量\n知道什么是环境变量以后，现在应该明白我们在开发 java、python、php 之前需要配置的环境变量的原因了吧！\n比如 Java 我们就需要把 JDK 的 bin 目录添加到环境变量的 path 中，这样我们就可以在任意目录下使用 bin 下面的 .exe 可执行程序 javac.exe\njavac.exe 用来处理 .java 源代码文件，是把源代码文件编译为字节码文件的一个工具,经过 javac.exe 这个工具编译 java 源代码文件后形成的 .class 就是字节码文件\njava.exe 用来处理 .class 字节码文件进行执行的，也就是 JVM 解释执行 java 程序, 从而实现 java 程序的运行\n而他们都在 bin 目录下, 这都是为了能够方便的使用这些开发语言所带有的编译解释工具和命令, 所以我们才要配置环境变量。如果环境变量配置不成功，在 cmd 中去输入 java 就会提示找不到某某的关键词\n所以在开始学习 java 或者其他一些开发语言的时候，为了操作方便必须要配置一下环境变量 从而达到能够正常运行 java 的环境, 其他一些语言也是以此类推!\n","thumbnail":"2024/环境变量/./thumb.png","plink":"https://CHONG589.github.io/2024/环境变量/"},{"title":"static","date":"2024-01-30T07:31:31.000Z","date_formatted":{"ll":"2024年1月30日","L":"2024/01/30","MM-DD":"01-30"},"author":"Chong","updated":"2025-04-10T08:01:19.674Z","content":"\n当与不同类型一起使用时，static 关键字具有不同的含义。static 编译时分配内存。\n函数中的静态变量\n当变量声明为 static 时，空间 将在程序的生命周期内分配。即使多次调用该函数，静态变量的空间也 只分配一次，前一次调用中的变量值通过下一次函数调用传递。这对于在 C / C ++ 或需要存储先前函数状态的任何其他应用程序非常有用。\n类中的静态成员变量\n当我们在头文件中声明一个静态成员时，只是在告知编译器存在这样一个静态成员变量，但实际上并没有定义它（从某种意义上说，这与前置声明非常相似）。因为静态成员变量不属于类实例（它们的处理方式与全局变量类似，在程序启动时初始化），所以必须在类外部的全局作用域中显式定义静态成员。也是因为这个原因，静态变量不能使用构造函数初始化，使用类外的类名和范围解析运算符显式初始化。\n12345678910111213141516171819#include&lt;iostream&gt; using namespace std; class Apple &#123; public: \tstatic int i; \t\tApple() &#123; \t\t// Do nothing \t&#125;; &#125;; int Apple::i = 1; //类名和范围解析运算符显示初始化int main()  &#123; \tApple obj; \t// prints value of i \tcout &lt;&lt; obj.i; &#125; \n不过也有一些例外情况。首先，当静态成员是const整型（包括char和bool）或const枚举类型时，静态成员可以在类定义内部初始化：\n123class A &#123;    static const int  s_var&#123;42&#125;;&#125;;\n从C++17开始，static constexpr 成员可以在类定义内部初始化（无需在外部进行初始化）。\n1234class A &#123;    // 对于任何支持constexpr初始化的类，这都有效    static constexpr std::array&lt;int , 3&gt; s_array&#123; 1, 2, 3 &#125;;&#125;;\n如果在成员函数中调用静态数据成员，那么该成员函数应声明为static。这点在下面解释了，允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数。\n类对象为静态\n就像变量一样，对象也在声明为 static 时具有范围，直到程序的生命周期。如果我们将对象声明为静态，现在让我们看看输出的变化。\n123456789101112131415161718192021222324#include&lt;iostream&gt; using namespace std; class Apple &#123;  public: \tApple() &#123; \t\ti = 0; \t\tcout &lt;&lt; &quot;Inside Constructor\\n&quot;; \t&#125; \t~Apple() &#123; \t\tcout &lt;&lt; &quot;Inside Destructor\\n&quot;; \t&#125;private:\tint i;&#125;; int main() &#123; \tint x = 0; \tif (x==0) &#123; \t\tstatic Apple obj; \t&#125; \tcout &lt;&lt; &quot;End of main\\n&quot;; &#125; \n输出：\n123Inside ConstructorEnd of mainInside Destructor\n您可以清楚地看到输出的变化。现在，在 main 结束后调用析构函数。这是因为静态对象的范围是贯穿程序的生命周期。\n类中的静态成员函数\n静态成员函数可用于 处理类中的静态成员变量，或执行无需类实例的操作。不过，从概念和语义上讲，静态成员函数所执行的操作应与类密切相关。关于静态成员函数，有以下几个要点：\n\n静态成员函数没有this指针。\n静态成员函数不能是虚函数（virtual）。\n静态成员函数不能访问非静态成员。\n静态成员函数不能使用const和volatile限定符（静态变量是可以用 const 修饰的）。\n\n在实际应用中，静态成员函数意味着无需实例化类就可以调用它。如果Foo类中有一个静态函数static void bar()，你可以这样调用它：Foo::bar()，而无需实例化 Foo 类（顺便说一句，你也可以通过实例调用它：aFoo.bar()）。\n允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数。\n由于this指针始终保存当前对象的内存地址，而调用静态成员根本不需要对象，所以静态成员函数不能有this指针。\n虚成员与任何特定类没有直接关系，只与实例相关。（根据定义）“虚函数” 是一种动态链接的函数，即在运行时根据给定对象的动态类型选择正确的实现。因此，如果没有对象，就不可能进行虚函数调用。\n访问非静态成员函数要求对象已经构造，但对于静态调用，我们不会传递类的任何实例，甚至不能保证已经构造了任何实例。\n同样，const 和 const volatile 关键字用于修改对象是否可被修改以及如何被修改。由于静态调用不能保证已经构造了任何实例，所以这两个关键字操作的对象都不知道有没有。\n12345678910111213141516#include&lt;iostream&gt; using namespace std; class Apple &#123; public: \t// static member function \tstatic void printMsg() &#123;\t\tcout&lt;&lt;&quot;Welcome to Apple!&quot;; \t&#125;&#125;; // main function int main() &#123;     // invoking a static member function     Apple::printMsg(); &#125; \n输出：\n1Welcome to Apple!\n限定访问范围\n解决变量冲突问题\n1234567891011121314151617//proj.hvoid func(void);//proj.cint i = 100;void func(void)&#123;\tprintf(&quot;[%s]: i = %d\\n&quot;,__FUNCTION__,i);\texit(0);&#125;//main.cint i = 10;int main()&#123;\tprintf(&quot;[%s]: i = %d\\n&quot;,__FUNCTION__,i);\tfunc();\t\texit(0);&#125;\n这三个文件当中的全局变量 i 按理来说它们都只作用在本 .c 文件中，因为它们的作用范围和生命周期是不同的，但是编译后出现了错误。显示对 i 的定义重复定义了。所以 main.c 和 proj.c 链接后的 i 会导致作用范围一样，即导致冲突。编译 --&gt; 链接 --&gt; 装入，链接时会出现两个文件的 i。\n如果想要 main.c 和 proj.c 中的 i 变量作用在各自的 .c 文件中，则在各自定义 i 变量时加上关键字 static。像这样 static int i = 10;这样则当前文件修饰的变量只能在当前文件用，这样就不冲突了。\n同理如果一个文件访问另一个文件中加了 static 修饰的变量会出现 undefined reference 的编译错误。\n1234567891011121314// source1.cppextern void sayHello();static const char* msg = &quot;Hello World!\\n&quot;;int main() &#123;    sayHello();    return 0;&#125;// source2.cpp#include &lt;cstdio&gt;extern char *msg;void sayHello() &#123;    printf(&quot;%s&quot;, msg);&#125;\n防止函数对外扩展\n普通做法会出现的问题\n123456789101112131415161718//proj.hvoid func(void);//proj.cstatic int i = 100;static void func(void)&#123;\tprintf(&quot;[%s]: i = %d\\n&quot;,__FUNCTION__,i);\texit(0);&#125;//main.cstatic int i = 10;int main()&#123;\tprintf(&quot;[%s]: i = %d\\n&quot;,__FUNCTION__,i);\tfunc();\texit(0);&#125;\n由于 static 修饰了函数，所以只能在该 .c 文件中使用，导致在 .h 文件声明时使用不了，而在 main.c 文件中又使用了 func(), 这样就导致未定义就使用 func() 。\n解决方法\n12345678910111213141516171819202122//proj.hvoid call_func(void);//proj.cstatic int i = 100;static void func(void)&#123;\tprintf(&quot;[%s]: i = %d\\n&quot;,__FUNCTION__,i);\texit(0);&#125;void call_func() &#123;\tfunc();&#125;//main.cstatic int i = 10;int main()&#123;\tprintf(&quot;[%s]: i = %d\\n&quot;,__FUNCTION__,i);\tcall_func();\texit(0);&#125;\nfunc() 函数还是只能在本文件使用，只不过借助了一个 call_func() 函数来执行 func()。这样就能保证 func() 在本文件中使用，而在其他文件中通过调用 call_func() 来执行 func().\n什么是静态初始化顺序问题\n静态初始化顺序问题是C++中一个容易被许多人忽视、误解的微妙方面。由于该错误通常在main()函数被调用之前就发生了，所以很难察觉。\n在一个翻译单元（translation unit）中，静态或全局变量总是按照它们的定义顺序进行初始化。另一方面，对于哪个翻译单元先被初始化，并没有严格的顺序。\n假设你有一个翻译单元A，其中有一个静态变量sA，它的初始化依赖于翻译单元B中的静态变量sB。那么你有 50% 的失败几率。这就是静态初始化顺序问题。\n1234567891011121314// Logger.cpp#include  &lt;string&gt;std::string theLogger = &quot;aNiceLogger&quot;;// KeyBoard.cpp#include  &lt;iostream&gt; #include  &lt;string&gt;extern  std::string theLogger;std::string theKeyboard = &quot;The Keyboard with logger: &quot; + theLogger;int  main() &#123;    std::cout &lt;&lt; &quot;theKeyboard: &quot; &lt;&lt; theKeyboard &lt;&lt; &#x27;\\n&#x27;;&#125;\n那我们看看不同的初始化顺序会产生什么样的结果：\n12345678zhangxf@mydevserver ~/static_fiasco $ g++ -c Logger.cppzhangxf@mydevserver ~/static_fiasco $ g++ -c Keyboard.cppzhangxf@mydevserver ~/static_fiasco $ g++ Logger.o Keyboard.o -o LoggerThenKeyboardzhangxf@mydevserver ~/static_fiasco $ g++ Keyboard.o Logger.o -o KeyboardThenLogger zhangxf@mydevserver ~/static_fiasco $ ./KeyboardThenLogger theKeyboard: The Keyboard with logger: zhangxf@mydevserver ~/static_fiasco $ ./LoggerThenKeyboardtheKeyboard: The Keyboard with logger: aNiceLogger\n如何解决静态初始化顺序问题？\n需要再次提醒的是，在一个翻译单元中，静态或全局变量总是按照它们的定义顺序进行初始化。另一方面，对于哪个翻译单元先被初始化，并没有严格的顺序。\n上面的例子中如果编译单元Logger.cpp先被初始化，那么没问题。但如果是键盘（对应的编译单元）先被初始化，就会出问题。\n可能最简单的解决方案是将Logger.cpp中的theLogger变量替换为一个函数，如下所示：\n1234std::string theLogger() &#123;    static  std::string aLogger = &quot;aNiceLogger&quot;;    return  aLogger;&#125;\n然后在Keyboard.cpp中，我们只需确保对该函数使用extern，并且之后调用这个函数，而不是引用变量。这样做是可行的，因为局部静态变量std::string aLogger会在theLogger()函数第一次被调用时初始化。因此，可以保证在构造theKeyboard时，theLogger已经被初始化。\n如果在theLogger被构造之后，程序退出时另一个静态变量使用了theLogger，你可能会遇到其他问题。同样，对不同翻译单元中静态变量的依赖是代码质量不佳的表现……\n从C++20 开始，可以使用constinit来解决静态初始化顺序问题。在这种情况下，静态变量将在 编译时、链接之前进行初始化。你可以在这里查看相关解决方案。\n","thumbnail":"2024/static用法/./thumb.png","plink":"https://CHONG589.github.io/2024/static用法/"},{"title":"scanf相关知识","date":"2024-01-30T07:08:35.000Z","date_formatted":{"ll":"2024年1月30日","L":"2024/01/30","MM-DD":"01-30"},"author":"Chong","updated":"2024-12-25T06:39:27.000Z","content":"\n使用 scanf 的注意事项\nscanf 里面不能像 printf 那样在里面输入 \\n,因为在 scanf 中你在里面写了什么，在输入的时候你要原模原样的输入回去。\n123456789101112//这时你输入 i 和 j 时中间就要输入逗号才能正确输入。scacnf(&quot;%d,%d&quot;,&amp;i,&amp;j);//这时你就要在输入 i 和 j 的中间要加上一个空格。scanf(&quot;%d %d&quot;,&amp;i,&amp;j);//这时你在输入 i 后还要输入 \\n 才能结束。scanf(&quot;%d\\n&quot;,&amp;i);//如果你在里面没有输入其他，则你输入 i 和 j 时的间隔符可以//是空格、回车、Tab。scanf(&quot;%d%d&quot;,&amp;i,&amp;j);\nscanf 在用 %s 输入字符串时，输入的字符串中不能有空格、Tab、回车键等，它会作为当前输入的结束，即空格、Tab、回车键后面的字符不会再输入进去。\n\n\n用 %s 也是非常危险的操作，当你输入的字符串超过了接收数组容量时，它不会报错，而是原样输入进去，这样就发生了越界现象，使之存到了这个数组之外的空间中\n\n\nscanf 会返回一个值，当你在 scanf中输入两个值时，scanf(&quot;%d%d&quot;,&amp;i,&amp;j);如果正确输入，则会返回2，若输入错误，则返回不是2的值。所以它在放入循环中时要进行输入是否正确判断，若输入的格式不对，如本来要输入整型值的你输入字符类型，那么你输入错误，则会从你上一次输入的值中取。\n\n\n1234567int i;while(1)&#123;\tint ret = scanf(&quot;%d&quot;,&amp;i);\tif(ret != 1)\t\tbreak;\tprintf(&quot;i = %d\\n&quot;,i);&#125;\n或\n1234int i;while(scanf(&quot;%d&quot;,&amp;i))&#123;\tprintf(&quot;i = %d\\n&quot;,i);&#125;\n如果你没进行判断跳出，只要中间你输入一个错误，它就会一直输出你上一次输入的值，一直死循环。\n在用连续的 scanf 时，输入一个字符后，按回车确定的回车符会被下一个 scanf 吸收。（常常会在循环中遇到这种问题，导致出错）\n这种错误尤其是在循环中要求输入的字符为 char 时，因为回车符就是 char 。当在连续两个 scanf 使用时,当输入的是 int 时不会。\n12scanf(&quot;%c&quot;,&amp;i);scanf(&quot;%c&quot;,&amp;j);\n这样输入时，你输入第一个值 i 时，然后回车确定，再输入 j 时，此时 j 接收的是回车符。可以用 getchra() 吃掉一个回车符。\n123scanf(&quot;%c&quot;,&amp;i);getchar();scanf(&quot;%c&quot;,&amp;j);\n总结\n\n\n所以在循环中有输入规定格式的值时，要判断输入的值正不正确，即判断 scanf 返回的值，可以将加入到 while(scanf()) 中判断。\n\n\n当输入的值为 char 时，要注意输入后确定的回车符，也会被当作输入值输入进去，要用一个来吸收回车符，输入值为 int 时，不会被吸收，因为回车符为 char。\n\n\n","thumbnail":"2024/scanf相关知识/./thumb.png","plink":"https://CHONG589.github.io/2024/scanf相关知识/"},{"title":"编程注意的问题","date":"2024-01-28T13:28:43.000Z","date_formatted":{"ll":"2024年1月28日","L":"2024/01/28","MM-DD":"01-28"},"author":"Chong","updated":"2025-04-10T08:00:18.091Z","content":"我们平时编程时经常会忽略一些细节，导致项目出现问题，且有些很难发现。\n\n1. 头文件正确包含的重要性\n在程序中使用 malloc 函数 时，在程序开头未写头文件 #include&lt;stdlib.h&gt;，这时 gcc 没有看到 malloc 函数头文件的时候，也就看不到它的原型，那它会默认 malloc 的返回值为 int 型，如以下程序。\n12345678910#include &lt;stdio.h&gt;int main(void)&#123;    int *p = NULL;    p = malloc(sizeof(int));    if(p == NULL)        return -1;       return 0;&#125;\n默认 malloc 函数的返回值为 int 型后，而程序中接收的是 int* 型指针，这样就会报错。有人会这样解决问题：p = (int*)malloc(sizeof(int));,使用强制转换类型，有时有些编译器不会报错，但是以后经过移植或换个环境等的时候，这个问题就会出现，导致很难找出来。通过 man malloc 查看可知：\n\nmalloc 函数返回的是 void* 类型的值，而 void 可以转变为大部分的类型，所以可以这样写 p = malloc(sizeof(int))。\n以后使用 gcc 编译时可以用参数 -Wall ,它会显示全部错误，你只要按照出现的错误一个个解决，后面出现的大部分错误都是来源于这，因为你不把这些错误用 -Wall 打印出来，gcc 有些错误在你编译时没有非常严重的错误，它是会忽略的。\n例：gcc hello.c -Wall\n2. 以函数为单位来进行程序编写\n3. 声明部分 + 实现部分\n4. 对于宏定义的理解\n#define 处理在程序的预处理阶段，占编译时间，特点是，一改全改。缺点：不检查语法，只是单纯的宏体与宏名之间的替换。例如以下程序：\n12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ADD 2 + 3int main()&#123;        printf(&quot;%d\\n&quot;,ADD * ADD);        exit(0);&#125;\n结果为：11\n明显结果不是我们想要的 25，我们用 gcc 的预编译命令 gcc -E defind.c 查看\nprintf(&quot;%d\\n&quot;,ADD * ADD);\nprintf(&quot;%d\\n&quot;,2+3 * 2+3);\n从这里可知宏定义就只是在预编译时单纯的将宏体替换宏名。这里想要正确输出，则要这样定义：#define ADD (2+3)\n带参数形式的使用：\n1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX(a,b)   (a &gt; b ? a : b)int main()&#123;        int i = 5, j = 3;        printf(&quot;%d\\n&quot;,MAX(i,j));        exit(0);&#125;\n输出为：5\n但是逻辑上 a 和 b 也应该各自加上括号，因为传参时的数要考虑到运算的优先级,因为无论是 a 还是 b 在这里都是单独的个体，且可以是 a = 1 + 3 的形式，这样组合起来就要考虑优先级问题，1 + 3 是要自己单独运算的。\n#define MAX(a,b)   ((a) &gt; (b) ? (a) : (b))\n当程序改成如下后\n12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX(a,b)   ((a) &gt; (b) ? (a) : (b))int main()&#123;                int i = 5, j = 3;                    printf(&quot;i = %d\\tj = %d\\n&quot;,i,j);        printf(&quot;%d\\n&quot;,MAX(i++,j++));        printf(&quot;i = %d\\tj = %d\\n&quot;,i,j);        exit(0);&#125;\n将参数改成 i++ 和 j++。结果输出如下\n123i = 5\tj = 36i = 7\tj = 4\n理论上 i = 5 和 j = 3 先进行比较，然后各自自增，i 大，则第二行的输出结果为 i 自增后的结果6（先比较后自增），第三行应为 i = 6，j = 4.可结果不是。\n预编译的结果为\nprintf(&quot;%d\\n&quot;,((i++) &gt; (j++) ? (i++) : (j++)));\n根据这串语句可知，i 和 j 先比较，然后各自自增，由于 i 大，则执行 ？ 后面的 i++，这样 i 就再次自增了一次，所以第三行的 i 为自增了两次的。\n解决方法：像函数的参数一样，用变量接收自增后的结果，而不是在比较完后，又将参数 i++ 执行一次，而是执行的是 i++的结果。\n12345678#define MAX(a,b)   (&#123;                        int A = a, B = b;                        ((A) &gt; (B) ? (A) : (B));                    &#125;)i = 5\tj = 35i = 6\tj = 4\n预编译结果为：\n1printf(&quot;%d\\n&quot;,(&#123;int A = i++, B = j++; ((A) &gt; (B) ? (A) : (B));&#125;));\n有时参数未必都是 int 型，则可以\n1#define MAX(a,b)   (&#123;typeof(a) A = a, B = b; ((A) &gt; (B) ? (A) : (B));&#125;)\n用 a 的类型定义 A , B。用 typeof() 函数获取类型。\n","thumbnail":"2024/编程注意的问题/./thumb.png","plink":"https://CHONG589.github.io/2024/编程注意的问题/"},{"title":"Learn","date":"2024-03-11T10:43:00.000Z","date_formatted":{"ll":"2024年3月11日","L":"2024/03/11","MM-DD":"03-11"},"updated":"2024-12-24T13:35:32.066Z","content":"C 语言基础知识\n\n编程注意的问题\nscanf 相关知识\nstatic\n二维数组\n字符数组\n指针与变量\n函数\n构造类型\n动态内存管理\n重定义 typedef\n函数中指针传参问题\n\n数据结构\n\n顺序表 (sqlist)\nmain.c    sqlist.c    sqlist.h    makefile\n链表 (Linklist)\n\nnohead: main.c   list.c   list.h   makefile   笔记\nhead:\nlib1:\nlib2:\nlib3:\nlib4:\n\n\n\n","plink":"https://CHONG589.github.io/Learn/"},{"title":"关于","date":"2024-02-26T16:00:00.000Z","date_formatted":{"ll":"2024年2月27日","L":"2024/02/27","MM-DD":"02-27"},"updated":"2024-12-24T13:40:11.026Z","content":"关于我\n","plink":"https://CHONG589.github.io/about/"},{"title":"LeetCode Solutions（Cpp）","date":"2019-06-29T16:00:00.000Z","date_formatted":{"ll":"2019年6月30日","L":"2019/06/30","MM-DD":"06-30"},"updated":"2024-12-24T13:35:59.482Z","content":"简体中文 ｜ English ｜ \nEasy\n\n0001. Two Sum\n0007. Reverse Integer\n0009. Palindrome Number\n0013. Roman to Integer\n0014. Longest Common Prefix\n0020. Valid Parentheses\n0021. Merge Two Sorted Lists\n0026. Remove Duplicates from Sorted Array\n0027. Remove Element\n0028. Implement strStr()\n0035. Search Insert Position\n\nMedium\n\n0002. Add Two Numbers\n0003. Longest Substring Without Repeating Characters\n0005. Longest Palindromic Substring \n0006. ZigZag Conversion\n0008. String to Integer (atoi)\n0011. Container With Most Water\n0012. Integer to Roman\n0015. 3Sum\n0016. 3Sum Closest\n0017. Letter Combinations of a Phone Number\n0018. 4Sum\n0019. Remove Nth Node From End of List\n0022. Generate Parentheses\n0024. Swap Nodes in Pairs\n0029. Divide Two Integers\n0031. Next Permutation\n0050. Pow(x, n)\n0134. Gas Station\n\nHard\n\n0004. Median of Two Sorted Arrays\n0010. Regular Expression Matching\n0023. Merge k Sorted Lists\n\n","plink":"https://CHONG589.github.io/leetcode/index-en/"},{"title":"LeetCode 刷题记录（Cpp）","date":"2024-02-26T16:00:00.000Z","date_formatted":{"ll":"2024年2月27日","L":"2024/02/27","MM-DD":"02-27"},"updated":"2024-12-24T13:31:53.394Z","content":"简体中文 ｜ English ｜ \n","plink":"https://CHONG589.github.io/leetcode/"}]