[{"title":"构造类型","date":"2024-02-04T09:47:18.000Z","date_formatted":{"ll":"2024年2月4日","L":"2024/02/04","MM-DD":"02-04"},"author":"Chong","updated":"2024-12-25T07:07:25.000Z","content":"结构体\n产生及意义\n类型描述(不占存储空间)，描述是怎样一个结构，是一个类型，如 int、char\n12345struct 结构体名 &#123;\t数组类型 成员1；\t数据类型 成员2；\t......  &#125;；\n嵌套定义\n123456789101112struct birthday_st &#123;\tint year;\tint month;\tint day;&#125;;struct student_st &#123;\tint id;\tchar name[NAMESIZE];\tstruct birthday_st birth;\tint math;\tint chinese;&#125;;\n或\n1234567891011struct student_st &#123;\tint id;\tchar name[NAMESIZE];\tstruct birthday_st &#123;\t\tint year;\t\tint month;\t\tint day;\t&#125;birth;\tint math;\tint chinese;&#125;;\n定义变量(变量、数组、指针)、初始化及成员引用\n\n\n成员引用：变量名.成员名\n像上面 struct birthday_st birth 定义变量的方式，这个变量名 birth 存的只是结构体的首地址。\n\n\n成员引用：指针 -&gt; 成员名 (*指针).成员名\n\n\n占用内存空间大小\n内存对齐\n函数传参（值，地址）\n一般不用结构体的值(即整个结构体)传参，因为当结构体里的成员很多时，定义形参时也要相对应的大小，内存开销大，所以我们一般传指针，形参只需定义指针即可，而指针变量大小在同一机器中时是固定。\n共用体\n产生及意义\n共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。\n类型描述\n123456union [union tag] &#123;member definition;member definition;...member definition;&#125; [one or more union variables];\nunion tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。\n嵌套定义\n练习：对一个具有 32 位值的高 16 位和低 16 位进行相加\n\n方法一：根据共用体和结构体的特性进行解决\n\n1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;union &#123;\tstruct &#123;\t\tuint16_t i;\t\tuint16_t j;\t&#125;x;\tuint32_t y;&#125;a;int main () &#123;\ta.y = 0x11223344;\tprintf(&quot;%x&quot;, a.x.i + a.x.j);\texit (0);&#125;\n\n方法二：用位运算解决\n\n123456789#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;int main () &#123;\tuint32_t i = 0x11223344;\tprintf(&quot;%x\\n&quot;, (i &gt;&gt; 16) + i &amp; 0xffff);\texit (0);&#125;\n定义变量（变量、数组、指针），初始化及成员引用\n跟结构体一样\n占用内存空间大小\n共用体占用的内存应足够存储共用体中最大的成员\n函数传参（值，地址）\n位域\nC 语言的位域（bit-field）是一种特殊的结构体成员，允许我们按位对成员进行定义，指定其占用的位数。\n1234struct &#123;\tint i;\tint j;&#125;a;\n这种结构需要 8 字节的内存空间，但在实际上，在每个变量中，我们只存储 0 或 1，在这种情况下，C 语言提供了一种更好的利用内存空间的方式。如果您在结构内使用这样的变量，您可以定义变量的宽度来告诉编译器，您将只使用这些字节。例如，上面的结构可以重写成：\n1234struct &#123;\tint i: 1;\tint j: 1;&#125;a;\n现在，上面的结构中，a 变量将占用 4 个字节的内存空间(内存对齐的原因)，但是只有 2 位被用来存储值。如果您用了 32 个变量，每一个变量宽度为 1 位，那么 a 结构将使用 4 个字节，但只要您再多用一个变量，如果使用了 33 个变量，那么它将分配内存的下一段来存储第 33 个变量，这个时候就开始使用 8 个字节。\n枚举\n枚举是 C 语言中的一种基本数据类型，用于定义一组具有离散值的常量，它可以让数据更简洁，更易读。枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性。\n定义一个枚举类型，需要使用 enum 关键字，后面跟着枚举类型的名称，以及用大括号 {} 括起来的一组枚举常量。每个枚举常量可以用一个标识符来表示，也可以为它们指定一个整数值，如果没有指定，那么默认从 0 开始递增。枚举语法定义格式为：\n123enum　枚举名　&#123;    枚举元素1,枚举元素2,……&#125;;\n接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：\n1234567#define MON  1#define TUE  2#define WED  3#define THU  4#define FRI  5#define SAT  6#define SUN  7\n这个看起来代码量就比较多，接下来我们看看使用枚举的方式：\n123enum DAY &#123;      MON=1, TUE, WED, THU, FRI, SAT, SUN&#125;;\n注意：第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。\n可以用 enum 当成宏来使用，enum 在预处理后，里面的值不会替换，这样在查看哪里错的时候，这样才能更直观的知道这个变量是干嘛的，而不是被替换成了值。\n","thumbnail":"2024/构造类型/./thumb.png","plink":"https://CHONG589.github.io/2024/构造类型/"},{"title":"二维数组","date":"2024-02-02T12:18:01.000Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"author":"Chong","updated":"2024-12-25T06:58:35.000Z","content":"二维数组的分配\n假设要为一个 m * n 的数组分配内存空间\n1. 一次分配\n\n这种分配就是把它当作一维数组来分配，通过 i 和 j 的值，计算出具体位置。该分配的内存必须是连续的。\n1234567int *arr = (int *)malloc(sizeof(int) * m * n);for(int i = 0; i &lt; m; i ++)&#123;    for(int j = 0; j &lt; n; j ++)&#123;        arr[i * n + j] = 1;    &#125;&#125;\n注意每个元素的下标和 i 、j 的关系\n#2. 二次分配\n\n首先分配一个指针数组 *arr[i],以行为单位，一行表示一个指针，该指针数组中的每个元素都是一个数组指针，该指针又指向一个一维数组。后面再对该数组指针分配内存空间(即对一维数组分配)，这种二维内存的分配是分两次来分配的，因此分配的内存是不连续的。\n12345678// 为指针数组分配内存int **arr = (int **)malloc(sizeof(int *) * m);// 为每个指向数组的指针分配空间，即每个指针只需一个指针变量接收，共有 m 个。// 再为每个指针数组分配内存空间for(int i = 0; i &lt; m; i ++)&#123;    arr[i] = (int *)malloc(sizeof(int) * n);&#125;\n","thumbnail":"2024/二维数组/./thumb.png","plink":"https://CHONG589.github.io/2024/二维数组/"},{"title":"环境变量","date":"2024-01-31T15:03:55.000Z","date_formatted":{"ll":"2024年1月31日","L":"2024/01/31","MM-DD":"01-31"},"author":"Chong","updated":"2024-12-25T07:38:18.000Z","content":"我们平时在装有些软件时，要配置环境变量，那么为什么要配置？它起什么作用？\n\n什么是环境变量\n是在操作系统中一个具有特定名字的对象，它包含了一个或多个应用程序所将使用到的信息, 例如: 如系统临时文件夹位置、系统文件夹位置、某些应用软件文件的路径等等…\n当要求系统运行一个程序但是又没有告诉它这个程序所在的完整路径时，系统默认会在当前目录下面寻找这个程序,如果找不到就会到环境变量中的 path 中指定的路径去找, 所以我们用户可以通过设置环境变量，来更好的运行程序!\n例：当我们在 cmd 命令行窗口中输入 qq 时：\n\n提示\n1&#x27;qq&#x27; is not recognized as an internal or external command\n所以这种方式不能打开 QQ 程序的，如果我们非要在 cmd 中打开 QQ 程序，我们要进入并且找到这个程序的 bin 目录下的 qq.exe 执行程序！\n我电脑中的 QQ 路径为：D:\\Program Files (x86)\\QQ\\QQ\\Bin\n在 cmd 中进入该路径且输入QQ.exe\n\n所以我们是可以通过命令行中进入到执行程序的位置进行打开该程序，这个效果跟你在桌面点击快捷方式是一个效果。如果关掉 cmd 后重新打开，再次输入 QQ 其实又是同样的问题，这就意味着你要从 cmd 打开 QQ 必须每次按照刚才的步骤进行打开，并且你还必须要切换到这个 QQ 的 bin 目录下才行，这样就很麻烦了（当然这只是个例子，我们完全可以通过快捷方式打开程序）。\n那么有没有办法让我们在随便哪个目录中都可以直接使用 cmd 输入一个 QQ 就可以打开的办法呢?\n这时就要使用到环境变量！你只要把刚刚那个 bin 目录的路径添加到环境变量中的系统变量下的 path 就可以了，这里的 path 也就是环境变量中用来指定可执行文件的绝对路径，这里配置了很多路径，彼此之间用分号隔开!这里操作以 windows 10 为例，步骤如下：\n右键点击此电脑 ---&gt; 属性 ---&gt; 高级系统设置 ---&gt; 环境变量\n\n然后找到系统环境变量 ---&gt; Path ---&gt; 编辑 ---&gt; 新建\n\n\n复制你 QQ 安装目录下的 bin 路径到新建的对话框中\n\n\n最后全部点击确定即可！这时你就可以在 cmd 中的任意目录、任意盘符下进行打开这个应用程序了！\n总之，环境变量 的主要作用就是规定了某些系统文件的所在位置！\n用户变量和系统变量的区别\n\n\n用户变量：在环境变量中的用户变量配置只会当前所登录的系统用户生效, 也就是说登录的系统用户可以对他自己所配置的环境变量参数进行增删改 , 不同用户的用户变量之间是独立存在的,并且互不干扰的\n\n\n系统环境变量：在环境变量中系统变量的配置会对所有用户都会有效, 也就是说如果系统变量被修改了，那么任何一个用户都将受到影响!但是只有管理员账户才有权限进行系统变量的设置, 普通系统用户是不能够去修改系统变量的\n\n\n如何自定义环境变量命令\n当我们想通过 cmd 来运行一个自己定义的命令时，就会出现不是内部或外部命令，也不是可运行的程序 或批处理文件的提示信息!\n但是如果我们在cmd中输入一个 shutdown 命令则可以完全正常执行!\n\n这个原因也很简单,正因为 shutdown 在环境变量中定义了它这个命令所在的路径,而test这个命令则没有!\nshutdown命令的默认路径是在 C:\\Windows\\System32 目录下, 包括一些常见的cmd命令其实都在这个目录下\n\n而 C:\\Windows\\System32 这个路径也是默认安装系统的时候就被定义在了环境变量当中, 就跟之前定义 QQ 应用程序也是一个道理！\n所以根据这个道理我们也可以自定义一个环境变量来进行调用！要知道变量就是一个可变化的量 我们就利用这个特点来自己定义一个系统变量然后调用它来打开某个应用程序\n我这里要打开微信，当然你完全可以依照之前的办法在 path 中把微信的 WeChat.exe 路径加入到其中, 但是这样子做不够灵活！我们可以先在系统变量中定义一个 weixin 然后值设置为微信目录地址！\n\n\n设置好后，我们现在就可以对它进行调用！在 path 中把刚刚自定义好的 weixin 这个变量加入到其中，格式为 %变量名%\n\n这样一来以后你只需要去修改变量的值 path 中就会自动获取到了！接下来就可以去 cmd 中尝试一下打开这个应用程序\n！！！但是这样在 cmd 中用 weixin 启动不成功，即使在变量值中改成 D:\\Program Files (x86)\\WeChat\\WeChat 也还是不行，网上查了一些原因也没解决\n为什么编程开发要配置环境变量\n知道什么是环境变量以后，现在应该明白我们在开发 java、python、php 之前需要配置的环境变量的原因了吧！\n比如 Java 我们就需要把 JDK 的 bin 目录添加到环境变量的 path 中，这样我们就可以在任意目录下使用 bin 下面的 .exe 可执行程序 javac.exe\njavac.exe 用来处理 .java 源代码文件，是把源代码文件编译为字节码文件的一个工具,经过 javac.exe 这个工具编译 java 源代码文件后形成的 .class 就是字节码文件\njava.exe 用来处理 .class 字节码文件进行执行的，也就是 JVM 解释执行 java 程序, 从而实现 java 程序的运行\n而他们都在 bin 目录下, 这都是为了能够方便的使用这些开发语言所带有的编译解释工具和命令, 所以我们才要配置环境变量。如果环境变量配置不成功，在 cmd 中去输入 java 就会提示找不到某某的关键词\n所以在开始学习 java 或者其他一些开发语言的时候，为了操作方便必须要配置一下环境变量 从而达到能够正常运行 java 的环境, 其他一些语言也是以此类推!\n","thumbnail":"2024/环境变量/./thumb.png","plink":"https://CHONG589.github.io/2024/环境变量/"},{"title":"scanf相关知识","date":"2024-01-30T07:08:35.000Z","date_formatted":{"ll":"2024年1月30日","L":"2024/01/30","MM-DD":"01-30"},"author":"Chong","updated":"2024-12-25T06:39:27.000Z","content":"\n使用 scanf 的注意事项\nscanf 里面不能像 printf 那样在里面输入 \\n,因为在 scanf 中你在里面写了什么，在输入的时候你要原模原样的输入回去。\n123456789101112//这时你输入 i 和 j 时中间就要输入逗号才能正确输入。scacnf(&quot;%d,%d&quot;,&amp;i,&amp;j);//这时你就要在输入 i 和 j 的中间要加上一个空格。scanf(&quot;%d %d&quot;,&amp;i,&amp;j);//这时你在输入 i 后还要输入 \\n 才能结束。scanf(&quot;%d\\n&quot;,&amp;i);//如果你在里面没有输入其他，则你输入 i 和 j 时的间隔符可以//是空格、回车、Tab。scanf(&quot;%d%d&quot;,&amp;i,&amp;j);\nscanf 在用 %s 输入字符串时，输入的字符串中不能有空格、Tab、回车键等，它会作为当前输入的结束，即空格、Tab、回车键后面的字符不会再输入进去。\n\n\n用 %s 也是非常危险的操作，当你输入的字符串超过了接收数组容量时，它不会报错，而是原样输入进去，这样就发生了越界现象，使之存到了这个数组之外的空间中\n\n\nscanf 会返回一个值，当你在 scanf中输入两个值时，scanf(&quot;%d%d&quot;,&amp;i,&amp;j);如果正确输入，则会返回2，若输入错误，则返回不是2的值。所以它在放入循环中时要进行输入是否正确判断，若输入的格式不对，如本来要输入整型值的你输入字符类型，那么你输入错误，则会从你上一次输入的值中取。\n\n\n1234567int i;while(1)&#123;\tint ret = scanf(&quot;%d&quot;,&amp;i);\tif(ret != 1)\t\tbreak;\tprintf(&quot;i = %d\\n&quot;,i);&#125;\n或\n1234int i;while(scanf(&quot;%d&quot;,&amp;i))&#123;\tprintf(&quot;i = %d\\n&quot;,i);&#125;\n如果你没进行判断跳出，只要中间你输入一个错误，它就会一直输出你上一次输入的值，一直死循环。\n在用连续的 scanf 时，输入一个字符后，按回车确定的回车符会被下一个 scanf 吸收。（常常会在循环中遇到这种问题，导致出错）\n这种错误尤其是在循环中要求输入的字符为 char 时，因为回车符就是 char 。当在连续两个 scanf 使用时,当输入的是 int 时不会。\n12scanf(&quot;%c&quot;,&amp;i);scanf(&quot;%c&quot;,&amp;j);\n这样输入时，你输入第一个值 i 时，然后回车确定，再输入 j 时，此时 j 接收的是回车符。可以用 getchra() 吃掉一个回车符。\n123scanf(&quot;%c&quot;,&amp;i);getchar();scanf(&quot;%c&quot;,&amp;j);\n总结\n\n\n所以在循环中有输入规定格式的值时，要判断输入的值正不正确，即判断 scanf 返回的值，可以将加入到 while(scanf()) 中判断。\n\n\n当输入的值为 char 时，要注意输入后确定的回车符，也会被当作输入值输入进去，要用一个来吸收回车符，输入值为 int 时，不会被吸收，因为回车符为 char。\n\n\n","thumbnail":"2024/scanf相关知识/./thumb.png","plink":"https://CHONG589.github.io/2024/scanf相关知识/"},{"title":"Learn","date":"2024-03-11T10:43:00.000Z","date_formatted":{"ll":"2024年3月11日","L":"2024/03/11","MM-DD":"03-11"},"updated":"2024-12-24T13:35:32.066Z","content":"C 语言基础知识\n\n编程注意的问题\nscanf 相关知识\nstatic\n二维数组\n字符数组\n指针与变量\n函数\n构造类型\n动态内存管理\n重定义 typedef\n函数中指针传参问题\n\n数据结构\n\n顺序表 (sqlist)\nmain.c    sqlist.c    sqlist.h    makefile\n链表 (Linklist)\n\nnohead: main.c   list.c   list.h   makefile   笔记\nhead:\nlib1:\nlib2:\nlib3:\nlib4:\n\n\n\n","plink":"https://CHONG589.github.io/Learn/"},{"title":"关于","date":"2024-02-26T16:00:00.000Z","date_formatted":{"ll":"2024年2月27日","L":"2024/02/27","MM-DD":"02-27"},"updated":"2024-12-24T13:40:11.026Z","content":"关于我\n","plink":"https://CHONG589.github.io/about/"},{"title":"LeetCode Solutions（Cpp）","date":"2019-06-29T16:00:00.000Z","date_formatted":{"ll":"2019年6月30日","L":"2019/06/30","MM-DD":"06-30"},"updated":"2024-12-24T13:35:59.482Z","content":"简体中文 ｜ English ｜ \nEasy\n\n0001. Two Sum\n0007. Reverse Integer\n0009. Palindrome Number\n0013. Roman to Integer\n0014. Longest Common Prefix\n0020. Valid Parentheses\n0021. Merge Two Sorted Lists\n0026. Remove Duplicates from Sorted Array\n0027. Remove Element\n0028. Implement strStr()\n0035. Search Insert Position\n\nMedium\n\n0002. Add Two Numbers\n0003. Longest Substring Without Repeating Characters\n0005. Longest Palindromic Substring \n0006. ZigZag Conversion\n0008. String to Integer (atoi)\n0011. Container With Most Water\n0012. Integer to Roman\n0015. 3Sum\n0016. 3Sum Closest\n0017. Letter Combinations of a Phone Number\n0018. 4Sum\n0019. Remove Nth Node From End of List\n0022. Generate Parentheses\n0024. Swap Nodes in Pairs\n0029. Divide Two Integers\n0031. Next Permutation\n0050. Pow(x, n)\n0134. Gas Station\n\nHard\n\n0004. Median of Two Sorted Arrays\n0010. Regular Expression Matching\n0023. Merge k Sorted Lists\n\n","plink":"https://CHONG589.github.io/leetcode/index-en/"},{"title":"LeetCode 刷题记录（Cpp）","date":"2024-02-26T16:00:00.000Z","date_formatted":{"ll":"2024年2月27日","L":"2024/02/27","MM-DD":"02-27"},"updated":"2024-12-24T13:31:53.394Z","content":"简体中文 ｜ English ｜ \n","plink":"https://CHONG589.github.io/leetcode/"}]