[{"title":"函数中指针传参问题","date":"2024-02-16T07:51:58.000Z","date_formatted":{"ll":"2024年2月16日","L":"2024/02/16","MM-DD":"02-16"},"author":"Chong","updated":"2024-02-16T08:00:38.529Z","content":"在函数中进行指针传参时，尤其要注意指针传过去后，在函数里的操作是不是在本指针下进行，有可能是在指针的复制品中进行的，函数执行完后，把里面的变量等被销毁，这样就相当于对传过来的指针什么操作都没有做。\n\n下面有几个关于这个的例子\n例一：\n123456789101112131415161718void func (int **p, int n) &#123;    *p = malloc (n);            // 这就相当于将分配内存的首地址给了 main 中的 p;    if (p = NULL)        exit (1);    return ;&#125;int main () &#123;    int num = 100;    int *p = NULL;    func (&amp;p, num);         // 传指针变量所在的地址    free (p);    exit (0);&#125;\n例二：\n123456789101112131415161718192021void sqlist_create1 (sqlist **ptr) &#123;    *ptr = malloc (sizeof (**ptr));    if (*ptr == NULL)        return ;        (*ptr) -&gt; last = -1;    return ;&#125;sqlist *list = NULL;    datatype arr[] = &#123;12, 23, 34, 45, 56&#125;;    datatype arr1[] = &#123;78, 89, 56, 23, 10&#125;;    sqlist_create (&amp;list);    if (list == NULL) &#123;        fprintf (stderr, &quot;sqlist_create () failed!\\n&quot;);        exit (1);    &#125;    \n例三：\n有头节点的链表创造\n1234567891011list *list_create () &#123;    list *me;    me = malloc (sizeof (*me));    if (me == NULL)        return NULL;    me -&gt; next = NULL;    return me;&#125;\n从这里可知，无论是有头节点还是无头节点，在创造链表的函数中，都有这个问题，要么是要把函数里创造好的链表传回来，要么就是用二级指针传参过去，即当在 main 函数中定义了一个指针后，不能只是这样将一个空指针传过去，这样只会是在函数中复制一个复制品，用二级指针则意味着是操作的就是这个指针。即指针为空时，要注意传参问题。\n12345678910111213141516171819202122232425262728// 注意：在操作无头节点时，函数的传参形式尤其要注意，比如在这里，me 是有可能被 free () 掉的，如果// 最后，没将 me = q; me 就会丢失掉（即链表丢失），main 函数里调用 show 就会出现段错误，因为 me // 已经被释放掉，你再访问就段错误了。而带头节点的就不会有此类问题，因为头指针一直都是指着头节点的，// 而头节点无论怎么样都不会被释放掉或者是改变，在操作时会跳过头节点操作。node_st *jose_kill (node_st *me, int n) &#123;    node_st *p, *q = me;    int i;        while (q -&gt; next != q) &#123;        for (i = 1; i &lt; n; i++) &#123;            p = q;            q = q -&gt; next;        &#125;        printf (&quot;delete: %d\\n&quot;, q -&gt; data);        p -&gt; next = q -&gt; next;        free (q);        q = p -&gt; next;            &#125;    me = q;    return me;&#125;\n这里的问题就是在 kill 的过程中会把 me 指向的节点 free () 掉，要把 me 重新指向后返回来，至于为什么还要返回，是因为当 me free () 后， me 就相当于空指针，什么都没有，则在实参传过来的什么都没指向，而最后将 me = q; 对它操作同上面的原理一样，要返回来。\n而关于销毁链表的函数不用，一是因为在一个一个销毁的过程中也没丢失头指针的指向，二是因为最后返回来的本来就是什么都没有的，只要把指针指向的空间 free () 掉就行。\n对于有头节点的删除节点不会有这个问题，始终有头节点在那，而无头结点的删除可能要注意一下。\n","thumbnail":"2024/函数中指针传参问题/./nsurlprotocol.png","plink":"https://CHONG589.github.io/2024/函数中指针传参问题/"},{"title":"重定义 typedef","date":"2024-02-06T06:36:57.000Z","date_formatted":{"ll":"2024年2月6日","L":"2024/02/06","MM-DD":"02-06"},"author":"Chong","updated":"2024-02-16T08:02:25.714Z","content":"typedef 与 define 的区别\n123#define IP int *IP p, q;    --&gt; int *, q;\n123typedef int *IP;IP p, q;    --&gt; int *p, *q;\ndefine 只是简单的替换，typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。\ntypedef 的本质\n1234567891011typedef int ARR[6];         --&gt; int [6] -&gt; ARR;  // int [6] 为数组的本质ARR a; --&gt; int a[6];// ------------------------------------------------------typedef int FUNC (int);     --&gt; int (int)   FUNC;FUNC f; --&gt; int f(int); typedef int *FUNCP (int);FUNC p; --&gt; int *p (int);\n","thumbnail":"2024/重定义-typedef/./xcode-clean.png","plink":"https://CHONG589.github.io/2024/重定义-typedef/"},{"title":"段错误","date":"2024-02-06T05:10:50.000Z","date_formatted":{"ll":"2024年2月6日","L":"2024/02/06","MM-DD":"02-06"},"author":"Chong","updated":"2024-02-16T08:07:13.159Z","content":"段错误（Segmentation Fault）是一种常见的运行时错误，通常发生在访问未分配的内存或者试图读写不允许访问的内存区域时。虽然段错误本身是一个简单的错误，但却可能导致程序不可预测的行为，甚至是崩溃，在Linux中也会导致许多软件无法正常运行。\n\n段错误的原因\n未分配的内存\n当程序试图访问未经分配的内存区域时，会触发段错误。这可能是因为 忘记分配内存 或者 试图访问已经释放的内存。\n12int *ptr;*ptr = 10;      // 未分配内存\n定义了指针要为其分配内存才能使用，我们平时直接指向变量、数组等，好像并没有分配内存也直接用了，其实你在定义变量、数组后，已经为变量，数组分配了空间，你让指针指向它们，是可以直接使用的。\n内存越界\n尝试访问数组或其他数据结构的超出边界的元素，导致访问了不允许访问的内存区域。\n空指针引用\n试图使用空指针访问内存中的数据，导致段错误。\n12int *ptr = NULL;int value = *ptr; // 空指针引用，导致段错误\n还有在释放了内存后，通常将指针指向 NULL, 防止之后访问该指针，如果之后又访问了该指针就会报段错误\n123456789101112131415161718int main () &#123;    int *p = NULL;    p = malloc (sizeof (int));          if (p == NULL) &#123;        printf (&quot;malloc () error!&quot;);        exit (1);                              &#125;    *p = 11;    printf(&quot;%d\\n&quot;, *p);    free (p);                       // 释放空间    p = NULL;                       // 防止后面访问                                  exit (0);&#125;\n栈溢出\n当递归函数调用层级太深或者局部变量占用过多栈空间时，可能导致栈溢出，触发段错误。\n未初始化的指针\n使用未初始化的指针进行内存访问，会引发段错误。\n内存保护\n一些操作系统或硬件平台会对某些内存区域进行保护，试图修改这些区域的内容会导致段错误。\n12const char *str = &quot;Hello, World!&quot;;str[0] = &#x27;h&#x27;; // 尝试修改只读内存，导致段错误\n文件操作错误\n尝试读写一个不可访问的文件或者试图操作不存在的文件也可能引发段错误。\n","thumbnail":"2024/段错误/./apple.png","plink":"https://CHONG589.github.io/2024/段错误/"},{"title":"动态内存管理","date":"2024-02-05T08:40:25.000Z","date_formatted":{"ll":"2024年2月5日","L":"2024/02/05","MM-DD":"02-05"},"author":"Chong","updated":"2024-02-05T16:06:26.823Z","content":"在头文件 #include &lt;stdlib.h&gt; 中\n1234void *calloc (size_t nmemb, size_t size);   // 一个成员 size 大小空间，共分配给 nmemb 个成员void *malloc (size_t size);void free (void *ptr);void *realloc (void *ptr, size_t size);     // 已分配的空间不够，重新分配 size 大小的空间(size 包含了原先的大小)\n原则：谁申请，谁释放\n123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main () &#123;    int *p = NULL;    p = malloc (sizeof (int));      // 没必要这样 p = (int *)malloc (sizeof (int)); 加一个强制转换                                    // void * 适合任何类型    if (p == NULL) &#123;        printf (&quot;malloc () error!&quot;);        exit (1);                           // 分配失败，结束进程    &#125;    *p = 11;    printf(&quot;%d\\n&quot;, *p);    free (p);                       // 释放空间                                  exit (0);&#125;\n面试题\n123456789101112131415161718void func (int *p, int n) &#123;    p = malloc (n);    if (p = NULL)        exit (1);    return ;&#125;int main () &#123;    int num = 100;    int *p = NULL;    func (p, num);    free (p);    exit (0);&#125;\n这段程序的问题：main 中 p 指向了 NULL( NULL 在地址为 0 的位置)，然后传给形参，使 func 中的 p 也指向了 NULL ，即指向了地址为 0 的位置，然后 func 中为它的 p 分配了内存(计算机找到对应需要的连续空间，并把该空间的首地址给 func 中的 p)，这时其实两个 p 已经指向了不同的空间了(因为传参时形参是复制了一份实参的值，\n这里复制了指针的地址,使之也指向了 NULL,这时是两个指针，只不过是指向了同一个地址，但之后为另一个指针分配了空间，使 func 里的 p 指向了另一个空间)，在调用的函数运行完后，在该函数中的变量，指针变量会自动释放，因为这些变量只在该函数中存在，所以这样的话，func 中的 p 存的首地址就丢失了，但 func 里分配的空间\n又没释放，在 main 中释放的是一个空指针，这就导致了内存泄漏。\n改进方法：\n第一种：采用二级指针\n123456789101112131415161718void func (int **p, int n) &#123;    *p = malloc (n);            // 这就相当于将分配内存的首地址给了 main 中的 p;    if (p = NULL)        exit (1);    return ;&#125;int main () &#123;    int num = 100;    int *p = NULL;    func (&amp;p, num);         // 传指针变量所在的地址    free (p);    exit (0);&#125;\n第二种方法\n123456789101112131415161718void *func (int *p, int n) &#123;    p = malloc (n);    if (p = NULL)        exit (1);    return p;&#125;int main () &#123;    int num = 100;    int *p = NULL;    p = func (p, num);    free (p);    exit (0);&#125;\n有关 free 的理解\n有时我们在已经释放的内存中再进行操作，如 free § 后，又进行 *p = 123;, 这是很严重的错误，因为这个空间很可能其他设备已经在使用。\n意识：在 free § 后，再 p = NULL;如果我们后面又对 p 进行了操作，程序会报段错误，这样就防止了污染其它空间。\n","thumbnail":"2024/动态内存管理/./thumb.png","plink":"https://CHONG589.github.io/2024/动态内存管理/"},{"title":"构造类型","date":"2024-02-04T09:47:18.000Z","date_formatted":{"ll":"2024年2月4日","L":"2024/02/04","MM-DD":"02-04"},"author":"Chong","updated":"2024-02-05T08:38:28.393Z","content":"结构体\n\n\n产生及意义\n\n\n类型描述(不占存储空间)，描述是怎样一个结构，是一个类型，如 int、char\n 1234567struct 结构体名 &#123;    数组类型 成员1；    数据类型 成员2；    ......  &#125;；\n\n\n嵌套定义\n 12345678910111213141516struct birthday_st &#123;    int year;    int month;    int day;&#125;;struct student_st &#123;    int id;    char name[NAMESIZE];    struct birthday_st birth;    int math;    int chinese;&#125;;\n或\n 1234567891011121314struct student_st &#123;    int id;    char name[NAMESIZE];    struct birthday_st &#123;        int year;        int month;        int day;    &#125;birth;    int math;    int chinese;&#125;;\n\n\n定义变量(变量、数组、指针)、初始化及成员引用\n成员引用：变量名.成员名\n像上面 struct birthday_st birth 定义变量的方式，这个变量名 birth 存的只是结构体的首地址。\n成员引用：指针 -&gt; 成员名\n(*指针).成员名\n\n\n占用内存空间大小\n内存对齐\n\n\n函数传参（值，地址）\n一般不用结构体的值(即整个结构体)传参，因为当结构体里的成员很多时，定义形参时也要相对应的大小，内存开销大，所以我们一般传指针，形参只需定义指针即可，而指针变量大小在同一机器中时是固定。\n\n\n共用体\n\n\n产生及意义\n共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。\n\n\n类型描述\n 1234567union [union tag]&#123;member definition;member definition;...member definition;&#125; [one or more union variables];\nunion tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。\n\n\n嵌套定义\n练习：对一个具有 32 位值的高 16 位和低 16 位进行相加\n方法一：根据共用体和结构体的特性进行解决\n 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;union &#123;    struct &#123;        uint16_t i;        uint16_t j;    &#125;x;    uint32_t y;&#125;a;int main () &#123;    a.y = 0x11223344;    printf(&quot;%x&quot;, a.x.i + a.x.j);    exit (0);&#125;\n方法二：用位运算解决\n 1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;int main () &#123;    uint32_t i = 0x11223344;    printf(&quot;%x\\n&quot;, (i &gt;&gt; 16) + i &amp; 0xffff);    exit (0);&#125;\n\n\n定义变量（变量、数组、指针），初始化及成员引用\n跟结构体一样\n\n\n占用内存空间大小\n共用体占用的内存应足够存储共用体中最大的成员\n\n\n函数传参（值，地址）\n\n\n位域\nC 语言的位域（bit-field）是一种特殊的结构体成员，允许我们按位对成员进行定义，指定其占用的位数。\n 1234struct &#123;    int i;    int j;&#125;a;\n这种结构需要 8 字节的内存空间，但在实际上，在每个变量中，我们只存储 0 或 1，在这种情况下，C 语言提供了一种更好的利用内存空间的方式。如果您在结构内使用这样的变量，您可以定义变量的宽度来告诉编译器，您将只使用这些字节。例如，上面的结构可以重写成：\n 1234struct &#123;    int i: 1;    int j: 1;&#125;a;\n现在，上面的结构中，a 变量将占用 4 个字节的内存空间(内存对齐的原因)，但是只有 2 位被用来存储值。如果您用了 32 个变量，每一个变量宽度为 1 位，那么 a 结构将使用 4 个字节，但只要您再多用一个变量，如果使用了 33 个变量，那么它将分配内存的下一段来存储第 33 个变量，这个时候就开始使用 8 个字节。\n\n\n枚举\n枚举是 C 语言中的一种基本数据类型，用于定义一组具有离散值的常量，它可以让数据更简洁，更易读。枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性。\n定义一个枚举类型，需要使用 enum 关键字，后面跟着枚举类型的名称，以及用大括号 {} 括起来的一组枚举常量。每个枚举常量可以用一个标识符来表示，也可以为它们指定一个整数值，如果没有指定，那么默认从 0 开始递增。枚举语法定义格式为：\n123enum　枚举名　&#123;    枚举元素1,枚举元素2,……&#125;;\n接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：\n1234567#define MON  1#define TUE  2#define WED  3#define THU  4#define FRI  5#define SAT  6#define SUN  7\n这个看起来代码量就比较多，接下来我们看看使用枚举的方式：\n123enum DAY &#123;      MON=1, TUE, WED, THU, FRI, SAT, SUN&#125;;\n注意：第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。\n可以用 enum 当成宏来使用，enum 在预处理后，里面的值不会替换，这样在查看哪里错的时候，这样才能更直观的知道这个变量是干嘛的，而不是被替换成了值。\n","thumbnail":"2024/构造类型/./thumb.png","plink":"https://CHONG589.github.io/2024/构造类型/"},{"title":"函数","date":"2024-02-02T14:01:05.000Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"author":"Chong","updated":"2024-02-04T09:45:03.771Z","content":"1. 函数的定义\n\n数据类型   函数名   (形参说明)\n\n1234int main (int argc, char *argv[]) &#123;    return 0;&#125;\nargc 是一个计数器，计算从终端传了多少个参数过来。argv[] 是一个列表，用来保存传过来的参数。\n2. 函数的传参\n值传参\n地址传参\n全局变量\n\n3. 函数的调用\n\n\n嵌套调用\n\n\n递归调用 (面试常考，非常考验编程功底)\n阶乘\n  12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int func (int n) &#123;    if (n &lt; 0)        return -1;        if (n == 0 || n == 1)        return 1;    return n * func (n - 1);&#125;int main () &#123;    int n;    int res;    scanf(&quot;%d&quot;,&amp;n);    res = func(n);    printf(&quot;%d! = %d\\n&quot;,n,res);        exit(0);&#125;\n斐波那契数列\n  12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// 1, 1, 2, 3, 5, 8, 13, 21, 34......// n = (n - 1) + (n - 2)// (n == 1 || n == 2)  ---&gt;   return 1;  int fib (int n) &#123;    if (n &lt; 0)        return -1;    if (n == 1 || n == 2)        return 1;        return fib (n - 1) + fib (n - 2);&#125;int main () &#123;    int n;    int res;    printf(&quot;请输入你要求的斐波那契数列的项数：\\n&quot;);    scanf(&quot;%d&quot;,&amp;n);    res = fib(n);    printf(&quot;fib[%d] = %d\\n&quot;,n,res);    exit(0);&#125;\n\n\n4. 函数与数组\n\n\n数组传参方式\n传参时传的是数组的首地址，所以还要传数组的大小。\n  123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void print_arr (int *p, int n) &#123;    int i;    for (i = 0; i &lt; n; i++)        printf(&quot;%d &quot;, p[i]);    printf(&quot;\\n&quot;);&#125;int main () &#123;    int a[] = &#123;1, 2, 3, 6, 6, 7&#125;;    print_arr(a,sizeof(a) / sizeof(*a));    exit(0);&#125;\n在 print_arr 函数中，接收数组的是一个指针变量，也就是接收的是数组首地址，实际上这个函数是不知道数组的大小的，只知道数组首地址，而在定义函数时用 sizeof§ / sizeof(*p) 是不可行的，sizeof§ 肯定是 8 字节，这是固定的，这算出来的是接收地址的指针变量的大小，并不是数组的大小。所以在传参时要传数组的大小。\n  1void print_arr (int p[], int n)\n定义时这样写成数组的形式，看似好像是把整个数组传过去了，实则不然，它的含义仍然是指针变量，跟上面是一样的。\n所以在形参中定义成数组的形式和在 main 函数中定义时是不一样的，作为形参时，它就是指针变量。\n  123456int a[N] = &#123;1, 2, 4, 5, 6&#125;;int *p = a;实参：         a       *a           a[0]        &amp;a[3]       p[i]        p       *p          p+1                       *(a+0)                               *(p+i)              *(p+0)形参接收类型： int*     int          int         int*        int         int*    int        int*     \n数组逆序实现\n  1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void func (int *a, int n)&#123;    int i, j, tmp, mid;    mid = (n - 1) / 2;    for(i = 0; i &lt;= mid; i++)&#123;            j = n - 1 -i;            tmp = a[i];            a[i] = a[j];            a[j] = tmp;    &#125;&#125;int main () &#123;    int a[] = &#123;1, 3, 5, 7, 9&#125;;    // puts(a);     puts 是用于输出 char *     int i;    for(i = 0; i &lt; sizeof(a) / sizeof(*a); i++)        printf(&quot;%d &quot;, a[i]);    printf(&quot;\\n&quot;);    func(a,sizeof(a) / sizeof(*a));    for(i = 0; i &lt; sizeof(a) / sizeof(*a); i++)        printf(&quot;%d &quot;, a[i]);    printf(&quot;\\n&quot;);    exit(0);&#125;\n\n\n函数与二维数组\n方式一：\n  1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M   3#define N   4void print_arr (int *p, int n) &#123;    int i;    for(i = 0; i &lt; n; i++)&#123;        printf(&quot;%d &quot;, p[i]);    &#125;    printf(&quot;\\n&quot;);&#125;int main () &#123;    int a[M][N] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;;    print_arr(&amp;a[0][0], M * N);    exit(0);&#125;\n注意这里函数的形参采用的是一级指针接收，传入的实参不能直接传 a, a 为二维数组，为行指针，一级指针只能在列指针中移动，所以实参应转化为列指针 &amp;a[0][0] 传入, 把二维数组当成一个大的一维数组，个数为 M * N 。这里 &amp;a[0][0] 还可以为 *a 、a[0]、*(a + 0)。\n方式二：\n  12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M   3#define N   4// 二维数组 a 的本质就是一个数组指针,指向数组的指针void print_arr (int (*p)[N], int m, int n) &#123;      // 或 void print_arr(int p[][N], int m, int n)    int i, j;    printf(&quot;sizeof(p) = %d\\n&quot;,sizeof(p));   //  结果为：8，所以也是一个指针变量，不过这个指向的是一个数组，数组大小为 N 个元素    for(i = 0; i &lt; m; i++)&#123;        for(j = 0; j &lt; n; j++)&#123;            printf(&quot;%4d &quot;, *(*(p + i) + j));     // 或 printf(&quot;%4d &quot;, p[i][j]);          &#125;        printf(&quot;\\n&quot;);    &#125;    printf(&quot;\\n&quot;);&#125;int main () &#123;    int a[M][N] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;;    printf(&quot;sizeof(a) = %d\\n&quot;,sizeof(a));      // 结果为 48    print_arr(a, M, N);    exit(0);&#125;\n如果想在实参中传入一个二维数组，而不是把它当成一维数组传入，那么在函数定义时的形参中要有与二维数组相对应的类型，前面已学过二维数组的本质就是数组指针，所以要接收一个二维数组，就应该在形参中用数组指针接收，a + 1 和 p + 1 效果是一样的，都是行指针。int (*p)[N] 中 N 为二维数组的列数。将二维数组接收过来后，对应的行数和列数也接收过来了，接下来就跟平时处理二维数组时一样。\n同样，跟一维数组一样，传过来的数组，接收的是首地址，同样不知道大小，所以还要传大小参数。\n  12345678int [M][N] = &#123;&#125;;int *p = *a;int (*q)[N] = a;实参：      a[i][j]     *(a+i)+j        a[i]+j      p[i]        *p      q[i][j]     *q       q              p+3     q+2                                                                                    *(q+0)形参类型：  int          int *          int *       int          int     int         int *   int (*)[N]    int *    int(*)[N]\n练习题\n求每个学生的平均成绩\n  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M   3#define N   5void print_arr (float (*p)[N], int m, int n) &#123;    int i, j;    printf(&quot;  科目一  科目二  科目三   科目四  平均\\n&quot;);    for(i = 0; i &lt; m; i++)&#123;        for(j = 0; j &lt; n; j++)&#123;            printf(&quot;%7.2f &quot;, *(*(p + i) + j));        &#125;        printf(&quot;\\n&quot;);    &#125;    printf(&quot;\\n&quot;);&#125;// 求每个学生的平均成绩，并把平均成绩写在后面void average (float (*p)[N], int m, int n) &#123;    int i, j;    for(i = 0; i &lt; m; i++)&#123;        float tmp = 0;        for(j = 0; j &lt; n; j++)&#123;            tmp += p[i][j];         &#125;        p[i][4] = tmp / (N - 1);    &#125;&#125;int main () &#123;    float a[M][N] = &#123;&#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;, &#123;9, 10, 11, 12&#125;&#125;;        average(a, M, N);    print_arr(a, M, N);    exit(0);&#125;\n\n求总平均成绩和把指定学生的四科成绩打印出来\n  12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M   3#define N   4float average_scope(int *p, int n) &#123;    float sum = 0;    int i;    for(i = 0; i &lt; n; i++) &#123;        sum += p[i];    &#125;    return sum / n;&#125;void find_num(int (*p)[N], int num) &#123;    int i;    for(i = 0; i &lt; N; i++) &#123;        printf(&quot;%d &quot;, *(*(p + num) + i));    &#125;    printf(&quot;\\n&quot;);&#125;int main () &#123;    int a[M][N] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;;    int i, j;    float ave;    int num = 0;    ave = average_scope(*a, M * N);    printf(&quot;ave = %.2f\\n&quot;, ave);    find_num(a, num);    exit(0);&#125;\n\n\n函数与字符数组\nstrcpy 的实现，它在库中的封装方式为：\nchar *strcpy (char *dest, const char *src); \nsrc 为常量指针，不能通过该指针改变变量的值，因为该指针的内容是不能改变的。所以自己实现 strcpy 的代码也可用这种形式：\n  123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char *mystrcpy (char *dest, const char *src) &#123;    char *ret = dest;                   // 用 ret 记录 dest 的头指针，因为下面 dest++ 指针会移动    if (dest != NULL &amp;&amp; src != NULL)    // 最后返回 ret 即可        while ((*dest++ = *src++) != &#x27;\\0&#x27;);        return ret;&#125;int main () &#123;    char str1[] = &quot;helloworld&quot;;    char str2[128];    mystrcpy (str2, str1);    puts (str2);                // puts 会自动在后面加换行符    exit (0);&#125;\nstrncpy 实现\n  1234567891011121314151617char *mystrncpy (char *dest, const char *src, size_t n) &#123;    int i;    for (i = 0; i &lt; n &amp;&amp; (dest[i] = src[i]); i++) &#123;        // (dest[i] = src[i]) 作用是一边拷贝到 dest 中，一边用作判断，当 (dest[i] = src[i])        // 的值为 \\0 即在 &amp;&amp; 运算中式子不成立，跳出循环,因为 有时 src 的长度会小于 n ，即 src         // 不够长, 那就只拷贝 src 那么长的    &#125;        // i &lt; n 时才拷贝 \\0, i &gt;= n，会自动跳过这条语句    for (; i &lt; n; i++)        dest[i] = &#x27;\\0&#x27;;        return dest;&#125;\n若 src 没有 n 那么长，经过 (dest[i] = src[i]) 将 \\0 复制到了 dest 中,且判断跳出循环，这时 \\0 是赋值到了字符串中的，当 src &gt; n 时，是因为 i &lt; n 跳出的，\\0 并无拷贝，最后应该将 dest[i] = ‘\\0’;\n\n\n5. 函数与指针\n指针函数 (返回值为指针)\n根据 Type name 可知，指针函数是定义函数，所以为\n定义形式：返回值 函数名 （形参）  如：int *fun (int)\n用途：例如前面 find_num 的实现，它只让你找到第几个学生的成绩，并没有然你输出，你却遍历输出那个学生的成绩，显然不是最完美的解决方案，这时就可以用返回一个指向函数的指针\n理论上的实现方式：\n12345int (*)[N] find_num (int (*p)[N], int num) &#123;    return (p + num);&#125;\n把指针 p 移动到第 num 的学生的位置，由于 p 为行指针，所以理论上要这样写返回值就也要为对应的类型，即也要行指针，所以返回值为 int (*)[N],但是我们就只是想要得到第 num 行的那些数据，根本不需整个二维数组的形式返回来，只需在 num 行使用列指针即可，所以可以这样：\n12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M   3#define N   4int * find_num (int (*p)[N], int num) &#123;    if (num &gt; M - 1)        return NULL;        // 不能写 -1，因为返回类型为指针    return *(p + num);     // 也可 p[num];&#125;int main () &#123;    int a[M][N] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;;    int i, j;    int num = 0;    int *res;    res = find_num(a, num);    if (res != NULL) &#123;        for(i = 0; i &lt; N; i++)            printf(&quot;%d &quot;, res[i]);        printf(&quot;\\n&quot;);    &#125;else &#123;        printf(&quot;Can not find!\\n&quot;);    &#125;    exit(0);&#125;\n函数指针\n记忆：整型指针为指针指向整型，那么函数指针自然就是指向函数的指针\n根据 Type name 可知，函数指针是定义指针，所以为\n定义形式：类型 （*指针名） (形参)  如: int (*p)(int);\n类型：int (int) --&gt; 函数和形参的类型\nname: *p\n两个合起来就为 int (*p)(int);\n12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int add (int a, int b) &#123;    return a + b;&#125;int main () &#123;    int a = 3, b = 5;    int ret;    int (*p) (int, int);    p = add;            // 也可 p = &amp;add; 函数名跟数组名一样，就是个地址    // ret = add (a, b);  // 原来的写法    ret = p (a, b);    printf (&quot;%d\\n&quot;, ret);      exit(0);&#125;\n函数指针数组\n指针数组：数组中每个元素就是一个指针\n函数指针：指向函数的指针\n函数指针数组：数组中每个元素都是一个指向函数的指针\n定义：类型 (*数组名 【下标】)  (形参) 如：int (*arr[N]) (int);\n类型：int (int) --&gt; 函数和形参的类型\nname: *arr[N] \n两个合起来就为 int (*arr[N]) (int);\n指向指针函数的函数指针数组\n函数指针数组：数组中每个元素都是一个指向函数的指针\n指针函数 (返回值为指针)，即这个函数是指针类型的\n数组中的每个指向函数的指针\n定义：int *(*funcp[N])(int);\n指针数组：(*funcp[N])\n函数指针数组: 要加上返回值类型和形参类型，即：int (*funcp[N])(int)(int);\n指针函数：即返回值为指针（即返回值为地址），将里面的元素的返回值为整型指针，而不是整型。int *(*funcp[N])(int);\n总结\n自己的理解：为什么不能直接调用函数，而是特地定义指针来，因为函数名是地址常量，函数指针是指针变量，有区别，就跟前面学的指针变量跟数组名一样的区别。\n老师讲解：传参时如果传一个函数名过去(因为可能要用到某函数，将此函数传过去用)，这时形参就要定义一个同类型的来接收。\n传整形数     ----&gt;    整型指针接收\n传数组名     ----&gt;    指针接收\n函数名       ----&gt;    指向函数的指针来接收\n如：快速排序的封装\n1void qsort (void *base, size_t nmemb, size_t size, int (*compar) (const void *, const void *));\n此方式定义为函数指针，返回值为函数\n总之就是为了满足传参的要求，这些函数叫回调函数。\n数组、指针与函数的结合\n数组指针：像整型指针为指向整型的指针，而数组指针则为指向数组的指针。\nType name\nType —&gt; 数组 —&gt; int[N]\nname —&gt; 指针 —&gt; *p\nType name —&gt; int (*p)[N];\n指针数组：数组中每个元素就是一个指针。\nType —&gt; int *\nname —&gt; arr[N]\nType name —&gt; int *arr[N]\n指针函数：定义函数\n返回值 函数名 （形参）\n返回值 —&gt; int *\n函数名 —&gt; func\n函数指针：指向函数的指针\n定义指针\nType name\nType —&gt; int (int)\nname —&gt; *p\nint (*p) (int)\n函数指针数组：数组中每个元素都是一个指向函数的指针\n指针数组：int *arr[N]\n函数指针：int (*p) (int)\n只需将函数指针的指针名改为数组的形式就可\nint (*arr[N]) (int)\n指向指针函数的函数指针数组\n指针数组是指向函数，那么指向指针函数的函数指针数组为指向指针函数，只需在定义函数的返回值时定义指针类型即可\nint *(*func[N]) (int)\n","thumbnail":"2024/函数/./thumb.png","plink":"https://CHONG589.github.io/2024/函数/"},{"title":"指针与变量","date":"2024-02-02T13:55:50.000Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"author":"Chong","updated":"2024-02-15T12:07:23.567Z","content":"1. 变量与地址\n12int i = 1;int *p = &amp;i;\np 就是一个指针变量，用来存放变量 i 的地址值，所以我们平常所说的定义一个指针指向一个值，其实就是定义一个指针变量来存放这个值的地址。\nint **q = &amp;p;\np 是一个指针变量，q 是用来存放指针变量 p 的地址值的变量，即定义时一个 * 指存放地址的变量，** 指是用来存放指针变量的地址的变量。要满足两边的类型相同。\n1234int *p;float *q;double *d;char *c;\n不管定义的是什么类型的指针变量(即我们通常说的指针)，是几级的指针，以及定义的结构体类型的指针，其在某一个平台上所占的空间是确定的大小，在 64 位的机器上占 8 个字节。\n不同类型的指针，其在运算时，如 *p 在做取值运算时，若 p 为 char ，则取一个字节，int 时，则取四个字节，所以什么类型的数据，要对应什么类型的指针，不然在取值时取得的大小与实际不符。\n2. 指针与指针变量(上面也有解释)\n\n指针：就是一个地址，是常量，不会变的。\n指针变量：用来存放指针的变量，可以改变。\n我们常说的某指针指向谁，哪个指针又指向谁，是指改变指针变量的值\n\n3. 直接访问与间接访问\n123456789int i = 1;int *p = &amp;i;    int **q = &amp;p; i --&gt; 1                        q --&gt; 0x3000 --&gt; &amp;p&amp;i --&gt; 0x2000                   &amp;q --&gt; 0x4000  p --&gt; 0x2000    --&gt; &amp;i         *q --&gt; *(&amp;p)  --&gt; &amp;i&amp;p --&gt; 0x3000                  **q --&gt; *(*q)  --&gt; *(&amp;i) --&gt; 1*p --&gt; *(0x2000) --&gt; 1\n\n4. 空指针与野指针\n\n野指针：int *p = 0x2000; 这种直接赋地址的形式，因为你不知道这块地址是否可用，通常很危险。\n空指针：int *p = NULL; NULL 即为位于地址 0 的位置，0 号地址不分配给任何进程，指针定义出来后暂时还不知道指向哪里时，则将它指向 NULL；\n\n5. 空类型\n1void *q = NULL;     \n\n任何类型的指针值都能够把自己的值赋给 void *， void * 也能够把当前自己的值赋给任何类型的指针。当自己不知道要用到什么类型的值时使用。\n\n6. 定义与初始化的书写规则\n7. 指针运算\n1*     &amp;   关系运算   ++   --\n*p++：等同于：*p;  p += 1;\n解析: 但是，因为 ++ 后置的时候，本身含义就是先运算后增加1（运算指的是p++作为一个整体与前面的 * 进行运算；增加1指的是p+1），所以实际上 *p++ 符号整体对外表现的值是 *p 的值，运算完成后 p 再加1.\n*++p：等同于 p += 1;    *p;\n解析：由于 ++ 在 p 的前面，++ 前置的含义是，先 p 加1，得到一个新的p（它的值是原来p的值加1）。然后这个新的 p 再与前面的 * 结合.\n8. 指针与数组\n\n\n指针与一维数组\n  123int a[3] = &#123;1,2,3&#125;;int *p = a;int i;\na[i] = *(a + i) = *(p + i) = p[i];\n&amp;a[i] = a + i = p + i = &amp;p[i];\n这样看来指针(指针变量)好像是等价于一维数组的，但是它们是不完全等价的，首先，a 是地址，是一个常量，p 是指针变量，是一个变量，a++ 是不能运算的 (a = a + 1), 常量不能出现在运算符左边进行赋值操作，但 p++ 可以。\n  12p++    --&gt;  p = p + 1 --&gt; p 的指向已经改变p + 1  --&gt;  p 的指向未改变  \n\n\n指针与二维数组\n二维数组结合指针的理解: a[i][j] 相当于是数组名为 a[i],然后取第 j 个元素，即为 a[i][j],用指针的形式表示为：*(*(a + i) + j); (a + i) 是先按行移动指针，移动的 ‘1’ 就是一行，即一行 j 个元素，移到第 i 行的首地址，此时 (a + i) 还只是 a[i] 的函数名，即在第 i 个数组的函数名地址，要想取 a[i] 还要加一个 * 进行取值操作，结果为 a[i]（具体可参考二维数组的二次分配）, 而 a[i] 又为 a[i][j] 的函数名，即地址，a[i] + j 为 a[i][j] 的地址，* 取值后成为 a[i][j].\n二维数组的二次分配解析: 二维数组的行指针就是一个二级指针用于存储一级指针的地址，所以在分配行指针时大小就是一个指针变量的大小，它是存一级指针的地址。二维数组 a[i][j] 中，(a + i) 表示的就是取第 i 个二级指针变量里存的地址（就是一级指针的地址），而 *(a + i) 就是取一级指针里的内容，即变量的地址（为a[i]）\n  123int a[2][3] = &#123;1,2,3,4,5,6&#125;;int i, j;int *p;\np = a 是不允许的，因为 p 是在列指针上移动的，而 a 是在行指针上移动的，即 p + 1 和 a + 1 所表达的含义不一样，a + 1 是指加一行，p + 1 是加一个元素。\np = *a 即为 *(a + 0) 此种形式是可以的，此时 *a 取的是数组元素的地址,而不是存储元素地址的地址，使之在数组在列指针上移动，即每加 1 为一个元素大小。\n  1234p = *a;for(int i = 0; i &lt; 6; i++)    printf(&quot;%d &quot;,p[i]);printf(&quot;\\n&quot;);\n二维数组也可以用这种方式输出。\n\n\n指针与字符数组\n  12char str[10] = &#123;&quot;hello world&quot;&#125;;char *s; s = &quot;china&quot;;\nC 语言中编译器会给字符串常量分配地址，如 “china”，存储在内存中的 0x3000, 0x3001, 0x3002, 0x3003, 0x3004, 0x3005; 字符串常量的本质表现是代表它的第一个字符的地址，即 0x3000; 所以 s = &quot;china&quot; 是可以的，此操作相当于 s = “china” = 0x3000; 但是 str = &quot;hello world&quot; 是不允许的，str 是地址常量，不能赋给它。\n所以 printf(&quot;%s&quot;,s); 是通过字符串首地址输出字符串，因为字符串在内存中是连续存放的，遇到 \\0 结束\n其实它与 printf(&quot;%s&quot;,0x3000); 是等效的，前者是用了一个指针变量存储 0x3000, 后者是直接用地址，后者与 printf(&quot;%s&quot;,str) 等价，因为 str 就是地址常量，则可以 s = str, 但不能 str = s;\n因为 s 为指针变量，本身就是可以存地址的，将 str 的地址赋给 s 就是将数组 str[] 的首地址给指针 s。 而 str = s , str 在定义的时候就已经分配了地址空间，即首地址是已经固定了的，而 str = s 这样是在改变它的地址了，肯定不可能。\nchar *s = &quot;china&quot;; 的本质是一个指针变量，只占八个字节(64位机器中)，用来保存第一个字符的地址(str 就是一个地址)，它可以用 printf(&quot;%c&quot;,s[i]); 逐个输出字符，或 printf(&quot;%c&quot;,*s++); s[i] 就是 *(s + i)；例：\n  1234char str[] = &quot;hello&quot;;printf(&quot;%d %d\\n&quot;,sizeof(str),strlen(str));strcpy(str,&quot;world&quot;);puts(str);\nsizeof(str)为 6 字节，strlen(str) 为 5 字节，而puts(str)输出为 world,正确输出。strcpy 是将 world 复制到常量地址 str 开头的地址空间中。\n  1234char *s = &quot;hello&quot;;printf(&quot;%d %d\\n&quot;,sizeof(s),strlen(s));strcpy(s,&quot;world&quot;);puts(s);\n这段程序会报段错误（Segmentation Fault），为什么数组 str 不会，而用指针 s 就会，这就要理解内存分配的问题了，要使用内存，必须先分配了才能使用。\n定义了指针要为其分配内存才能使用，我们平时直接指向变量、数组等，好像并没有分配内存也直接用了，其实你在定义变量、数组后，已经为变量，数组分配了空间，你让指针指向它们，是可以直接使用的。\n而字符串常量 “hello” 赋给指针的本质是将字符串所在的空间的首地址给指针，指针只存了首地址，并没有为指针分配空间，但是用 char str[] = &quot;hello&quot;;,定义数组时就已经为数组分配了空间了。所以用数组不会报错\n通过 strcpy 的源码可知\n  12345678910//返回char*的原因是 可以在其他函数中直接调用。char * strcpy(char *dst,const char *src) &#123;          // 源字符串参数用const修饰，防止修改源字符串     assert(dst != NULL &amp;&amp; src != NULL);             // 检查指针的有效性      char *ret = dst;                                // 记下dst的初始地址防止找不到    while ((*dst++=*src++)!=&#x27;\\0&#x27;);                  // 将src中所有字符(包括&#x27;\\0&#x27;)一个字符一个字符的拷贝到dst(包括&#x27;\\0&#x27;)。在赋值完&#x27;\\0&#x27;后，循环停止    return ret;&#125;\n观察可知，在复制的过程中，dst++ 会移动，即 s++ ，而又没有为指针 s 分配内存，你这样做是访问未分配给你的内存，自然就报段错误\n\n\n9. const 与 指针\n\n\nconst 的概念\nconst 关键字是一种修饰符。所谓“修饰符”，就是在编译器进行编译的过程中，给编译器一些“要求”或“提示”，但修饰符本身，并不产生任何实际代码。就 const 修饰符而言，它用来告诉编译器，被修饰的这些东西，具有“只读”的特点。在编译的过程中，一旦我们的代码试图去改变这些东西，编译器就应该给出错误提示。\n\n\n与 define 的区别\ndefine 定义的对象没有数据类型，编译器只能机械地进行字符替换，没有类型安全检查，即会出现“边际问题”或者是“括号问题”。而 const 定义的是变量，有数据类型。如：我们想要这样定义\n  1#define PI 3.14\n但是我们不小心写成了\n  1#define PI sdlkf\n编译器也不会报错，而是编译时直接用该值替换，如果用 const 则不会，它本身就是变量，有数据类型，会进行安全检查，sdlkf 是 char ，而 3.14 为 float ，这样编译器就会报错。同样，define 还会出现括号问题,所以 const 既有变量的有点，又有 define 的优点。\n\n\nconst 变量\nconst 变量指的是，此变量的值是只读的，不应该被改变。如果我们在程序中试图修改 const 变量的值，在编译的时候，编译器将给出错误提示(即在代码中出现赋值给 const 变量的语句)。正因为 const 变量的值在给定以后不能改变，所以 const 变量必须被初始化。（如果不初始化，之后还怎么赋值呢？）如果我们不初始化 const 变量，编译时也会有错误提示。\n定义形式：\n  12const int a;int const a;\n这两种定义方式都是可以的，但是记得一定要初始化。\n  123const float pi = 3.14;float *p = &amp;pi;*p = 3.14159;\n这样通过指针来改变 pi 的值编译器可以通过，但是这样也是非常危险的。会出现警告：初始化丢弃了指针目标类型的限定。正确的做法应该为 const float *p = &amp;pi;,即指向 const 变量的指针也应该定义成 const 类型。所以说 const 变量也不是不可以改变的。即不通过改变量来修改值，而是通过指针间接修改。\n\n\n常量指针\n常量指针是指针指向的内容是常量\n  12const int *p;int const *p;\n可以结合以下方法记忆\nint *p; 为整型指针，是指向整型的指针，自然 const int *p 就为指向常量的指针。\n常量指针说的是不能通过这个指针改变变量的值，但可以通过其他的引用来改变变量的值。\n  123int cnt = 5;const int* num = &amp;cnt;cnt=6;\n即不能 *num = 6; 这样改变值，但可以 cnt = 6;来改变。如果 cnt 也加上 const 来限定就不可以这样来改了。\n所以要想不改变一个变量的值，应该这样：\n  12const float pi = 3.14;const float *p = &amp;pi;\n这样无论是用指针 p 还是用变量 pi 都无法修改 pi 的值。\n常量指针指向地址中保存的值不能改变，但是指向的地址可以改变。\n  1234int cnt = 5;int tmp = 6;const int* num = &amp;cnt;num = &amp;tmp;\n联想记忆：可以想象成它定义的是 *p ,而它表示指针指向的值，则表示值不能改变。\n\n\n指针常量\n指针常量是指指针本身是个常量，不能再指向其他的地址，写法如下：\n  12int *const p;const int *const p;\n需要注意的是，指针常量指向的地址不能改变，但是地址中保存的数值是可以改变的，可以通过其他指向该地址的指针来修改。\n  1234int cnt = 5;int *tmp = &amp;cnt;int* const num = &amp;cnt;*tmp = 6;\n直接用 *num = 6; 也可以修改。\n联想记忆：它定义的是 p ，表示一个地址，则为指向的地址不能改变。\n\n\n指向常量的常指针\n  1const int *const p;\n这相当于是常量指针与指针常量的结合，指针指向的位置不能改变并且也不能通过这个指针改变变量的值。\n\n\n10. 指针数组与数组指针(工作常用，指针函数、数组指针)\n数组指针：像整型指针为指向整型的指针，而数组指针则为指向数组的指针。\n\n【存储类型】 数据类型  (*指针名)【下标】  = 值\n\n1int (*p)[3]; --&gt; type name; --&gt; int[3] *p;\ntype 可以是 int char double,以及结构体类型，上面这种为数组类型。int *p; p 每加一，p 移动一个 int 大小，而 int (*p)[3]即int[3] *p移动三个 int 大小。是数组间移动。\n1234int a[2][3] = &#123;1,2,3,4,5,6&#125;;int i,j;int *p = *a;int (*q)[3] = a;\n这种形式定义的 q 每加一，和 a 加一是一样的，q 加一，移动三个 int型元素大小，和二维数组的行指针一样。但要注意区别：a 是常量，q 是变量。二维数组的本质就是一个数组指针。\n指针数组：数组中每个元素就是一个指针。\n\n【存储类型】 数据类型  * 数组名【下标】  = 值；\n\n1int * arr[3];  --&gt;  TYPE NAME;\n11. 多级指针\n","thumbnail":"2024/指针与变量/./thumb.png","plink":"https://CHONG589.github.io/2024/指针与变量/"},{"title":"字符数组","date":"2024-02-02T13:50:00.000Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"author":"Chong","updated":"2024-02-15T10:34:03.584Z","content":"字符数组\n1. 初始化\n（1）单个字符初始化\nchar str[N] = &#123;'a','b','c'&#125;;\n（2）字符串常量初始化\n\n\nchar str[N] = &quot;a&quot;;\n这个要区别于一般的数组，虽然这里只有 “a” 一个字符，但是它占用了两块空间，末尾还有一个 \\0,表示结束标志(这个是只有字符数组才有’\\0’，像整型数组等是没有的)。所以即使你在输出时想输出 3 个字符，但它遇到 \\0 会自动结束。例：\n12for(int i = 0; i &lt; 3; i++)  printf(&quot;%c&quot;,str[i]);\n这时只会输出一个字符 ‘a’。\n\n\n在用 gets(str) 连续输入字符串时，也会出现和用 scanf(&quot;%s&quot;,   str) 一样的问题，即使输入的大小大于数组的大小时，也不会报错，会导致越界。并且它会自动在输入结束后加 \\0。\n字符数组在初始化时只有在定义时才可以char str[N] = &quot;hello&quot;;而在定义完后，不能单独这样赋初值：str = &quot;hello&quot;;, str 表示地址，是一个常量，不能给常量赋值。\n\n\n2. 相关的函数\n包含在 #include &lt;string.h&gt;\n12345/*strlen &amp; sizeof *strcpy &amp; strncpy *strcat &amp; strncat *strcmp &amp; strncmp */\n\n\nstrlen 计算的长度不包含 ‘\\0’。\n\n\nsizeof 计算的是在内存中真正所占的字节数，即包含 ‘\\0’。\nchar str[] = &quot;hello\\0abc&quot;;\n\n\n用strlen(str) 所得出的结果是 5 个字节，而用 sizeof(str) 得出的结果是 10 个字节。\n\n\nstrcpy()\n不能用 str = &quot;hello&quot;;这样赋值，但可用 strcpy(),复制以 '\\0’作为结束标志。接收拷贝值的容器必须有足够大小装拷贝的值。\nstrcpy(str,&quot;abcde&quot;);\n\n\nstrncpy()\n防止目标接收容器不够大的情况\nchar *strncpy(char *dest,const char *src,size_t n);\nn 的大小一般设置成 dest 的大小减一。\n\n\nstrcat() 连接\n  1234char str[] = &quot;hello&quot;;strcat(str,&quot; &quot;);strcat(str,&quot;world!&quot;);puts(str);\n输出结构：hello world!\n\n\nstrcpm() 比较的是 ASCII\nint strcpm(const char *s1,const char *s2);\ns1 == s2,返回为 0\ns1 &lt; s2,返回为负值\ns1 &gt; s2,返回正值\n可以用 s1 - s2 理解\n\n\n3. 练习\n（1）单词计数\n123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// 单词间的间隔形式// sldk   sdfasdf           fasldjf          asdlkfj// sldkjf                       fasldjkf// 分隔符的后面是一个字母表示这是一个单词新开始的位置，// 某一个字母的前面不是分隔符表示位于单词内部，不去计数。int main()&#123;    char str[128];    int count = 0;    int flag = 0;                           // 标记前一个是否为一个字母    gets(str);                              // gets 遇到分隔符不会结束输入，scanf 的 %s 才会    for(int i = 0; str[i] != &#x27;\\0&#x27;; i++)&#123;        if(str[i] == &#x27; &#x27;)                   // 表示当前字符为分隔符            flag = 0;                       // 当前字符为分隔符，不是字母，flag 置0        else                                // 当前字符为字母            if(flag = 0)&#123;                   // 且前一个字符为分隔符，count++,将 flag = 1                count++;                flag = 1;            &#125;    &#125;    printf(&quot;count = %d\\n&quot;,count);    exit(0);&#125;\n","thumbnail":"2024/字符数组/./thumb.png","plink":"https://CHONG589.github.io/2024/字符数组/"},{"title":"二维数组","date":"2024-02-02T12:18:01.000Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"author":"Chong","updated":"2024-02-15T11:16:05.104Z","content":"二维数组的分配\n假设要为一个 m * n 的数组分配内存空间\n1. 一次分配\n\n这种分配就是把它当作一维数组来分配，通过 i 和 j 的值，计算出具体位置。该分配的内存必须是连续的。\n1234567int *arr = (int *)malloc(sizeof(int) * m * n);for(int i = 0; i &lt; m; i ++)&#123;    for(int j = 0; j &lt; n; j ++)&#123;        arr[i * n + j] = 1;    &#125;&#125;\n注意每个元素的下标和 i 、j 的关系\n2. 二次分配\n\n首先分配一个指针数组 *arr[i],以行为单位，一行表示一个指针，该指针数组中的每个元素都是一个数组指针，该指针又指向一个一维数组。后面再对该数组指针分配内存空间(即对一维数组分配)，这种二维内存的分配是分两次来分配的，因此分配的内存是不连续的。\n12345678// 为指针数组分配内存int **arr = (int **)malloc(sizeof(int *) * m);// 为每个指向数组的指针分配空间，即每个指针只需一个指针变量接收，共有 m 个。// 再为每个指针数组分配内存空间for(int i = 0; i &lt; m; i ++)&#123;    arr[i] = (int *)malloc(sizeof(int) * n);&#125;\n","thumbnail":"2024/二维数组/./thumb.png","plink":"https://CHONG589.github.io/2024/二维数组/"},{"title":"环境变量","date":"2024-01-31T15:03:55.000Z","date_formatted":{"ll":"2024年1月31日","L":"2024/01/31","MM-DD":"01-31"},"author":"Chong","updated":"2024-02-03T08:00:55.802Z","content":"我们平时在装有些软件时，要配置环境变量，那么为什么要配置？它起什么作用？\n\n什么是环境变量\n是在操作系统中一个具有特定名字的对象，它包含了一个或多个应用程序所将使用到的信息, 例如: 如系统临时文件夹位置、系统文件夹位置、某些应用软件文件的路径等等…\n当要求系统运行一个程序但是又没有告诉它这个程序所在的完整路径时，系统默认会在当前目录下面寻找这个程序,如果找不到就会到环境变量中的 path 中指定的路径去找, 所以我们用户可以通过设置环境变量，来更好的运行程序!\n例：当我们在 cmd 命令行窗口中输入 qq 时：\n\n提示\n1&#x27;qq&#x27; is not recognized as an internal or external command\n所以这种方式不能打开 QQ 程序的，如果我们非要在 cmd 中打开 QQ 程序，我们要进入并且找到这个程序的 bin 目录下的 qq.exe 执行程序！\n我电脑中的 QQ 路径为：D:\\Program Files (x86)\\QQ\\QQ\\Bin\n在 cmd 中进入该路径且输入QQ.exe\n\n所以我们是可以通过命令行中进入到执行程序的位置进行打开该程序，这个效果跟你在桌面点击快捷方式是一个效果。如果关掉 cmd 后重新打开，再次输入 QQ 其实又是同样的问题，这就意味着你要从 cmd 打开 QQ 必须每次按照刚才的步骤进行打开，并且你还必须要切换到这个 QQ 的 bin 目录下才行，这样就很麻烦了（当然这只是个例子，我们完全可以通过快捷方式打开程序）。\n那么有没有办法让我们在随便哪个目录中都可以直接使用 cmd 输入一个 QQ 就可以打开的办法呢?\n这时就要使用到环境变量！你只要把刚刚那个 bin 目录的路径添加到环境变量中的系统变量下的 path 就可以了，这里的 path 也就是环境变量中用来指定可执行文件的绝对路径，这里配置了很多路径，彼此之间用分号隔开!这里操作以 windows 10 为例，步骤如下：\n右键点击此电脑 ---&gt; 属性 ---&gt; 高级系统设置 ---&gt; 环境变量\n\n然后找到系统环境变量 ---&gt; Path ---&gt; 编辑 ---&gt; 新建\n\n\n复制你 QQ 安装目录下的 bin 路径到新建的对话框中\n\n\n最后全部点击确定即可！这时你就可以在 cmd 中的任意目录、任意盘符下进行打开这个应用程序了！\n总之，环境变量 的主要作用就是规定了某些系统文件的所在位置！\n用户变量和系统变量的区别\n\n\n用户变量：在环境变量中的用户变量配置只会当前所登录的系统用户生效, 也就是说登录的系统用户可以对他自己所配置的环境变量参数进行增删改 , 不同用户的用户变量之间是独立存在的,并且互不干扰的\n\n\n系统环境变量：在环境变量中系统变量的配置会对所有用户都会有效, 也就是说如果系统变量被修改了，那么任何一个用户都将受到影响!但是只有管理员账户才有权限进行系统变量的设置, 普通系统用户是不能够去修改系统变量的\n\n\n如何自定义环境变量命令\n当我们想通过 cmd 来运行一个自己定义的命令时，就会出现不是内部或外部命令，也不是可运行的程序 或批处理文件的提示信息!\n但是如果我们在cmd中输入一个 shutdown 命令则可以完全正常执行!\n\n这个原因也很简单,正因为 shutdown 在环境变量中定义了它这个命令所在的路径,而test这个命令则没有!\nshutdown命令的默认路径是在 C:\\Windows\\System32 目录下, 包括一些常见的cmd命令其实都在这个目录下\n\n而 C:\\Windows\\System32 这个路径也是默认安装系统的时候就被定义在了环境变量当中, 就跟之前定义 QQ 应用程序也是一个道理！\n所以根据这个道理我们也可以自定义一个环境变量来进行调用！要知道变量就是一个可变化的量 我们就利用这个特点来自己定义一个系统变量然后调用它来打开某个应用程序\n我这里要打开微信，当然你完全可以依照之前的办法在 path 中把微信的 WeChat.exe 路径加入到其中, 但是这样子做不够灵活！我们可以先在系统变量中定义一个 weixin 然后值设置为微信目录地址！\n\n\n设置好后，我们现在就可以对它进行调用！在 path 中把刚刚自定义好的 weixin 这个变量加入到其中，格式为 %变量名%\n\n这样一来以后你只需要去修改变量的值 path 中就会自动获取到了！接下来就可以去 cmd 中尝试一下打开这个应用程序\n！！！但是这样在 cmd 中用 weixin 启动不成功，即使在变量值中改成 D:\\Program Files (x86)\\WeChat\\WeChat 也还是不行，网上查了一些原因也没解决\n为什么编程开发要配置环境变量\n知道什么是环境变量以后，现在应该明白我们在开发 java、python、php 之前需要配置的环境变量的原因了吧！\n比如 Java 我们就需要把 JDK 的 bin 目录添加到环境变量的 path 中，这样我们就可以在任意目录下使用 bin 下面的 .exe 可执行程序 javac.exe\njavac.exe 用来处理 .java 源代码文件，是把源代码文件编译为字节码文件的一个工具,经过 javac.exe 这个工具编译 java 源代码文件后形成的 .class 就是字节码文件\njava.exe 用来处理 .class 字节码文件进行执行的，也就是 JVM 解释执行 java 程序, 从而实现 java 程序的运行\n而他们都在 bin 目录下, 这都是为了能够方便的使用这些开发语言所带有的编译解释工具和命令, 所以我们才要配置环境变量。如果环境变量配置不成功，在 cmd 中去输入 java 就会提示找不到某某的关键词\n所以在开始学习 java 或者其他一些开发语言的时候，为了操作方便必须要配置一下环境变量 从而达到能够正常运行 java 的环境, 其他一些语言也是以此类推!\n","thumbnail":"2024/环境变量/./thumb.png","plink":"https://CHONG589.github.io/2024/环境变量/"},{"title":"static","date":"2024-01-30T07:31:31.000Z","date_formatted":{"ll":"2024年1月30日","L":"2024/01/30","MM-DD":"01-30"},"author":"Chong","updated":"2024-02-03T08:01:29.247Z","content":"\nstatic 不仅有继承性，另外，常用于修饰任何变量或者是函数，使用 static 定义的变量，它会自动初始化为 0。\n1. 解决变量冲突问题\n首先有一个 minproj 的工程文件，该文件下有 main.c  proj.c  proj.h 三个文件\nmain.c : 写函数的调用\nproj.c : 函数的实现\nproj.h ：函数声明的位置\nmain.c\n123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;proj.h&quot;int i = 10;int main()&#123;        printf(&quot;[%s]: i = %d\\n&quot;,__FUNCTION__,i);        func();        exit(0);&#125;\nproj.c\n1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;proj.h&quot;int i = 100;void func(void)&#123;                printf(&quot;[%s]: i = %d\\n&quot;,__FUNCTION__,i);        exit(0);&#125;\nproj.h\n1234567#ifndef PROJ_H___#define PROJ_H___void func(void);#endif\n这三个文件当中的全局变量 i 按理来说它们都只作用在本 .c 文件中，因为它们的作用范围和生命周期是不同的，但是编译后出现了错误\n\n显示对 i 的定义重复定义了。所以 main.c 和 proj.c 链接后的 i 会导致作用范围一样，即导致冲突。编译 --&gt; 链接 --&gt; 装入，链接时会出现两个文件的 i。\n解决方法：\n如果想要 main.c 和 proj.c 中的 i 变量作用在各自的 .c 文件中，则在各自定义 i 变量时加上关键字 static。像这样 static int i = 10;这样则当前文件修饰的变量只能在当前文件用，这样就不冲突了。\n2. 函数\n将文件 proj.c 中修改\n1234567static void func(void)&#123;                printf(&quot;[%s]: i = %d\\n&quot;,__FUNCTION__,i);        exit(0);&#125;\n在 proj.h 中声明时也加上 static\n在函数前加了个 static,使其只能在当前文件使用。编译函数\n\n即在 proj.c 文件中，该函数定义只能在该 .c 文件中使用，声明时也同样，所以在 proj.h 中声明时是用不了的，而在 main.c 文件中又使用了 func(), 这样就导致未定义就使用 func() 。\n在函数定义是加上 static 是防止当前函数对外扩展\n解决方法\nmain.c\n123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;proj.h&quot;static int i = 10;int main()&#123;        printf(&quot;[%s]: i = %d\\n&quot;,__FUNCTION__,i);        call_func();        exit(0);&#125;\nproj.c\n123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;proj.h&quot;static int i = 100;static void func(void)&#123;                printf(&quot;[%s]: i = %d\\n&quot;,__FUNCTION__,i);        exit(0);&#125;void call_func()&#123;        func();&#125;\nproj.h\n1234567#ifndef PROJ_H___#define PROJ_H___void call_func();#endif\nfunc() 函数还是只能在本文件使用，只不过借助了一个 call_func() 函数来执行 func().这样就能保证 func() 在本文件中使用，而在其他文件中通过调用 call_func() 来执行 func().\n#####总结\n\n防止工程中链接各文件时，出现相同变量的问题，将变量用 static 定义\n在函数定义是加上 static 是防止当前函数对外扩展\n\n","thumbnail":"2024/static/./thumb.png","plink":"https://CHONG589.github.io/2024/static/"},{"title":"scanf相关知识","date":"2024-01-30T07:08:35.000Z","date_formatted":{"ll":"2024年1月30日","L":"2024/01/30","MM-DD":"01-30"},"author":"Chong","updated":"2024-02-03T08:01:31.525Z","content":"\n1. scanf 里面不能像 printf 那样在里面输入 \\n,因为在 scanf 中你在里面写了什么，在输入的时候你要原模原样的输入回去。\n例：\n\n\nscacnf(&quot;%d,%d&quot;,&amp;i,&amp;j);\n这时你输入 i 和 j 时中间就要输入逗号才能正确输入。\n\n\nscanf(&quot;%d %d&quot;,&amp;i,&amp;j);\n这时你就要在输入 i 和 j 的中间要加上一个空格。\n\n\nscanf(&quot;%d\\n&quot;,&amp;i);\n这时你在输入 i 后还要输入 \\n 才能结束。\n\n\n如果你在里面没有输入其他，如:\nscanf(&quot;%d%d&quot;,&amp;i,&amp;j);\n则你输入 i 和 j 时的间隔符可以是空格、回车、Tab。\n\n\n2. scanf 在用 %s 输入字符串时，输入的字符串中不能有空格、Tab、回车键等，它会作为当前输入的结束，即空格、Tab、回车键后面的字符不会再输入进去。\n\n\n用 %s 也是非常危险的操作，当你输入的字符串超过了接收数组容量时，它不会报错，而是原样输入进去，这样就发生了越界现象，使之存到了这个数组之外的空间中\n\n\nscanf 会返回一个值，当你在 scanf中输入两个值时，scanf(&quot;%d%d&quot;,&amp;i,&amp;j);如果正确输入，则会返回2，若输入错误，则返回不是2的值。所以它在放入循环中时要进行输入是否正确判断，若输入的格式不对，如本来要输入整型值的你输入字符类型，那么你输入错误，则会从你上一次输入的值中取。\n  1234567int i;while(1)&#123;    int ret = scanf(&quot;%d&quot;,&amp;i);    if(ret != 1)        break;    printf(&quot;i = %d\\n&quot;,i);&#125;\n或\n  12345int i;while(scanf(&quot;%d&quot;,&amp;i))&#123;        printf(&quot;i = %d\\n&quot;,i);&#125;\n如果你没进行判断跳出，只要中间你输入一个错误，它就会一直输出你上一次输入的值，一直死循环。\n\n\n3. 在用连续的 scanf 时，输入一个字符后，按回车确定的回车符会被下一个 scanf 吸收。（常常会在循环中遇到这种问题，导致出错）\n这种错误尤其是在循环中要求输入的字符为 char 时，因为回车符就是 char 。\n当在连续两个 scanf 使用时,当输入的是 int 时不会\n12scanf(&quot;%c&quot;,&amp;i);scanf(&quot;%c&quot;,&amp;j);\n这样输入时，你输入第一个值 i 时，然后回车确定，再输入 j 时，此时 j 接收的是回车符。可以用 getchra() 吃掉一个回车符。\n123scanf(&quot;%c&quot;,&amp;i);getchar();scanf(&quot;%c&quot;,&amp;j);\n总结\n所以在循环中有输入规定格式的值时，要判断输入的值正不正确，即判断 scanf 返回的值，可以将加入到 while(scanf()) 中判断\n当输入的值为 char 时，要注意输入后确定的回车符，也会被当作输入值输入进去，要用一个来吸收回车符，输入值为 int 时，不会被吸收，因为回车符为 char。\n","thumbnail":"2024/scanf相关知识/./thumb.png","plink":"https://CHONG589.github.io/2024/scanf相关知识/"},{"title":"编程注意的问题","date":"2024-01-28T13:28:43.000Z","date_formatted":{"ll":"2024年1月28日","L":"2024/01/28","MM-DD":"01-28"},"author":"Chong","updated":"2024-02-03T08:01:03.592Z","content":"我们平时编程时经常会忽略一些细节，导致项目出现问题，且有些很难发现。\n\n1. 头文件正确包含的重要性\n在程序中使用 malloc 函数 时，在程序开头未写头文件 #include&lt;stdlib.h&gt;，这时 gcc 没有看到 malloc 函数头文件的时候，也就看不到它的原型，那它会默认 malloc 的返回值为 int 型，如以下程序。\n12345678910111213#include &lt;stdio.h&gt;int main(void)&#123;    int *p = NULL;    p = malloc(sizeof(int));    if(p == NULL)        return -1;        return 0;&#125;\n默认 malloc 函数的返回值为 int 型后，而程序中接收的是 int* 型指针，这样就会报错。有人会这样解决问题：p = (int*)malloc(sizeof(int));,使用强制转换类型，有时有些编译器不会报错，但是以后经过移植或换个环境等的时候，这个问题就会出现，导致很难找出来。通过 man malloc 查看可知：\n\nmalloc 函数返回的是 void* 类型的值，而 void 可以转变为大部分的类型，所以可以这样写 p = malloc(sizeof(int))\n以后使用 gcc 编译时可以用参数 -Wall ,它会显示全部错误，你只要按照出现的错误一个个解决，后面出现的大部分错误都是来源于这，因为你不把这些错误用 -Wall 打印出来，gcc 有些错误在你编译时没有非常严重的错误，它是会忽略的。\n例：gcc hello.c -Wall\n2. 以函数为单位来进行程序编写\n3. 声明部分 + 实现部分\n4. 对于宏定义的理解\n#define 处理在程序的预处理阶段，占编译时间，特点是，一改全改。缺点：不检查语法，只是单纯的宏体与宏名之间的替换。例如以下程序：\n123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ADD 2 + 3int main()&#123;        printf(&quot;%d\\n&quot;,ADD * ADD);        exit(0);&#125;\n结果为：11\n明显结果不是我们想要的 25，我们用 gcc 的预编译命令 gcc -E defind.c 查看\nprintf(&quot;%d\\n&quot;,ADD * ADD);\nprintf(&quot;%d\\n&quot;,2+3 * 2+3);\n从这里可知宏定义就只是在预编译时单纯的将宏体替换宏名。这里想要正确输出，则要这样定义：#define ADD (2+3)\n带参数形式的使用：\n12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX(a,b)   (a &gt; b ? a : b)int main()&#123;        int i = 5, j = 3;        printf(&quot;%d\\n&quot;,MAX(i,j));        exit(0);&#125;\n输出为：5\n但是逻辑上 a 和 b 也应该各自加上括号，因为传参时的数要考虑到运算的优先级,因为无论是 a 还是 b 在这里都是单独的个体，且可以是 a = 1 + 3 的形式，这样组合起来就要考虑优先级问题，1 + 3 是要自己单独运算的。\n#define MAX(a,b)   ((a) &gt; (b) ? (a) : (b))\n当程序改成如下后\n12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX(a,b)   ((a) &gt; (b) ? (a) : (b))int main()&#123;                int i = 5, j = 3;                      printf(&quot;i = %d\\tj = %d\\n&quot;,i,j);        printf(&quot;%d\\n&quot;,MAX(i++,j++));        printf(&quot;i = %d\\tj = %d\\n&quot;,i,j);        exit(0);&#125;\n将参数改成 i++ 和 j++。结果输出如下\n123i = 5\tj = 36i = 7\tj = 4\n理论上 i = 5 和 j = 3 先进行比较，然后各自自增，i 大，则第二行的输出结果为 i 自增后的结果6（先比较后自增），第三行应为 i = 6，j = 4.可结果不是。\n预编译的结果为\nprintf(&quot;%d\\n&quot;,((i++) &gt; (j++) ? (i++) : (j++))); \n根据这串语句可知，i 和 j 先比较，然后各自自增，由于 i 大，则执行 ？ 后面的 i++，这样 i 就再次自增了一次，所以第三行的 i 为自增了两次的。\n解决方法：像函数的参数一样，用变量接收自增后的结果，而不是在比较完后，又将参数 i++ 执行一次，而是执行的是 i++的结果。\n12345678#define MAX(a,b)   (&#123;                        int A = a, B = b;                        ((A) &gt; (B) ? (A) : (B));                    &#125;)i = 5\tj = 35i = 6\tj = 4\n预编译结果为：\n1printf(&quot;%d\\n&quot;,(&#123;int A = i++, B = j++; ((A) &gt; (B) ? (A) : (B));&#125;));\n这样用变量接收后，则在比较完后执行时就不是执行 i++了，而是执行 A 这个值。\n有时参数未必都是 int 型，则可以\n#define MAX(a,b)   (&#123;typeof(a) A = a, B = b; ((A) &gt; (B) ? (A) : (B));&#125;) \n用 a 的类型定义 A , B。用 typeof() 函数获取类型。\n","thumbnail":"2024/编程注意的问题/./thumb.png","plink":"https://CHONG589.github.io/2024/编程注意的问题/"},{"title":"关于","date":"2020-02-16T16:00:00.000Z","date_formatted":{"ll":"2020年2月17日","L":"2020/02/17","MM-DD":"02-17"},"updated":"2022-09-02T10:52:57.000Z","content":"关于我\n90 后典型水瓶座猫科 （少女，不是） 宅女👧，坐标杭州。\n主攻 iOS 开发，面向谷歌/Stack OverFlow/技术文档能编写 Android、Web、小程序、Flutter 项目，我的技术博文曾经发布在掘金、CSDN、知乎、简书、思否。\n不追星、不追剧、不追番、不追文、偶尔打打王者，日常沉迷工作和学习，追求精神世界的快乐。\n钟情于悬疑、推理、烧脑题材，偶尔羞耻的傻白甜剧也可食用，习惯 2 倍速。\n完美主义，排版强迫症患者。\n不是什么黑洞，生活技能点满，是干啥啥都行的小机灵～👀\n我是…\n（👇记得点开小箭头哦…）\n\n  运动小天才\n   🌟 大学期间蝉联全学院女生体质健康测试分数第一\n   🏃 女子 800m 跑中考成绩 2'40\n   🏆 小学全镇跳远冠军 \n\n\n  虚假的王者\n   🎮 熟悉 KPL 各大战队选手英雄池和 BP 风格\n   👀 意识流召唤师，嘴强王者\n   \n\n\n  脑洞怪兽\n   💡 脑袋中常爆发特别的灵感\n   🎨 想要用有趣的灵魂过有趣的人生\n\n\n  熬夜冠军\n   🌝 参加美赛建模曾四天四夜不睡觉\n   👸 入夜，头脑清醒、文思泉涌、茅塞顿开...\n\n\n  无辣不欢\n   🌶️ 可以直接嚼辣椒\n   🍲 钟情麻辣香锅、四川重庆火锅\n   \n\n\n  热搜雷达\n   🏂 掌握实时热点和八卦信息\n   👻 能接梗\n   \n\n\n  预言家\n   🥛 鲜奶，能够无预兆地预测到未来发生的事\n   🎰 只要不参与下注，预测比赛胜负正确率奇高无比\n   🚗 不依赖导航，靠第六感寻找目的地能力满分\n  \n\n\n  树洞\n   👭 朋友们负能量的消除者\n   🐌 会迟到但不会失约的小伙伴\n\n关于博客\n感谢以下项目为本博客提供服务支持：\n\n框架主题：Hexo 5.1.1 + inside 2.7.0-beta.6\n托管服务：GitHub Pages\n评论系统：Valine\n持续集成：Travis CI\n统计服务：LeanCloud、不蒜子\n\n","plink":"https://CHONG589.github.io/about/"},{"title":"Charles Mac 版破解","date":"2024-02-02T11:48:50.537Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"\n⚠️⚠️⚠️ 请支持正版，仅供技术交流。\n\n步骤：\n1、从官网下载最新版的安装包，如果下载速度太慢，也可以在此下载。\n2、在Charles 在线破解工具网站上生成破解后的 charles.jar 文件\n3、替换本地/Applications/Charles.app/Contents/Java 目录下的 charles.jar 文件\n如果安装时出现这样的报错信息：\n\n只需要在命令行中输入：\n1sudo spctl --master-disable\n设置隐私中， 允许任何来源软件即可。\n","plink":"https://CHONG589.github.io/resources/charles/"},{"title":"Cornerstone 破解","date":"2024-02-02T11:48:50.538Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"\n⚠️⚠️⚠️ 请支持正版，仅供技术交流。\n\n网上直接搜索破解版\n例如：吾爱破解提供的百度网盘下载地址  密码:3ycy\n自行破解\n方案一（未安装软件）\n如果之前未安装，直接把当前系统时间改成未来的某个时间，再安装，成功运行一次后可以退出程序，将系统时间还原。\n方案二（已安装软件）\n如果安装前未修改系统日期，需要通过修改 plist 文件的方式破解。步骤如下：\n步骤一：显示系统隐藏文件。\n在终端中输入以下命令：\n1defaults write ~/Library/Preferences/com.apple.finder AppleShowAllFiles -bool true\n把 true 改成 false 就可以不再显示隐藏文件。\n步骤二：重启 Finder。\n有两种方式：\n方式一、按住 Command+Option+esc 打开对话框，选中 Finder，点击“重新开启”。\n方式二、执行命令：\n1killall Finder\n步骤三：删除安装记录。\n前往目录 ~/Library/Preferences/ByHost，找到 GlobalPreferences.XXXX.plist 文件，XXXX 是一串数字，删掉包含 com.zennaware.Cornerstone:2.0 字样的一行，然后保存。\n步骤四：重新安装。\n卸载应用，按照方法一的步骤再次安装，就能得到永久破解版。\n","plink":"https://CHONG589.github.io/resources/cornerstone/"},{"title":"Dash 破解","date":"2024-02-02T11:48:50.538Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"\n⚠️⚠️⚠️ 请支持正版，仅供技术交流。\n\n破解步骤\n步骤一：下载 Dash4 并安装\n步骤二：本地建一个文件，命名为 license.dash-license，文件内写入内容：\n123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple Computer//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt;   &lt;key&gt;Product&lt;/key&gt;   &lt;string&gt;Dash&lt;/string&gt;   &lt;key&gt;Name&lt;/key&gt;   &lt;string&gt;Yang Wang&lt;/string&gt;   &lt;key&gt;Email&lt;/key&gt;   &lt;string&gt;lizhixiangwang@gmail.com&lt;/string&gt;   &lt;key&gt;Licenses&lt;/key&gt;   &lt;string&gt;1&lt;/string&gt;   &lt;key&gt;Timestamp&lt;/key&gt;   &lt;string&gt;1487632616&lt;/string&gt;   &lt;key&gt;Version&lt;/key&gt;   &lt;string&gt;4&lt;/string&gt;   &lt;key&gt;TransactionID&lt;/key&gt;   &lt;string&gt;KAP170220-3181-48919&lt;/string&gt;   &lt;key&gt;Signature&lt;/key&gt;   &lt;data&gt;DxmY4cUBFC/iYn/zRodj/5EwhL/7TD5BKyqXAOHoE/K19lNCorbnTvWKGmTrWJC242/mT8DJ7Zoddb5J98m8h0Q/YOfDHeDTyTkz5o5gYRAplIzBOqCGwdUjn1YHOI4OsMKH6LIML5VoHIpkxAOQwmmHiHrpg4CHXopKW1uB45Q=&lt;/data&gt;&lt;/dict&gt;&lt;/plist&gt;\n步骤三：双击打开这个 dash-license 文件，会自动导入授权文件，看到如下提示，则破解成功。\n\n","plink":"https://CHONG589.github.io/resources/dash/"},{"title":"FinalShell Mac 版安装","date":"2024-02-02T11:48:50.539Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"官方网站\n一键安装脚本\n1curl -o finalshell_install.sh www.hostbuf.com/downloads/finalshell_install.sh;chmod +x finalshell_install.sh;sudo ./finalshell_install.sh\n直接下载\n下载地址\n","plink":"https://CHONG589.github.io/resources/final-shell/"},{"title":"Mac 实用工具 ｜ 让工作更高效","date":"2024-02-02T11:48:50.550Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"\n📖表示开源软件，点击进入开源仓库；\n🆓表示所有或部分主要功能支持免费使用；\n🔨表示支持破解，点击查看破解方法；\n🔗表示工具相关的插件，点击查看插件列表。\n\n本文中列举的，仅限本人用过且体验较好的工具，在精不在多。不定时更新，如有推荐欢迎补充。\n\n开发相关\nIDE\n\nSublime Text - 一个比较简洁大方带插件管理系统的流行编辑器。（程序员必备）🆓🔗\nXcode - 开发 iOS 和 MacOS 工程的官方 IDE。（iOS 和 Mac 开发必备）🆓\nAppCode - iOS 开发工具，支持 macOS 和 iOS 平台上最流行的编程语言（Swift、Objective-C、C 和 C ++）🔨🔗\nAndroid Studio - 谷歌推出的 Android 集成开发工具，基于 Intellij IDEA。（Android 开发必备）📖🆓🔗\nVisual Studio Code - 微软推出，免费开源的轻量级代码编辑器。（前端开发必备）📖🆓🔗\n微信开发者工具 - 支持微信公众号网页调试和小程序调试的开发工具。（前端开发必备）🆓\nIntelliJ IDEA - Java 编程语言开发的集成环境。在业界被公认为最好的 Java 开发工具之一。（后端开发必备）🔨🔗\nEclipse - 开源、基于 Java 的可扩展开发平台。📖🆓🔗\n\n效率\n\nAlfred - 不多说，极其优秀的 Mac 效率工具。\n\n终端\n\niTerm2 - 免费的终端工具，可替代系统自带的 Terminal。📖🆓\nZsh - 为交互使用而设计的一款 shell，同时它也是一个强大的脚本语言。 📖🆓🔗\n\nAPI 开发与分析\n\nPostman - API 调试工具。🆓\n\n测试自动化\n\nAppium - 适用于原生、hybrid、H5 以及桌面应用程序的开源、跨平台的测试自动化工具。📖🆓\n\nSSH\n\nFinalShell - 良心国货，好用的中文 SSH 工具。🆓\n\n版本控制\n\nSourceTree - 强大的 Git 跨平台客户端。🆓\nGitHub Desktop - GitHub 官方桌面客户端。🆓\nCornerstone - SVN 客户端工具，还能与 Xcode、BBEdit、TextMate、Coda 等开发工具无缝集成使用。🔨\n\n网络分析\n\nCharles - 代理工具，允许你查看所有的 HTTP 和 HTTPS 流量。🔨\nWireshark - 世界上最广泛使用的网络协议分析软件，主要作用是尝试捕获网络包，并尝试显示包的尽可能详细的情况。📖🆓\n\nHelper\n\nDash - API 文档浏览器以及代码片段管理工具。🔨\nPPRows - 在 Mac 上计算你写了多少行代码。📖🆓\nSwitchHosts - 管理、切换多个 hosts 方案的工具。📖🆓\n\n设计&amp;产品\n设计\n\nSketch - 混合矢量/位图布局应用，特别适用于用户界面，Web 和移动设计。🔗\n\n \n原型流程\n\nProcessOn - 国产在线作图平台，支持流程图、思维导图、原型图、UML、网络拓扑图、组织结构图等，可以免费保存 5 个文件。🆓\ndraw.io - 流程图在线绘制工具，也支持客户端离线使用，没有保存文件的数量限制。📖🆓\nStarUML - 超好用的 UML 画图工具。📖🆓🔨\nXMind - 专业思维导图软件。🆓\nMindNode - 简洁可爱风格的思维脑图绘制软件。\n\n图片处理\n\ngifsicle - 用于操作 GIF 图片的命令行工具，可以修改 gif 文件的尺寸大小、颜色、帧率等。 🆓\nImageOptim - 图片优化无损压缩工具。📖🆓\n智图 - 腾讯 ISUX 前端团队开发的一个专门用于图片压缩和图片格式转换的平台，其功能包括针对 png、jpeg、gif 等各类格式图片的压缩，以及为上传图片自动选择最优的图片格式。🆓\n\n\n写作\nMarkDown\n\nCmd Markdown - 在线 MarkDown 编辑阅读器，支持实时同步预览。🆓\nTypora - “读写一体” 简约 Markdown 编辑器。🆓\nMacDown - 开源的 Markdown 编辑器，参照 Mou。📖🆓\nMWeb - 专业的 Markdown 写作、记笔记、静态博客生成软件。🔨\n\n截图&amp;录屏\n\niShot - 免费、功能全面的录屏、区域截图、窗口截图、长截图、延时截图、快速标注、贴图工具。🆓\nGifox - 专业的 GIF 动图制作工具，支持截选区域录屏导出 GIF 动图并进行压缩处理，支持预览和编辑帧文件。\n\n图床\n\nuPic - 支持免费上传到多种图床（SM.MS、 又拍云 USS、七牛云 KODO、 阿里云 OSS、 腾讯云 COS、微博、Github、 Gitee、 Amazon S3、自定义上传接口），开源的图床客户端。📖🆓\niPic - 上传到指定的新浪图床免费，其它的需要付费升级高级版，用户体验相对较优，可以配合 Typora 直接食用。🆓\nPicGo - 全平台开源的图床工具，支持免费上传到多种图床（SM.MS、 又拍云 USS、七牛云 KODO、 阿里云 OSS、 腾讯云 COS、微博、Github、Imgur）。用户可以通过 PicGo-Core 搭建个人图床工具，例如 Visual Studio Code 的 vs-picgo 插件。📖🆓🔗\n\nOffice\n\nWPS - 跨平台的办公室软件套件。🆓\n\n笔记\n\nNotion - 一个统一的笔记、知识、任务管理，并且能够多人协作的工作空间。目前 Personal Plan 已免费。\nEvernote - 支持数据同步的的笔记本应用程序，支持 MarkDown。🆓\n\nRSS\n\nReeder 4 - 老牌的 RSS 阅读器，因其流畅的操作和精致的设计而闻名。🔨\nirreader - 高品质、免费、无广告、多平台的 RSS 和播客阅读器，提供了订阅源市场，可以订阅任何网站。🆓📖\n\n科学上网\n\nLantern - 简单易用的老牌科学上网软件，每月 500M 高速免费流量。🆓\nJust My Socks - 搬瓦工推出的 SS 服务,性价比高且稳定,用的是与搬瓦工同款的 CN2 GIA 和 CN2 GT 线路，最低价 $2.88/月。\nShadowsocksX-NG - Shadowsocks 客户端软件 🆓\nV2rayU - v2ray 的客户端软件，支持 vmess｜shadowsocks｜socks5 等服务协议，支持二维码、剪贴板导入、手动配置、二维码分享、订阅等。（搭建 v2ray 服务，可伪装成正常网站，防封锁。）🆓\n\n系统相关\n\nCleanMyMac X - 经典好用的 Mac 清理工具，需要付费使用。\n柠檬清理 - 腾讯出品的免费的 Mac 系统清理软件。🆓\n\n浏览器\n\nGoogle Chrome - 谷歌浏览器，它的拓展插件功能非常出色，是提升工作效率利器。🆓🔗（如果不能访问谷歌商店，可以通过 crx4chrome 来下载所需的插件。）\nChromium - 开源免费，相当于 Google Chrome 的实验版，在 Chromium 上线稳定后的功能，会在 Google Chrome 中正式推出。📖🆓\n\n办公\n\nThe Unarchiver － 解压不同类型的存档文件。📖🆓\nTeamViewer - 远程协助及在线协作和会议功能的软件，商业软件个人使用免费。🆓\n\n工具网站\n\nMacWk - 精品 Mac 应用集合，支持部分破解版。🆓\n在线工具 VIP - 非常全的小工具功能集合。🆓\ndocsmall - 免费支持在线图片压缩、GIF 压缩、PDF 压缩、PDF 合并、PDF 分割的网站。🆓\n\n图片素材\n\nPixabay - 免费正版高清图片素材库。🆓\nunDraw - 免费的人物主题插画素材网站，支持自定义色系。🆓\n创客贴 - 平面设计作图神器、适用于制作博客/公众号文章封面图、还有免费好看的 PPT 插件。🆓\nDimmy.club - 电脑、手机、iPad 等设备的展示模型，可以提升图片档次。🆓\n\n\n归纳了一下上文中支持破解的工具：\n\n⚠️⚠️⚠️ 请支持正版，仅供技术交流。\n\n\nJetbrains Mac 版全系列 IDE 永久破解教程\nCornerstone 破解\nCharles Mac 版破解\nDash 破解\nStarUML Mac 版破解\nMWeb 破解安装\nReeder 4 Mac 版破解\n\n","plink":"https://CHONG589.github.io/resources/"},{"title":"Jetbrains Mac 版全系列 IDE 永久破解教程","date":"2024-02-02T11:48:50.551Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"\n⚠️⚠️⚠️ 请支持正版，仅供技术交流。\n学生凭学生证可免费申请正版授权。\n创业公司可五折购买正版授权。\n\n注意事项\n现在 http://idea.lanyus.com/ 里的激活码已经不能用的，如果你曾经在 /private/etc/hosts 文件里 Jetbrains 相关的项⽬，请先删除。\n以下教程适用于 Jetbrains 全系列产品 2019.3.3 及以下版本，下文以 IntelliJ IDEA 的破解为例。\n激活步骤\n1、下载安装包。前往官网下载正版的 IDEA。\n2、点击下载（提取码：412x）补丁文件，可以将补丁文件 jetbrains-agent.jar 放在 IDEA 安装目录的 bin 文件夹（即 /Applications/IntelliJ IDEA.app/Contents/bin）下。\n3、启动 IDE，点击激活窗口的 Evalutate for free，开启试用。\n4、修改配置。\n进入欢迎页，在下图中的 Configure 中选择 Edit Custom VM Options …。\n\n如下图所示，在弹出的 idea.vmoptions 文件的最后一行加入 -javaagent:/Applications/IntelliJ IDEA.app/Contents/bin/jetbrains-agent.jar。\n\n5、重启 IDE。（这一步切记不要遗漏。）\n6、在欢迎页 Configure 中选择 Manage License...，选择 License server ⽅式，点击 Discover Server 按钮应该会⾃动填充上地址：http://jetbrains-license-server。然后点击 Activate 按钮，看到如下 Licensed to XXX 则激活完毕。\n\n如果不成功，尝试一下 Activation code 方式离线激活。将 ACTIVATION_CODE.txt 中的激活码粘贴到内容框中。你也可以选择自定义激活码。\n看到如下页面则激活完毕。如果激活无效，可能是因为你下载安装的版本号过高，要下载最近的破解 jar 文件，请参考下面的链接。\n\n\n参考链接：Jetbrains 系列产品 2019.3.3 最新激活方法[持续更新]\n","plink":"https://CHONG589.github.io/resources/jetbrains-series/"},{"title":"0001. Two Sum","date":"2024-02-02T11:48:50.493Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nExample:\n\nGiven nums = [2, 7, 11, 15], target = 9,\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n\nA\n12345678910111213class Solution &#123;    func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] &#123;        var dic = [Int: Int]()        for (i, n) in nums.enumerated() &#123;            let complement = target - n             if dic.keys.contains(complement) &amp;&amp; i != dic[complement] &#123;                return [dic[complement]!, i]            &#125;            dic[n] = i        &#125;        return [];    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0001-en/"},{"title":"0001.两数之和","date":"2024-02-02T11:48:50.494Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n示例：\n\n给定 nums = [2, 7, 11, 15], target = 9\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n\n题解\n12345678910111213class Solution &#123;    func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] &#123;        var dic = [Int: Int]()        for (i, n) in nums.enumerated() &#123;            let complement = target - n             if dic.keys.contains(complement) &amp;&amp; i != dic[complement] &#123;                return [dic[complement]!, i]            &#125;            dic[n] = i        &#125;        return [];    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0001/"},{"title":"Reeder 4 Mac 版破解","date":"2024-02-02T11:48:50.552Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"\n⚠️⚠️⚠️ 请支持正版，仅供技术交流。\n\n可以在网上直接搜到破解版。例如百度网盘 密码：7rg1\n","plink":"https://CHONG589.github.io/resources/reeder/"},{"title":"MWeb 破解安装","date":"2024-02-02T11:48:50.551Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"\n⚠️⚠️⚠️ 请支持正版，仅供技术交流。\n\n安装步骤\n1、点击下载（提取码：yzz8） MWeb v3.3.4 破解版。\n2、安装前先检查系统偏好设置 → 安全性与隐私 → 通用中是否已经选择任何来源选项，如果没有，在终端输入：\n1sudo spctl --master-disable\n3、安装打开时，如果还是出现“MWeb”已损坏，无法打开。 您应该将它移到废纸篓。的提示，检查一下自己的 macOS 系统。如果是 macOS 10.15 Catalina，通过以下命令绕过苹果的公证 Gatekeeper：\n1sudo xattr -rd com.apple.quarantine /Applications/MWeb.app\n","plink":"https://CHONG589.github.io/resources/mweb/"},{"title":"StarUML Mac 版破解","date":"2024-02-02T11:48:50.553Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"\n⚠️⚠️⚠️ 请支持正版，仅供技术交流。\n\n破解步骤\n1、下载并安装 Node.js，如已安装可以跳过。\n2、下载并安装 dmg 包。\n3、安装 asar：\n1sudo npm install -g asar\n4、进入 app.asar 目录：\n1cd /Applications/StarUML.app/Contents/Resources/\n5、解压 app.asar\n1asar extract app.asar app\n6、修改源码绕过注册弹窗\n1open app/src/engine/license-manager.js\n找到 checkLicenseValidity 方法，改成下图所示：\n\n7、重新打包，替换 app.asar\n1asar pack app app.asar\n至此，破解完成。\n","plink":"https://CHONG589.github.io/resources/star-uml/"},{"title":"0002. Add Two Numbers","date":"2024-02-02T11:48:50.494Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample:\n\nInput: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)\nOutput: 7 -&gt; 0 -&gt; 8\nExplanation: 342 + 465 = 807.\n\nA\n123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; *     public var val: Int *     public var next: ListNode? *     public init(_ val: Int) &#123; *         self.val = val *         self.next = nil *     &#125; * &#125; */class Solution &#123;    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? &#123;        var p1 = l1, p2 = l2, node : ListNode?, pointer : ListNode?        var flag = 0        while p1 != nil || p2 != nil || flag == 1  &#123;            let t1 : Int =  p1?.val ?? 0            let t2 : Int =  p2?.val ?? 0            let sum = flag + t1 + t2            if node == nil &#123;                node = ListNode(sum % 10);            &#125; else &#123;                node?.next = ListNode(sum % 10)                node = node?.next            &#125;            pointer = pointer ?? node            p1 = p1?.next            p2 = p2?.next            flag = sum / 10        &#125;        return pointer    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0002-en/"},{"title":"0002. 两数相加","date":"2024-02-02T11:48:50.495Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n示例：\n\n输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)\n**输出：**7 -&gt; 0 -&gt; 8\n**原因：**342 + 465 = 807\n\n题解\n123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; *     public var val: Int *     public var next: ListNode? *     public init(_ val: Int) &#123; *         self.val = val *         self.next = nil *     &#125; * &#125; */class Solution &#123;    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? &#123;        var p1 = l1, p2 = l2, node : ListNode?, pointer : ListNode?        var flag = 0        while p1 != nil || p2 != nil || flag == 1  &#123;            let t1 : Int =  p1?.val ?? 0            let t2 : Int =  p2?.val ?? 0            let sum = flag + t1 + t2            if node == nil &#123;                node = ListNode(sum % 10);            &#125; else &#123;                node?.next = ListNode(sum % 10)                node = node?.next            &#125;            pointer = pointer ?? node            p1 = p1?.next            p2 = p2?.next            flag = sum / 10        &#125;        return pointer    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0002/"},{"title":"0003. 无重复字符的最长字串","date":"2024-02-02T11:48:50.496Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n示例 1：\n\n输入：“abcabcbb”\n**输出：**3\n**解释：**因为无重复字符的最长子串是 “abc”，所以其长度为 3。\n\n示例 2：\n\n输入：“bbbbb”\n**输出：**1\n**解释：**因为无重复字符的最长子串是 “b”，所以其长度为 1。\n\n示例 3：\n\n输入：“pwwkew”\n**输出：**3\n**解释：**因为无重复字符的最长子串是 “wke”，所以其长度为 3。\n请注意，你的答案必须是 子串 的长度，“pwke” 是一个 子序列，不是子串。\n\n题解\n123456789101112131415class Solution &#123;    func lengthOfLongestSubstring(_ s: String) -&gt; Int &#123;        var chars = [Character: Int]()        var length : Int = 0        var i : Int = 0        for (j, ch) in s.enumerated() &#123;            if let head = chars[ch] &#123;                i = max(head + 1, i)            &#125;            chars[ch] = j            length = max(j - i + 1, length)        &#125;        return length    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0003/"},{"title":"0003. Longest Substring Without Repeating Characters","date":"2024-02-02T11:48:50.496Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nGiven a string, find the length of the longest substring without repeating characters.\nExample 1:\n\nInput: “abcabcbb”\nOutput: 3\nExplanation: The answer is “abc”, with the length of 3.\n\nExample 2:\n\nInput: “bbbbb”\nOutput: 1\nExplanation: The answer is “b”, with the length of 1.\n\nExample 3:\n\nInput: “pwwkew”\nOutput: 3\nExplanation: The answer is “wke”, with the length of 3.\nNote that the answer must be a substring, “pwke” is a subsequence and not a substring.\n\nA\n123456789101112131415class Solution &#123;    func lengthOfLongestSubstring(_ s: String) -&gt; Int &#123;        var chars = [Character: Int]()        var length : Int = 0        var i : Int = 0        for (j, ch) in s.enumerated() &#123;            if let head = chars[ch] &#123;                i = max(head + 1, i)            &#125;            chars[ch] = j            length = max(j - i + 1, length)        &#125;        return length    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0003-en/"},{"title":"0004. Median of Two Sorted Arrays","date":"2024-02-02T11:48:50.497Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nThere are two sorted arrays nums1 and nums2 of size m and n respectively.\nFind the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\nYou may assume nums1 and nums2 cannot be both empty.\nExample 1:\n\nnums1 = [1, 3]\nnums2 = [2]\nThe median is 2.0\n\nExample 2:\n\nnums1 = [1, 2]\nnums2 = [3, 4]\nThe median is (2 + 3)/2 = 2.5\n\nA\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -&gt; Double &#123;        var m : Int = nums1.count, n : Int = nums2.count        var A : [Int] = nums1, B : [Int] = nums2        if m &gt; n &#123;            let temp : [Int] = A            A = B            B = temp            let t : Int = m            m = n            n = t        &#125;        let halfLength : Int = (m + n + 1) / 2        var iMin : Int = 0, iMax : Int = m        while iMin &lt;= iMax &#123;            let i : Int = (iMin + iMax) / 2            let j = halfLength - i            if i &lt; iMax &amp;&amp; A[i] &lt; B[j - 1] &#123;                iMin = i + 1            &#125; else if i &gt; iMin &amp;&amp; B[j] &lt; A[i - 1] &#123;                iMax = i - 1            &#125; else &#123;                var leftMax : Int, rightMin : Int                if i == 0 &#123;                    leftMax = B[j - 1]                &#125; else if j == 0 &#123;                    leftMax = A[i - 1]                &#125; else &#123;                    leftMax = max(A[i - 1], B[j - 1])                &#125;                if (m + n) % 2 == 1 &#123;                    return Double(leftMax)                &#125;                if (i == m) &#123;                    rightMin = B[j]                &#125; else if (j == n) &#123;                    rightMin = A[i]                &#125; else &#123;                    rightMin = min(A[i], B[j])                &#125;                return Double(leftMax + rightMin) / 2            &#125;        &#125;        return 0.0    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0004-en/"},{"title":"0004. 寻找两个有序数组的中位数","date":"2024-02-02T11:48:50.498Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。\n请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n你可以假设 nums1 和 nums2 不会同时为空。\n示例 1：\n\nnums1 = [1, 3]\nnums2 = [2]\n则中位数是 2.0\n\n示例 2：\n\nnums1 = [1, 2]\nnums2 = [3, 4]\n则中位数是 (2 + 3)/2 = 2.5\n\n题解\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -&gt; Double &#123;        var m : Int = nums1.count, n : Int = nums2.count        var A : [Int] = nums1, B : [Int] = nums2        if m &gt; n &#123;            let temp : [Int] = A            A = B            B = temp            let t : Int = m            m = n            n = t        &#125;        let halfLength : Int = (m + n + 1) / 2        var iMin : Int = 0, iMax : Int = m        while iMin &lt;= iMax &#123;            let i : Int = (iMin + iMax) / 2            let j = halfLength - i            if i &lt; iMax &amp;&amp; A[i] &lt; B[j - 1] &#123;                iMin = i + 1            &#125; else if i &gt; iMin &amp;&amp; B[j] &lt; A[i - 1] &#123;                iMax = i - 1            &#125; else &#123;                var leftMax : Int, rightMin : Int                if i == 0 &#123;                    leftMax = B[j - 1]                &#125; else if j == 0 &#123;                    leftMax = A[i - 1]                &#125; else &#123;                    leftMax = max(A[i - 1], B[j - 1])                &#125;                if (m + n) % 2 == 1 &#123;                    return Double(leftMax)                &#125;                if (i == m) &#123;                    rightMin = B[j]                &#125; else if (j == n) &#123;                    rightMin = A[i]                &#125; else &#123;                    rightMin = min(A[i], B[j])                &#125;                return Double(leftMax + rightMin) / 2            &#125;        &#125;        return 0.0    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0004/"},{"title":"0005. 最长回文子串","date":"2024-02-02T11:48:50.499Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n示例 1：\n\n输入：“babad”\n输出：“bab”\n注意：“aba” 也是一个有效答案。\n\n示例 2：\n\n输入：“cbbd”\n输出：“bb”\n\n题解\n12345678910111213141516171819202122232425262728293031323334class Solution &#123;    func longestPalindrome(_ s: String) -&gt; String &#123;        if s.count == 0 &#123;            return &quot;&quot;        &#125;        var S = [Character]()        for c in s &#123;            S.append(c)        &#125;        var startIndex : Int = 0, endIndex : Int = 0        for (i, _) in s.enumerated()  &#123;            let addLen = expandCenter(S, i, i)            let evenLen = expandCenter(S, i, i + 1)            let len = max(addLen, evenLen)            if len &gt; endIndex - startIndex &#123;                startIndex = i - (len - 1) / 2                endIndex = i + len / 2            &#125;        &#125;        let leftIndex = s.index(s.startIndex, offsetBy: startIndex)        let rightIndex = s.index(s.startIndex, offsetBy: endIndex + 1)        let sub = s[leftIndex..&lt;rightIndex]        return String(sub)    &#125;        func expandCenter(_ s: [Character], _ left: Int, _ right: Int) -&gt; Int &#123;        var L : Int = left, R : Int = right        while  L &gt;= 0 &amp;&amp; R &lt; s.count &amp;&amp; s[L] == s[R] &#123;            L -= 1            R += 1        &#125;        return R - L - 1    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0005/"},{"title":"0006. ZigZag Conversion","date":"2024-02-02T11:48:50.499Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nThe string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n123P   A   H   NA P L S I I GY   I   R\nAnd then read line by line: &quot;PAHNAPLSIIGYIR&quot;\nWrite the code that will take a string and make this conversion given a number of rows:\n1string convert(string s, int numRows);\nExample 1:\n12Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3Output: &quot;PAHNAPLSIIGYIR&quot;\nExample 2:\n12345678Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4Output: &quot;PINALSIGYAHRPI&quot;Explanation:P     I    NA   L S  I GY A   H RP     I\nA\n1234567891011121314151617181920class Solution &#123;    func convert(_ s: String, _ numRows: Int) -&gt; String &#123;        if numRows == 1 &#123;            return s        &#125;        let zCount = 2 * numRows - 2        var list : Dictionary = [Int:String]()        for (i, c) in s.enumerated() &#123;            let index = i % zCount &gt;= numRows ? zCount - i % zCount : i % zCount            var rowContent : String = list[index] ?? &quot;&quot;            rowContent.append(c)            list[index] = rowContent        &#125;        var newS : String = &quot;&quot;        for i in 0...list.count &#123;            newS += list[i] ?? &quot;&quot;        &#125;        return newS    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0006-en/"},{"title":"0005. Longest Palindromic Substring","date":"2024-02-02T11:48:50.498Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\nExample 1:\n\nInput: “babad”\nOutput: “bab”\nNote: “aba” is also a valid answer.\n\nExample 2:\n\nInput: “cbbd”\nOutput: “bb”\n\nA\n12345678910111213141516171819202122232425262728293031323334class Solution &#123;    func longestPalindrome(_ s: String) -&gt; String &#123;        if s.count == 0 &#123;            return &quot;&quot;        &#125;        var S = [Character]()        for c in s &#123;            S.append(c)        &#125;        var startIndex : Int = 0, endIndex : Int = 0        for (i, _) in s.enumerated()  &#123;            let addLen = expandCenter(S, i, i)            let evenLen = expandCenter(S, i, i + 1)            let len = max(addLen, evenLen)            if len &gt; endIndex - startIndex &#123;                startIndex = i - (len - 1) / 2                endIndex = i + len / 2            &#125;        &#125;        let leftIndex = s.index(s.startIndex, offsetBy: startIndex)        let rightIndex = s.index(s.startIndex, offsetBy: endIndex + 1)        let sub = s[leftIndex..&lt;rightIndex]        return String(sub)    &#125;        func expandCenter(_ s: [Character], _ left: Int, _ right: Int) -&gt; Int &#123;        var L : Int = left, R : Int = right        while  L &gt;= 0 &amp;&amp; R &lt; s.count &amp;&amp; s[L] == s[R] &#123;            L -= 1            R += 1        &#125;        return R - L - 1    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0005-en/"},{"title":"0006. Z 字形变换","date":"2024-02-02T11:48:50.502Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。\n比如输入字符串为 &quot;LEETCODEISHIRING&quot; 行数为 3 时，排列如下：\n123L   C   I   RE T O E S I I GE   D   H   N\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;LCIRETOESIIGEDHN&quot;。\n请你实现这个将字符串进行指定行数变换的函数：\n1string convert(string s, int numRows);\n示例 1：\n12输入：s = &quot;LEETCODEISHIRING&quot;, numRows = 3输出：&quot;LCIRETOESIIGEDHN&quot;\n示例 2：\n12345678输入：s = &quot;LEETCODEISHIRING&quot;, numRows = 4输出：&quot;LDREOEIIECIHNTSG&quot;解释：L     D     RE   O E   I IE C   I H   NT     S     G\n题解\n1234567891011121314151617181920class Solution &#123;    func convert(_ s: String, _ numRows: Int) -&gt; String &#123;        if numRows == 1 &#123;            return s        &#125;        let zCount = 2 * numRows - 2        var list : Dictionary = [Int:String]()        for (i, c) in s.enumerated() &#123;            let index = i % zCount &gt;= numRows ? zCount - i % zCount : i % zCount            var rowContent : String = list[index] ?? &quot;&quot;            rowContent.append(c)            list[index] = rowContent        &#125;        var newS : String = &quot;&quot;        for i in 0...list.count &#123;            newS += list[i] ?? &quot;&quot;        &#125;        return newS    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0006/"},{"title":"0007. Reverse Integer","date":"2024-02-02T11:48:50.502Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nGiven a 32-bit signed integer, reverse digits of an integer.\nExample 1:\n\nInput: 123\nOutput: 321\n\nExample 2:\n\nInput: -123\nOutput: -321\n\nExample 3:\n\nInput: 120\nOutput: 21\n\nNote:\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.\nA\n1234567891011121314151617class Solution &#123;    func reverse(_ x: Int) -&gt; Int &#123;        var n = 0, y = x        while y != 0 &#123;            let pop = y % 10            y /= 10            if n &gt; INT32_MAX / 10 || (n == INT32_MAX / 10 &amp;&amp; pop &gt; 7) &#123;                return 0            &#125;            if n &lt; (-INT32_MAX - 1) / 10 || (n == (-INT32_MAX - 1) / 10 &amp;&amp; pop &lt; -8) &#123;                return 0            &#125;            n = 10 * n + pop        &#125;        return n    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0007-en/"},{"title":"0008. String to Integer (atoi)","date":"2024-02-02T11:48:50.503Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nImplement atoi which converts a string to an integer.\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.\nThe string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.\nIf the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.\nIf no valid conversion could be performed, a zero value is returned.\nNote:\n\nOnly the space character ’ ’ is considered as whitespace character.\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31) is returned.\n\nExample 1:\n\nInput: “42”\nOutput: 42\n\nExample 2:\n\nInput: &quot;   -42&quot;\nOutput: -42\nExplanation: The first non-whitespace character is ‘-’, which is the minus sign.\nThen take as many numerical digits as possible, which gets 42.\n\nExample 3:\n\nInput: “4193 with words”\nOutput: 4193\nExplanation: Conversion stops at digit ‘3’ as the next character is not a numerical digit.\n\nExample 4:\n\nInput: “words and 987”\nOutput: 0\nExplanation: The first non-whitespace character is ‘w’, which is not a numerical\ndigit or a +/- sign. Therefore no valid conversion could be performed.\n\nExample 5:\n\nInput: “-91283472332”\nOutput: -2147483648\nExplanation: The number “-91283472332” is out of the range of a 32-bit signed integer.\nThefore INT_MIN (−2^31) is returned.\n\nA\n123456789101112131415161718192021222324252627282930313233class Solution &#123;    func myAtoi(_ str: String) -&gt; Int &#123;        var sign : Int = 0        var iStr : String = &quot;&quot;        var realFirst = 0        for (i, c) in str.enumerated() &#123;            if c == &quot; &quot; &amp;&amp; sign == 0 &#123;                realFirst = i + 1                continue            &#125;            if i == realFirst &#123;                if c == &quot;+&quot; || c == &quot;-&quot; &#123;                    sign = c == &quot;-&quot; ? -1 : 1                &#125; else if c &gt;= &quot;0&quot; &amp;&amp; c &lt;= &quot;9&quot; &#123;                    sign = 1                    iStr.append(c)                &#125; else &#123;                    return 0                &#125;            &#125; else &#123;                if c &gt;= &quot;0&quot; &amp;&amp; c &lt;= &quot;9&quot; &#123;                    if iStr.count &gt;= 9 &amp;&amp; (Int(iStr)! &gt; Int(INT32_MAX) / 10 || (Int(iStr)! == Int(INT32_MAX) / 10 &amp;&amp; (sign &gt; 0 ? c &gt; &quot;7&quot; : c &gt; &quot;8&quot;))) &#123;                        return sign &gt; 0 ? Int(INT32_MAX) : -Int(INT32_MAX) - 1                    &#125;                    iStr.append(c)                &#125; else &#123;                    break                &#125;            &#125;        &#125;        return sign * (Int(iStr) ?? 0)    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0008-en/"},{"title":"0007. 整数反转","date":"2024-02-02T11:48:50.503Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。\n示例 1：\n\n输入：123\n**输出：**321\n\n示例 2：\n\n输入：-123\n输出： -321\n\n示例 3：\n\n**输入：**120\n**输出：**21\n\n注意:\n假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。\n题解\n1234567891011121314151617class Solution &#123;    func reverse(_ x: Int) -&gt; Int &#123;        var n = 0, y = x        while y != 0 &#123;            let pop = y % 10            y /= 10            if n &gt; INT32_MAX / 10 || (n == INT32_MAX / 10 &amp;&amp; pop &gt; 7) &#123;                return 0            &#125;            if n &lt; (-INT32_MAX - 1) / 10 || (n == (-INT32_MAX - 1) / 10 &amp;&amp; pop &lt; -8) &#123;                return 0            &#125;            n = 10 * n + pop        &#125;        return n    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0007/"},{"title":"0008. 字符串转换整数（atoi）","date":"2024-02-02T11:48:50.504Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n请你来实现一个 atoi 函数，使其能将字符串转换成整数。\n首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。\n当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。\n该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。\n注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。\n在任何情况下，若函数不能进行有效的转换时，请返回 0。\n说明：\n假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。\n示例 1：\n\n输入：“42”\n**输出：**42\n\n示例 2：\n\n输入：&quot;   -42&quot;\n输出：-42\n**解释：**第一个非空白字符为 ‘-’, 它是一个负号。\n我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。\n\n示例 3：\n\n输入：“4193 with words”\n**输出：**4193\n**解释：**转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。\n\n示例 4：\n\n输入：“words and 987”\n**输出：**0\n**解释：**第一个非空字符是 ‘w’, 但它不是数字或正、负号。\n因此无法执行有效的转换。\n\n示例 5：\n\n输入：“-91283472332”\n输出：-2147483648\n**解释：**数字 “-91283472332” 超过 32 位有符号整数范围。\n因此返回 INT_MIN (−231) 。\n\nA\n123456789101112131415161718192021222324252627282930313233class Solution &#123;    func myAtoi(_ str: String) -&gt; Int &#123;        var sign : Int = 0        var iStr : String = &quot;&quot;        var realFirst = 0        for (i, c) in str.enumerated() &#123;            if c == &quot; &quot; &amp;&amp; sign == 0 &#123;                realFirst = i + 1                continue            &#125;            if i == realFirst &#123;                if c == &quot;+&quot; || c == &quot;-&quot; &#123;                    sign = c == &quot;-&quot; ? -1 : 1                &#125; else if c &gt;= &quot;0&quot; &amp;&amp; c &lt;= &quot;9&quot; &#123;                    sign = 1                    iStr.append(c)                &#125; else &#123;                    return 0                &#125;            &#125; else &#123;                if c &gt;= &quot;0&quot; &amp;&amp; c &lt;= &quot;9&quot; &#123;                    if iStr.count &gt;= 9 &amp;&amp; (Int(iStr)! &gt; Int(INT32_MAX) / 10 || (Int(iStr)! == Int(INT32_MAX) / 10 &amp;&amp; (sign &gt; 0 ? c &gt; &quot;7&quot; : c &gt; &quot;8&quot;))) &#123;                        return sign &gt; 0 ? Int(INT32_MAX) : -Int(INT32_MAX) - 1                    &#125;                    iStr.append(c)                &#125; else &#123;                    break                &#125;            &#125;        &#125;        return sign * (Int(iStr) ?? 0)    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0008/"},{"title":"0009. Palindrome Number","date":"2024-02-02T11:48:50.505Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nDetermine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.\nExample 1:\n\nInput: 121\nOutput: true\n\nExample 2:\n\nInput: -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\nExample 3:\n\nInput: 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n\nFollow up:\nCoud you solve it without converting the integer to a string?\nA\n12345678910111213class Solution &#123;    func isPalindrome(_ x: Int) -&gt; Bool &#123;        if x &lt; 0 || x != 0 &amp;&amp; x % 10 == 0 &#123;            return false        &#125;        var palindrome = 0, y = x        while palindrome &lt; y &#123;            palindrome = y % 10 + palindrome * 10            y /= 10        &#125;        return y == palindrome || y == palindrome / 10    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0009-en/"},{"title":"0009. 回文数","date":"2024-02-02T11:48:50.505Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n示例 1：\n\n**输入：**121\n**输出：**true\n\n示例 2：\n\n输入：-121\n**输出：**false\n**解释：**从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n\n示例 3：\n\n**输入：**10\n**输出：**false\n**解释：**从右向左读, 为 01 。因此它不是一个回文数。\n\n进阶:\n你能不将整数转为字符串来解决这个问题吗？\n题解\n12345678910111213class Solution &#123;    func isPalindrome(_ x: Int) -&gt; Bool &#123;        if x &lt; 0 || x != 0 &amp;&amp; x % 10 == 0 &#123;            return false        &#125;        var palindrome = 0, y = x        while palindrome &lt; y &#123;            palindrome = y % 10 + palindrome * 10            y /= 10        &#125;        return y == palindrome || y == palindrome / 10    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0009/"},{"title":"0010. Regular Expression Matching","date":"2024-02-02T11:48:50.506Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nGiven an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.\n\n‘.’ Matches any single character.\n‘*’ Matches zero or more of the preceding element.\nThe matching should cover the entire input string (not partial).\n\nNote:\n\ns could be empty and contains only lowercase letters a-z.\np could be empty and contains only lowercase letters a-z, and characters like . or *.\n\nExample 1:\n\nInput:\ns = “aa”\np = “a”\nOutput: false\nExplanation: “a” does not match the entire string “aa”.\n\nExample 2:\n\nInput:\ns = “aa”\np = “a*”\nOutput: true\nExplanation: ‘*’ means zero or more of the precedeng element, ‘a’. Therefore, by repeating ‘a’ once, it becomes “aa”.\n\nExample 3:\n\nInput:\ns = “ab”\np = “.*”\nOutput: true\nExplanation: “.*” means “zero or more (*) of any character (.)”.\n\nExample 4:\n\nInput:\ns = “aab”\np = “cab”\nOutput: true\nExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches “aab”.\n\nExample 5:\n\nInput:\ns = “mississippi”\np = “mis*is*p*.”\nOutput: false\n\nA\n1234567891011121314class Solution &#123;    func isMatch(_ s: String, _ p: String) -&gt; Bool &#123;        if p.isEmpty &#123;            return s.isEmpty        &#125;        let sArr = Array(s), pArr = Array(p)        let isFirstMatch : Bool = (!s.isEmpty) &amp;&amp; (pArr[0] == sArr[0] || pArr[0] == &quot;.&quot;)        if (pArr.count &gt;= 2 &amp;&amp; pArr[1] == &quot;*&quot;) &#123;            return isFirstMatch &amp;&amp; isMatch(String(s.suffix(s.count - 1)), p) || isMatch(s, String(p.suffix(p.count - 2)))        &#125; else &#123;            return isFirstMatch &amp;&amp; isMatch(String(s.suffix(s.count - 1)), String(p.suffix(p.count - 1)))        &#125;    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0010-en/"},{"title":"0010. 正则表达式匹配","date":"2024-02-02T11:48:50.506Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。\n\n‘.’ 匹配任意单个字符\n‘*’ 匹配零个或多个前面的那一个元素\n所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。\n\n说明：\n\ns 可能为空，且只包含从 a-z 的小写字母。\np 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。\n\n示例 1：\n\n输入：\ns = “aa”\np = “a”\n**输出：**false\n解释：“a” 无法匹配 “aa” 整个字符串。\n\n示例 2：\n\n输入：\ns = “aa”\np = “a*”\n**输出：**true\n解释： 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。\n\n示例 3：\n\n输入：\ns = “ab”\np = “.*”\n**输出：**true\n解释：“.*” 表示可匹配零个或多个（‘*’）任意字符（‘.’）。\n\n示例 4：\n\n输入：\ns = “aab”\np = “cab”\n**输出：**true\n**解释：**因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。\n\n示例 5：\n\n输入：\ns = “mississippi”\np = “mis*is*p*.”\n**输出：**false\n\n题解\n1234567891011121314class Solution &#123;    func isMatch(_ s: String, _ p: String) -&gt; Bool &#123;        if p.isEmpty &#123;            return s.isEmpty        &#125;        let sArr = Array(s), pArr = Array(p)        let isFirstMatch : Bool = (!s.isEmpty) &amp;&amp; (pArr[0] == sArr[0] || pArr[0] == &quot;.&quot;)        if (pArr.count &gt;= 2 &amp;&amp; pArr[1] == &quot;*&quot;) &#123;            return isFirstMatch &amp;&amp; isMatch(String(s.suffix(s.count - 1)), p) || isMatch(s, String(p.suffix(p.count - 2)))        &#125; else &#123;            return isFirstMatch &amp;&amp; isMatch(String(s.suffix(s.count - 1)), String(p.suffix(p.count - 1)))        &#125;    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0010/"},{"title":"0011. Container With Most Water","date":"2024-02-02T11:48:50.507Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nGiven n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\nNote: You may not slant the container and n is at least 2.\n\nThe above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\nExample:\n\nInput: [1,8,6,2,5,4,8,3,7]\nOutput: 49\n\nA\n1234567891011121314class Solution &#123;    func maxArea(_ height: [Int]) -&gt; Int &#123;        var i = 0, j = height.count - 1, area = 0        while i &lt; j &#123;            area = max(area, min(height[i], height[j]) * (j - i))            if height[i] &lt; height[j] &#123;                i += 1            &#125; else &#123;                j -= 1            &#125;        &#125;        return area    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0011-en/"},{"title":"0011. 盛最多水的容器","date":"2024-02-02T11:48:50.508Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n**说明：**你不能倾斜容器，且 n 的值至少为 2。\n\n图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n示例：\n\n输入： [1,8,6,2,5,4,8,3,7]\n输出： 49\n\n题解\n1234567891011121314class Solution &#123;    func maxArea(_ height: [Int]) -&gt; Int &#123;        var i = 0, j = height.count - 1, area = 0        while i &lt; j &#123;            area = max(area, min(height[i], height[j]) * (j - i))            if height[i] &lt; height[j] &#123;                i += 1            &#125; else &#123;                j -= 1            &#125;        &#125;        return area    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0011/"},{"title":"0012. 整数转罗马数字","date":"2024-02-02T11:48:50.509Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n罗马数字包含以下七种字符：I, V, X, L, C, D and M.\n123456789字符                数值I                   1V                   5X                   10L                   50C                   100D                   500M                   1000\n例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。\nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。\n示例 1：\n\n输入： 3\n输出： “III”\n\n示例 2：\n\n输入： 4\n输出：“IV”\n\n示例 3：\n\n输入： 9\n输出：“IX”\n\n示例 4：\n\n输入： 58\n输出：“LVIII”\n**解释：**L = 50, V = 5, III = 3.\n\n示例 5：\n\n输入： 1994\n输出：“MCMXCIV”\n**解释：**M = 1000, CM = 900, XC = 90, IV = 4.\n\n题解\n123456789101112131415161718192021class Solution &#123;    func intToRoman(_ num: Int) -&gt; String &#123;        let value = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]        let symbol = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;]        var roman = &quot;&quot;, n = num, i = 0        while n &gt; 0 &#123;            for index in i...value.count - 1 &#123;                let m = value[index]                if n &gt;= m &#123;                    i = index                    let count = n / m                    for _ in 1...count &#123;                        n -= m                        roman.append(symbol[i])                    &#125;                &#125;            &#125;        &#125;        return roman    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0012/"},{"title":"0012. Integer to Roman","date":"2024-02-02T11:48:50.508Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n123456789Symbol              ValueI                   1V                   5X                   10L                   50C                   100D                   500M                   1000\nFor example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9.\nX can be placed before L (50) and C (100) to make 40 and 90.\nC can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.\nExample 1:\n\nInput: 3\nOutput: “III”\n\nExample 2:\n\nInput: 4\nOutput: “IV”\n\nExample 3:\n\nInput: 9\nOutput: “IX”\n\nExample 4:\n\nInput: 58\nOutput: “LVIII”\nExplanation: L = 50, V = 5, III = 3.\n\nExample 5:\n\nInput: 1994\nOutput: “MCMXCIV”\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\nA\n123456789101112131415161718192021class Solution &#123;    func intToRoman(_ num: Int) -&gt; String &#123;        let value = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]        let symbol = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;]        var roman = &quot;&quot;, n = num, i = 0        while n &gt; 0 &#123;            for index in i...value.count - 1 &#123;                let m = value[index]                if n &gt;= m &#123;                    i = index                    let count = n / m                    for _ in 1...count &#123;                        n -= m                        roman.append(symbol[i])                    &#125;                &#125;            &#125;        &#125;        return roman    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0012-en/"},{"title":"0013.  罗马数字转整数","date":"2024-02-02T11:48:50.510Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n罗马数字包含以下七种字符：I, V, X, L, C, D and M.\n123456789字符                数值I                   1V                   5X                   10L                   50C                   100D                   500M                   1000\n例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。\nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n示例 1：\n\n输入： “III”\n输出： 3\n\n示例 2：\n\n输入： “IV”\n输出： 4\n\n示例 3：\n\n输入： “IX”\n输出： 9\n\n示例 4：\n\n输入： “LVIII”\n输出： 58\n解释： L = 50, V= 5, III = 3.\n\n示例 5：\n\n输入： “MCMXCIV”\n输出： 1994\n解释： M = 1000, CM = 900, XC = 90, IV = 4.\n\n题解\n12345678910111213141516171819class Solution &#123;    func romanToInt(_ s: String) -&gt; Int &#123;        let map = [&quot;M&quot;: 1000, &quot;D&quot;: 500, &quot;C&quot;: 100, &quot;L&quot;: 50, &quot;X&quot;: 10, &quot;V&quot;: 5,  &quot;I&quot;: 1]        let special = [&quot;CM&quot;: 900, &quot;CD&quot;: 400, &quot;XC&quot;: 90, &quot;XL&quot;: 40, &quot;IX&quot;: 9, &quot;IV&quot;: 4]        var reducedRoman = s, value = 0        for sp in special &#123;            if reducedRoman.contains(sp.key) &#123;                value += sp.value                reducedRoman = reducedRoman.replacingOccurrences(of: sp.key, with: &quot;&quot;)            &#125;        &#125;        for c in reducedRoman &#123;            if map.keys.contains(String(c)) &#123;                value += map[String(c)] ?? 0            &#125;        &#125;        return value    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0013/"},{"title":"0013.  Roman to Integer","date":"2024-02-02T11:48:50.510Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n123456789Symbol              ValueI                   1V                   5X                   10L                   50C                   100D                   500M                   1000\nFor example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9.\nX can be placed before L (50) and C (100) to make 40 and 90.\nC can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.\nExample 1:\n\nInput: “III”\nOutput: 3\n\nExample 2:\n\nInput: “IV”\nOutput: 4\n\nExample 3:\n\nInput: “IX”\nOutput: 9\n\nExample 4:\n\nInput: “LVIII”\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\n\nExample 5:\n\nInput: “MCMXCIV”\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\nA\n12345678910111213141516171819class Solution &#123;    func romanToInt(_ s: String) -&gt; Int &#123;        let map = [&quot;M&quot;: 1000, &quot;D&quot;: 500, &quot;C&quot;: 100, &quot;L&quot;: 50, &quot;X&quot;: 10, &quot;V&quot;: 5,  &quot;I&quot;: 1]        let special = [&quot;CM&quot;: 900, &quot;CD&quot;: 400, &quot;XC&quot;: 90, &quot;XL&quot;: 40, &quot;IX&quot;: 9, &quot;IV&quot;: 4]        var reducedRoman = s, value = 0        for sp in special &#123;            if reducedRoman.contains(sp.key) &#123;                value += sp.value                reducedRoman = reducedRoman.replacingOccurrences(of: sp.key, with: &quot;&quot;)            &#125;        &#125;        for c in reducedRoman &#123;            if map.keys.contains(String(c)) &#123;                value += map[String(c)] ?? 0            &#125;        &#125;        return value    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0013-en/"},{"title":"0014. 最长公共前缀","date":"2024-02-02T11:48:50.511Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n编写一个函数来查找字符串数组中的最长公共前缀。\n如果不存在公共前缀，返回空字符串 &quot;&quot;。\n示例 1：\n\n输入： [“flower”,“flow”,“flight”]\n输出： “fl”\n\n示例 2：\n\n输入： [“dog”,“racecar”,“car”]\n输出： “”\n解释： 输入不存在公共前缀。\n\n说明：\n所有输入只包含小写字母 a-z 。\n题解\n123456789101112131415161718192021class Solution &#123;    func longestCommonPrefix(_ strs: [String]) -&gt; String &#123;        if strs.count == 0 &#123;            return &quot;&quot;        &#125;        var p = strs[0]        if strs.count == 1 &#123;            return p        &#125;        for i in 1...strs.count - 1 &#123;            let s = strs[i]            while s.prefix(p.count) != p &#123;                p = String(p.prefix(p.count - 1))                if p.isEmpty &#123;                    return &quot;&quot;                &#125;            &#125;        &#125;        return p    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0014/"},{"title":"0014.  Longest Common Prefix","date":"2024-02-02T11:48:50.511Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nWrite a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string &quot;&quot;.\nExample 1:\n\nInput: [“flower”,“flow”,“flight”]\nOutput: “fl”\n\nExample 2:\n\nInput: [“dog”,“racecar”,“car”]\nOutput: “”\nExplanation: There is no common prefix among the input strings.\n\nNote:\nAll given inputs are in lowercase letters a-z.\nA\n123456789101112131415161718192021class Solution &#123;    func longestCommonPrefix(_ strs: [String]) -&gt; String &#123;        if strs.count == 0 &#123;            return &quot;&quot;        &#125;        var p = strs[0]        if strs.count == 1 &#123;            return p        &#125;        for i in 1...strs.count - 1 &#123;            let s = strs[i]            while s.prefix(p.count) != p &#123;                p = String(p.prefix(p.count - 1))                if p.isEmpty &#123;                    return &quot;&quot;                &#125;            &#125;        &#125;        return p    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0014-en/"},{"title":"0015. 3Sum","date":"2024-02-02T11:48:50.512Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\nNote:\nThe solution set must not contain duplicate triplets.\nExample:\n\nGiven array nums = [-1, 0, 1, 2, -1, -4],\nA solution set is:\n[\n[-1, 0, 1],\n[-1, -1, 2]\n]\n\nA\n1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;    func threeSum(_ nums: [Int]) -&gt; [[Int]] &#123;        var res = [[Int]]()        let sortedNums = nums.sorted()        if nums.count &lt; 3 &#123;            return []        &#125;        for i in 0...nums.count - 1 &#123;            if i &gt; 0, sortedNums[i - 1] == sortedNums[i] &#123;                continue            &#125;            var j = i + 1, k = nums.count - 1            while j &lt; k &#123;                let target = -sortedNums[i]                let sum = sortedNums[j] + sortedNums[k]                if sum &lt; target &#123;                    j += 1                    while j &lt; k, sortedNums[j] == sortedNums[j - 1] &#123;                        j += 1                    &#125;                &#125; else if sum &gt; target &#123;                    k -= 1                    while j &lt; k, sortedNums[k] == sortedNums[k + 1] &#123;                        k -= 1                    &#125;                &#125; else &#123;                    res.append([-target, sortedNums[j], sortedNums[k]])                    j += 1                    k -= 1                    while j &lt; k, sortedNums[j] == sortedNums[j - 1] &#123;                        j += 1                    &#125;                    while j &lt; k, sortedNums[k] == sortedNums[k + 1] &#123;                        k -= 1                    &#125;                &#125;            &#125;        &#125;        return res    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0015-en/"},{"title":"0015. 三数之和","date":"2024-02-02T11:48:50.513Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。\n**注意：**答案中不可以包含重复的三元组。\n示例：\n\n给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n满足要求的三元组集合为：\n[\n[-1, 0, 1],\n[-1, -1, 2]\n]\n\n题解\n1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;    func threeSum(_ nums: [Int]) -&gt; [[Int]] &#123;        var res = [[Int]]()        let sortedNums = nums.sorted()        if nums.count &lt; 3 &#123;            return []        &#125;        for i in 0...nums.count - 1 &#123;            if i &gt; 0, sortedNums[i - 1] == sortedNums[i] &#123;                continue            &#125;            var j = i + 1, k = nums.count - 1            while j &lt; k &#123;                let target = -sortedNums[i]                let sum = sortedNums[j] + sortedNums[k]                if sum &lt; target &#123;                    j += 1                    while j &lt; k, sortedNums[j] == sortedNums[j - 1] &#123;                        j += 1                    &#125;                &#125; else if sum &gt; target &#123;                    k -= 1                    while j &lt; k, sortedNums[k] == sortedNums[k + 1] &#123;                        k -= 1                    &#125;                &#125; else &#123;                    res.append([-target, sortedNums[j], sortedNums[k]])                    j += 1                    k -= 1                    while j &lt; k, sortedNums[j] == sortedNums[j - 1] &#123;                        j += 1                    &#125;                    while j &lt; k, sortedNums[k] == sortedNums[k + 1] &#123;                        k -= 1                    &#125;                &#125;            &#125;        &#125;        return res    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0015/"},{"title":"0016. 3Sum Closest","date":"2024-02-02T11:48:50.513Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\nExample:\n\nGiven array nums = [-1, 2, 1, -4], and target = 1.\nThe sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n\nA\n1234567891011121314151617181920212223242526class Solution &#123;    func threeSumClosest(_ nums: [Int], _ target: Int) -&gt; Int &#123;        let sortedNums = nums.sorted()        var res = sortedNums[0] + sortedNums[1] + sortedNums[2]        for i in 0...sortedNums.count &#123;            if i - 1 &gt;= 0, i &lt; sortedNums.count, sortedNums[i - 1] == sortedNums[i] &#123;                continue            &#125;            var j = i + 1, k = sortedNums.count - 1            while j &lt; k &#123;                let sum = sortedNums[i] + sortedNums[j] + sortedNums[k]                if abs(sum - target) &lt; abs(res - target) &#123;                    res = sum                &#125;                if sum &lt; target &#123;                    j += 1                &#125; else if sum &gt; target &#123;                    k -= 1                &#125; else &#123;                    return res                &#125;            &#125;        &#125;        return res    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0016-en/"},{"title":"0016. 3Sum Closest","date":"2024-02-02T11:48:50.514Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。\n示例：\n\n例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.\n与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).\n\n题解\n1234567891011121314151617181920212223242526class Solution &#123;    func threeSumClosest(_ nums: [Int], _ target: Int) -&gt; Int &#123;        let sortedNums = nums.sorted()        var res = sortedNums[0] + sortedNums[1] + sortedNums[2]        for i in 0...sortedNums.count &#123;            if i - 1 &gt;= 0, i &lt; sortedNums.count, sortedNums[i - 1] == sortedNums[i] &#123;                continue            &#125;            var j = i + 1, k = sortedNums.count - 1            while j &lt; k &#123;                let sum = sortedNums[i] + sortedNums[j] + sortedNums[k]                if abs(sum - target) &lt; abs(res - target) &#123;                    res = sum                &#125;                if sum &lt; target &#123;                    j += 1                &#125; else if sum &gt; target &#123;                    k -= 1                &#125; else &#123;                    return res                &#125;            &#125;        &#125;        return res    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0016/"},{"title":"0017. Letter Combinations of a Phone Number","date":"2024-02-02T11:48:50.515Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.\nA mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\nExample:\n\nInput: “23”\nOutput: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].\n\nNote:\nAlthough the above answer is in lexicographical order, your answer could be in any order you want.\nA\n12345678910111213141516171819202122class Solution &#123;    func letterCombinations(_ digits: String) -&gt; [String] &#123;        let map: [Character : String] = [&quot;2&quot;: &quot;abc&quot;, &quot;3&quot;: &quot;def&quot;, &quot;4&quot;: &quot;ghi&quot;, &quot;5&quot;: &quot;jkl&quot;, &quot;6&quot;: &quot;mno&quot;, &quot;7&quot;: &quot;pqrs&quot;, &quot;8&quot;: &quot;tuv&quot;, &quot;9&quot;:&quot;wxyz&quot;]        var res : [String] = []        for c in digits &#123;            let temp = res            res.removeAll()            for s in map[c]! &#123;                if temp.count == 0 &#123;                    res.append(String(s))                &#125; else &#123;                    for t in temp &#123;                        var a = t                        a.append(s)                        res.append(a)                    &#125;                &#125;            &#125;        &#125;        return res    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0017-en/"},{"title":"0017. 电话号码的字母组合","date":"2024-02-02T11:48:50.515Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n示例:\n\n输入：“23”\n输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].\n\n说明：\n尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。\n题解\n12345678910111213141516171819202122class Solution &#123;    func letterCombinations(_ digits: String) -&gt; [String] &#123;        let map: [Character : String] = [&quot;2&quot;: &quot;abc&quot;, &quot;3&quot;: &quot;def&quot;, &quot;4&quot;: &quot;ghi&quot;, &quot;5&quot;: &quot;jkl&quot;, &quot;6&quot;: &quot;mno&quot;, &quot;7&quot;: &quot;pqrs&quot;, &quot;8&quot;: &quot;tuv&quot;, &quot;9&quot;:&quot;wxyz&quot;]        var res : [String] = []        for c in digits &#123;            let temp = res            res.removeAll()            for s in map[c]! &#123;                if temp.count == 0 &#123;                    res.append(String(s))                &#125; else &#123;                    for t in temp &#123;                        var a = t                        a.append(s)                        res.append(a)                    &#125;                &#125;            &#125;        &#125;        return res    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0017/"},{"title":"0018. 4Sum","date":"2024-02-02T11:48:50.516Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a +b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\nNote:\nThe solution set must not contain duplicate quadruplets.\nExample:\n\nGiven array nums = [1, 0, -1, 0, -2, 2], and target = 0.\nA solution set is:\n[\n[-1,  0, 0, 1],\n[-2, -1, 1, 2],\n[-2,  0, 0, 2]\n]\n\nA\n123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;    func fourSum(_ nums: [Int], _ target: Int) -&gt; [[Int]] &#123;        let sortNums = nums.sorted()        var res : [[Int]] = []        if nums.count &lt; 4 &#123;            return []        &#125;        for i in 0...sortNums.count - 4 &#123;            if i != 0 &amp;&amp; sortNums[i - 1] == sortNums[i] &#123;                continue            &#125;            for j in i + 1...sortNums.count - 2 &#123;                if j != i + 1 &amp;&amp; sortNums[j - 1] == sortNums[j] &#123;                    continue                &#125;                var k = j + 1, l = sortNums.count - 1                while k &lt; l &#123;                    let sum = sortNums[i] + sortNums[j] + sortNums[k] + sortNums[l]                    if sum &lt; target &#123;                        k += 1                        while k &lt; l, sortNums[k] == sortNums[k - 1] &#123;                            k += 1                        &#125;                    &#125; else if sum &gt; target&#123;                        l -= 1                        while k &lt; l, sortNums[l] == sortNums[l + 1] &#123;                            l -= 1                        &#125;                    &#125; else &#123;                        res.append([sortNums[i], sortNums[j], sortNums[k], sortNums[l]])                        k += 1                        l -= 1                        while k &lt; l, sortNums[k] == sortNums[k - 1] &#123;                            k += 1                        &#125;                        while k &lt; l, sortNums[l] == sortNums[l + 1] &#123;                            l -= 1                        &#125;                    &#125;                &#125;            &#125;        &#125;        return res    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0018-en/"},{"title":"0018. 四数之和","date":"2024-02-02T11:48:50.516Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。\n注意：\n答案中不可以包含重复的四元组。\n示例：\n\n给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。\n满足要求的四元组集合为：\n[\n[-1,  0, 0, 1],\n[-2, -1, 1, 2],\n[-2,  0, 0, 2]\n]\n\nA\n123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;    func fourSum(_ nums: [Int], _ target: Int) -&gt; [[Int]] &#123;        let sortNums = nums.sorted()        var res : [[Int]] = []        if nums.count &lt; 4 &#123;            return []        &#125;        for i in 0...sortNums.count - 4 &#123;            if i != 0 &amp;&amp; sortNums[i - 1] == sortNums[i] &#123;                continue            &#125;            for j in i + 1...sortNums.count - 2 &#123;                if j != i + 1 &amp;&amp; sortNums[j - 1] == sortNums[j] &#123;                    continue                &#125;                var k = j + 1, l = sortNums.count - 1                while k &lt; l &#123;                    let sum = sortNums[i] + sortNums[j] + sortNums[k] + sortNums[l]                    if sum &lt; target &#123;                        k += 1                        while k &lt; l, sortNums[k] == sortNums[k - 1] &#123;                            k += 1                        &#125;                    &#125; else if sum &gt; target&#123;                        l -= 1                        while k &lt; l, sortNums[l] == sortNums[l + 1] &#123;                            l -= 1                        &#125;                    &#125; else &#123;                        res.append([sortNums[i], sortNums[j], sortNums[k], sortNums[l]])                        k += 1                        l -= 1                        while k &lt; l, sortNums[k] == sortNums[k - 1] &#123;                            k += 1                        &#125;                        while k &lt; l, sortNums[l] == sortNums[l + 1] &#123;                            l -= 1                        &#125;                    &#125;                &#125;            &#125;        &#125;        return res    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0018/"},{"title":"0019. Remove Nth Node From End of List","date":"2024-02-02T11:48:50.517Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nGiven a linked list, remove the n-th node from the end of list and return its head.\nExample:\n\nGiven linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.\nAfter removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.\n\nNote:\nGiven n will always be valid.\nFollow up:\nCould you do this in one pass?\nA\n12345678910111213141516class Solution &#123;    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -&gt; ListNode? &#123;        let p = ListNode(0)        p.next = head        var q = p, r = p        for _ in 0..&lt;n &#123;            q = q.next!        &#125;        while q.next != nil &#123;            q = q.next!            r = r.next!        &#125;        r.next = r.next?.next        return p.next    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0019-en/"},{"title":"0019. 删除链表的倒数第 N 个节点","date":"2024-02-02T11:48:50.518Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。\n示例：\n\n给定一个链表：1-&gt;2-&gt;3-&gt;4-&gt;5，和 n = 2。\n当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5。\n\n说明：\n给定的 n 保证是有效的。\n进阶：\n你能尝试使用一趟扫描实现吗？\n题解\n12345678910111213141516class Solution &#123;    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -&gt; ListNode? &#123;        let p = ListNode(0)        p.next = head        var q = p, r = p        for _ in 0..&lt;n &#123;            q = q.next!        &#125;        while q.next != nil &#123;            q = q.next!            r = r.next!        &#125;        r.next = r.next?.next        return p.next    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0019/"},{"title":"0020. Valid Parentheses","date":"2024-02-02T11:48:50.518Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nGiven a string containing just the characters '(', ')', '&#123;', '&#125;', '[' and ']', determine if the input string is valid.\nAn input string is valid if:\n\nOpen brackets must be closed by the same type of brackets.\nOpen brackets must be closed in the correct order.\n\nNote that an empty string is also considered valid.\nExample 1:\n\nInput: “()”\nOutput: true\n\nExample 2:\n\nInput: “()[]{}”\nOutput: true\n\nExample 3:\n\nInput: “(]”\nOutput: false\n\nExample 4:\n\nInput: “([)]”\nOutput: false\n\nExample 5:\n\nInput: “{[]}”\nOutput: true\n\nA\n123456789101112131415161718class Solution &#123;    func isValid(_ s: String) -&gt; Bool &#123;        var str : [Character] = []        for c in s &#123;            if str.count == 0 &#123;                str.append(c)                continue            &#125;            let combine = String(str.last!) + String(c)            if combine == &quot;[]&quot; || combine == &quot;&#123;&#125;&quot; || combine == &quot;()&quot; &#123;                str.removeLast()            &#125; else &#123;                str.append(c)            &#125;        &#125;        return str.count == 0    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0020-en/"},{"title":"0020. 有效的括号","date":"2024-02-02T11:48:50.519Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n给定一个只包括 '('，')'，'&#123;'，'&#125;'，'['，']' 的字符串，判断字符串是否有效。\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n\n注意空字符串可被认为是有效字符串。\n示例 1：\n\n输入： “()”\n输出： true\n\n示例 2：\n\n输入： “()[]{}”\n输出： true\n\n示例 3：\n\n输入： “(]”\n输出： false\n\n示例 4：\n\n输入： “([)]”\n输出： false\n\n示例 5：\n\n输入： “{[]}”\n输出： true\n\n题解\n123456789101112131415161718class Solution &#123;    func isValid(_ s: String) -&gt; Bool &#123;        var str : [Character] = []        for c in s &#123;            if str.count == 0 &#123;                str.append(c)                continue            &#125;            let combine = String(str.last!) + String(c)            if combine == &quot;[]&quot; || combine == &quot;&#123;&#125;&quot; || combine == &quot;()&quot; &#123;                str.removeLast()            &#125; else &#123;                str.append(c)            &#125;        &#125;        return str.count == 0    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0020/"},{"title":"0021. Merge Two Sorted Lists","date":"2024-02-02T11:48:50.520Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\nExample:\n\nInput: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4\nOutput: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4\n\nA\n12345678910111213141516171819class Solution &#123;    func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? &#123;        var p = ListNode(-1)        var ll1 = l1, ll2 = l2        let q = p        while ll1 != nil &amp;&amp; ll2 != nil &#123;            if ll1!.val &lt; ll2!.val &#123;                p.next = ll1                ll1 = ll1?.next            &#125; else &#123;                p.next = ll2                ll2 = ll2?.next            &#125;            p = p.next!        &#125;        p.next = ll1 == nil ? ll2 : ll1        return q.next    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0021-en/"},{"title":"0021. 合并两个有序链表","date":"2024-02-02T11:48:50.520Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n示例：\n\n输入： 1-&gt;2-&gt;4, 1-&gt;3-&gt;4\n输出： 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4\n\n题解\n12345678910111213141516171819class Solution &#123;    func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? &#123;        var p = ListNode(-1)        var ll1 = l1, ll2 = l2        let q = p        while ll1 != nil &amp;&amp; ll2 != nil &#123;            if ll1!.val &lt; ll2!.val &#123;                p.next = ll1                ll1 = ll1?.next            &#125; else &#123;                p.next = ll2                ll2 = ll2?.next            &#125;            p = p.next!        &#125;        p.next = ll1 == nil ? ll2 : ll1        return q.next    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0021/"},{"title":"0022. Generate Parentheses","date":"2024-02-02T11:48:50.521Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\nFor example, given n = 3, a solution set is:\n\n[\n“((()))”,\n“(()())”,\n“(())()”,\n“()(())”,\n“()()()”\n]\n\nA\n1234567891011121314151617class Solution &#123;    func generateParenthesis(_ n: Int) -&gt; [String] &#123;        var res: [String] = []        if n == 0 &#123;            res.append(&quot;&quot;)        &#125; else &#123;            for i in 0...n-1 &#123;                for left in generateParenthesis(i) &#123;                    for right in generateParenthesis(n-i-1) &#123;                        res.append(&quot;(&quot; + left + &quot;)&quot; + right)                    &#125;                &#125;            &#125;        &#125;        return res    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0022-en/"},{"title":"0022. 括号生成","date":"2024-02-02T11:48:50.522Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。\n例如，给出 n = 3，生成结果为：\n\n[\n“((()))”,\n“(()())”,\n“(())()”,\n“()(())”,\n“()()()”\n]\n\n题解\n1234567891011121314151617class Solution &#123;    func generateParenthesis(_ n: Int) -&gt; [String] &#123;        var res: [String] = []        if n == 0 &#123;            res.append(&quot;&quot;)        &#125; else &#123;            for i in 0...n-1 &#123;                for left in generateParenthesis(i) &#123;                    for right in generateParenthesis(n-i-1) &#123;                        res.append(&quot;(&quot; + left + &quot;)&quot; + right)                    &#125;                &#125;            &#125;        &#125;        return res    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0022/"},{"title":"0023. Merge k Sorted Lists","date":"2024-02-02T11:48:50.522Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\nExample:\n\nInput:\n[\n1-&gt;4-&gt;5,\n1-&gt;3-&gt;4,\n2-&gt;6\n]\nOutput: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n\nA\n1234567891011121314151617181920class Solution &#123;    func mergeKLists(_ lists: [ListNode?]) -&gt; ListNode? &#123;        var vals = [Int]()        for list in lists &#123;            var p = list            while p != nil &#123;                vals.append(p!.val)                p = p!.next            &#125;        &#125;        vals.sort()        var q : ListNode = ListNode(Int.min)        let res = q        for val in vals &#123;            q.next = ListNode(val)            q = q.next!        &#125;        return res.next    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0023-en/"},{"title":"0024. Swap Nodes in Pairs","date":"2024-02-02T11:48:50.523Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nGiven a linked list, swap every two adjacent nodes and return its head.\nYou may not modify the values in the list’s nodes, only nodes itself may be changed.\nExample:\n\nGiven 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.\n\nA\n1234567891011class Solution &#123;    func swapPairs(_ head: ListNode?) -&gt; ListNode? &#123;        if head == nil || head?.next == nil &#123;            return head        &#125;        let next = head?.next        head?.next = swapPairs(next?.next)        next?.next = head        return next    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0024-en/"},{"title":"0023. 合并K个排序链表","date":"2024-02-02T11:48:50.523Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。\n示例：\n\n输入：\n[\n1-&gt;4-&gt;5,\n1-&gt;3-&gt;4,\n2-&gt;6\n]\n输出： 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n\n题解\n1234567891011121314151617181920class Solution &#123;    func mergeKLists(_ lists: [ListNode?]) -&gt; ListNode? &#123;        var vals = [Int]()        for list in lists &#123;            var p = list            while p != nil &#123;                vals.append(p!.val)                p = p!.next            &#125;        &#125;        vals.sort()        var q : ListNode = ListNode(Int.min)        let res = q        for val in vals &#123;            q.next = ListNode(val)            q = q.next!        &#125;        return res.next    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0023/"},{"title":"0024. 两两交换链表的节点","date":"2024-02-02T11:48:50.524Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n示例：\n\n给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.\n\n题解\n1234567891011class Solution &#123;    func swapPairs(_ head: ListNode?) -&gt; ListNode? &#123;        if head == nil || head?.next == nil &#123;            return head        &#125;        let next = head?.next        head?.next = swapPairs(next?.next)        next?.next = head        return next    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0024/"},{"title":"0026. Remove Duplicates from Sorted Array","date":"2024-02-02T11:48:50.525Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nExample 1:\n\nGiven nums = [1,1,2],\nYour function should return length = 2, with the first two elements of nums being 1 and 2 respectively.\nIt doesn’t matter what you leave beyond the returned length.\n\nExample 2:\n\nGiven nums = [0,0,1,1,1,2,2,3,3,4],\nYour function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.\nIt doesn’t matter what values are set beyond the returned length.\n\nClarification:\nConfused why the returned value is an integer but your answer is an array?\nNote that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.\nInternally you can think of this:\n12345678// **nums** is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to **nums** in your function would be known by the caller.// using the length returned by your function, it prints the first **len** elements.for (int i = 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;\nA\n123456789101112131415class Solution &#123;    func removeDuplicates(_ nums: inout [Int]) -&gt; Int &#123;        if nums.count == 0 &#123;            return 0        &#125;        var i = 0        for num in nums &#123;            if nums[i] != num &#123;                i += 1                nums[i] = num            &#125;        &#125;        return i + 1    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0026-en/"},{"title":"0026. 删除排序数组中的重复项","date":"2024-02-02T11:48:50.525Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n示例 1：\n\n给定数组 nums = [1,1,2],\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。\n你不需要考虑数组中超出新长度后面的元素。\n\n示例 2：\n\n给定 nums = [0,0,1,1,1,2,2,3,3,4],\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n你不需要考虑数组中超出新长度后面的元素。\n\n说明：\n为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;\n题解\n123456789101112131415class Solution &#123;    func removeDuplicates(_ nums: inout [Int]) -&gt; Int &#123;        if nums.count == 0 &#123;            return 0        &#125;        var i = 0        for num in nums &#123;            if nums[i] != num &#123;                i += 1                nums[i] = num            &#125;        &#125;        return i + 1    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0026/"},{"title":"0027. Remove Element","date":"2024-02-02T11:48:50.526Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nGiven an array nums and a value val, remove all instances of that value in-place and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nThe order of elements can be changed. It doesn’t matter what you leave beyond the new length.\nExample 1：\n\nGiven nums = [3,2,2,3], val = 3,\nYour function should return length = 2, with the first two elements of nums being 2.\nIt doesn’t matter what you leave beyond the returned length.\n\nExample 2:\n\nGiven nums = [0,1,2,2,3,0,4,2], val = 2,\nYour function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.\nNote that the order of those five elements can be arbitrary.\nIt doesn’t matter what values are set beyond the returned length.\n\nClarification:\nConfused why the returned value is an integer but your answer is an array?\nNote that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.\nInternally you can think of this:\n12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeElement(nums, val);// any modification to **nums** in your function would be known by the caller.// using the length returned by your function, it prints the first **len** elements.for (int i = 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;\nA\n123456789101112class Solution &#123;    func removeElement(_ nums: inout [Int], _ val: Int) -&gt; Int &#123;        var i = 0        for num in nums &#123;            if num != val &#123;                nums[i] = num                i += 1            &#125;        &#125;        return i    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0027-en/"},{"title":"0027. 移除元素","date":"2024-02-02T11:48:50.527Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n给定一个数组 nums 和一个值 val ，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n示例 1：\n\n给定 nums = [3,2,2,3], val = 3,\n函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。\n你不需要考虑数组中超出新长度后面的元素。\n\n示例 2：\n\n给定 nums = [0,1,2,2,3,0,4,2], val = 2,\n函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n注意这五个元素可为任意顺序。\n你不需要考虑数组中超出新长度后面的元素。\n\n说明：\n为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以**“引用”**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中**该长度范围内**的所有元素。for (int i = 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;\n题解\n123456789101112class Solution &#123;    func removeElement(_ nums: inout [Int], _ val: Int) -&gt; Int &#123;        var i = 0        for num in nums &#123;            if num != val &#123;                nums[i] = num                i += 1            &#125;        &#125;        return i    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0027/"},{"title":"0028. Implement strStr()","date":"2024-02-02T11:48:50.527Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nImplement strStr().\nReturn the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\nExample 1:\n\nInput: haystack = “hello”, needle = “ll”\nOutput: 2\n\nExample 2:\n\nInput: haystack = “aaaaa”, needle = “bba”\nOutput: -1\n\nClarification:\nWhat should we return when needle is an empty string? This is a great question to ask during an interview.\nFor the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf().\nA\n123456789101112131415161718192021222324class Solution &#123;    func strStr(_ haystack: String, _ needle: String) -&gt; Int &#123;        let nCount = needle.count        if nCount == 0 &#123;            return 0        &#125;        let haystackArr = Array(haystack), hCount = haystack.count        let needleArr = Array(needle)        var i = 0, j = 0        while j &lt; nCount &amp;&amp; i + j &lt; hCount &#123;            if haystackArr[i + j] == needleArr[j] &#123;                if  j == nCount - 1 &#123;                    return i                &#125; else &#123;                    j += 1                &#125;            &#125; else &#123;                j = 0                i += 1            &#125;        &#125;        return -1    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0028-en/"},{"title":"0028. 实现 strStr()","date":"2024-02-02T11:48:50.528Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n实现 strStr() 函数。\n给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。\n示例 1：\n\n输入： haystack = “hello”, needle = “ll”\n输出： 2\n\n示例 2：\n\n输入： haystack = “aaaaa”, needle = “bba”\n输出： -1\n\n说明：\n当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。\n对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。\n题解\n123456789101112131415161718192021222324class Solution &#123;    func strStr(_ haystack: String, _ needle: String) -&gt; Int &#123;        let nCount = needle.count        if nCount == 0 &#123;            return 0        &#125;        let haystackArr = Array(haystack), hCount = haystack.count        let needleArr = Array(needle)        var i = 0, j = 0        while j &lt; nCount &amp;&amp; i + j &lt; hCount &#123;            if haystackArr[i + j] == needleArr[j] &#123;                if  j == nCount - 1 &#123;                    return i                &#125; else &#123;                    j += 1                &#125;            &#125; else &#123;                j = 0                i += 1            &#125;        &#125;        return -1    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0028/"},{"title":"0029. 两数相除","date":"2024-02-02T11:48:50.529Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。\n返回被除数 dividend 除以除数 divisor 得到的商。\n示例 1：\n\n输入： dividend = 10, divisor = 3\n输出： 3\n\n示例 2：\n\n输入： dividend = 7, divisor = -3\n输出： -2\n\n说明：\n\n被除数和除数均为 32 位有符号整数。\n除数不为 0。\n假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。\n\n题解\n12345678910111213141516171819202122class Solution &#123;    func divide(_ dividend: Int, _ divisor: Int) -&gt; Int &#123;        let INT_MAX = Int(INT32_MAX)        if divisor == 0 &#123;            return INT_MAX        &#125;        let flag = (dividend &gt; 0) == (divisor &gt; 0)        var d1 = abs(dividend), d2 = abs(divisor), count = 0        while d1 &gt;= d2 &#123;            var shift = 0            while d1 &gt;= d2 &lt;&lt; shift &#123;                shift += 1            &#125;            d1 -= d2 &lt;&lt; (shift - 1)            count += 1 &lt;&lt; (shift - 1)        &#125;        if count &gt; INT_MAX &amp;&amp; flag &#123;            return INT_MAX        &#125;        return flag ? count : -count    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0029/"},{"title":"0029. Divide Two Integers","date":"2024-02-02T11:48:50.529Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nGiven two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.\nReturn the quotient after dividing dividend by divisor.\nThe integer division should truncate toward zero.\nExample 1:\n\nInput: dividend = 10, divisor = 3\nOutput: 3\n\nExample 2:\n\nInput: dividend = 7, divisor = -3\nOutput: -2\n\nNote:\n\nBoth dividend and divisor will be 32-bit signed integers.\nThe divisor will never be 0.\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 2^31 − 1 when the division result overflows.\n\nA\n12345678910111213141516171819202122class Solution &#123;    func divide(_ dividend: Int, _ divisor: Int) -&gt; Int &#123;        let INT_MAX = Int(INT32_MAX)        if divisor == 0 &#123;            return INT_MAX        &#125;        let flag = (dividend &gt; 0) == (divisor &gt; 0)        var d1 = abs(dividend), d2 = abs(divisor), count = 0        while d1 &gt;= d2 &#123;            var shift = 0            while d1 &gt;= d2 &lt;&lt; shift &#123;                shift += 1            &#125;            d1 -= d2 &lt;&lt; (shift - 1)            count += 1 &lt;&lt; (shift - 1)        &#125;        if count &gt; INT_MAX &amp;&amp; flag &#123;            return INT_MAX        &#125;        return flag ? count : -count    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0029-en/"},{"title":"0031. Next Permutation","date":"2024-02-02T11:48:50.530Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\nThe replacement must be in-place and use only constant extra memory.\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n1,2,3 → 1,3,2\n3,2,1 → 1,2,3\n1,1,5 → 1,5,1\nA\n12345678910111213141516171819202122232425262728293031323334class Solution &#123;    func nextPermutation(_ nums: inout [Int]) &#123;        let count = nums.count        if count &lt; 2 &#123;            return        &#125;        var i : Int = count - 1        while i &gt; 0 &#123;            if nums[i - 1] &lt; nums[i] &#123;                var j = count - 1                while j &gt;= i &#123;                    if nums[i-1] &lt; nums[j] &#123;                        swap(&amp;nums, i-1, j)                        nums = nums[0...i-1] + nums[i...].reversed()                        return                    &#125;                    j -= 1                &#125;            &#125;            i -= 1            if i == 0 &#123;                nums.reverse()                return            &#125;        &#125;    &#125;    func swap(_ nums: inout [Int], _ i: Int, _ j: Int) &#123;        let temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0031-en/"},{"title":"0031. 下一个排列","date":"2024-02-02T11:48:50.530Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。\n如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n必须原地修改，只允许使用额外常数空间。\n以下是一些例子，输入位于左侧列，其相应输出位于右侧列。\n1,2,3 → 1,3,2\n3,2,1 → 1,2,3\n1,1,5 → 1,5,1\n题解\n123456789101112131415161718192021222324252627282930313233343536373839404142/** 算法描述： *  1. 从后向前查找第一个相邻的升序元素对(i-1, i)，满足 nums[i-1] &lt; nums[i]，此时 [i, end) 必然是降序的； *  2. 在 [i, end) 范围内从后向前查找第一个满足 A[i-1] &lt; A[k] 的 k *  3. 交换 A[i-1] 和 A[k] *  4. 逆置 [i, end)，使其升序 *  5. 如果步骤 1 中找不到符合的元素对(i-1, i)，说明[begin, end) 为降序，直接跳到步骤 4 */class Solution &#123;    func nextPermutation(_ nums: inout [Int]) &#123;        let count = nums.count        if count &lt; 2 &#123;            return        &#125;        var i : Int = count - 1        while i &gt; 0 &#123;            if nums[i - 1] &lt; nums[i] &#123;                var j = count - 1                while j &gt;= i &#123;                    if nums[i-1] &lt; nums[j] &#123;                        swap(&amp;nums, i-1, j)                        nums = nums[0...i-1] + nums[i...].reversed()                        return                    &#125;                    j -= 1                &#125;            &#125;            i -= 1            if i == 0 &#123;                nums.reverse()                return            &#125;        &#125;    &#125;        func swap(_ nums: inout [Int], _ i: Int, _ j: Int) &#123;        let temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0031/"},{"title":"0035. Search Insert Position","date":"2024-02-02T11:48:50.531Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou may assume no duplicates in the array.\nExample 1:\n\nInput: [1,3,5,6], 5\nOutput: 2\n\nExample 2:\n\nInput: [1,3,5,6], 2\nOutput: 1\n\nExample 3:\n\nInput: [1,3,5,6], 7\nOutput: 4\n\nExample 4:\n\nInput: [1,3,5,6], 0\nOutput: 0\n\nA\n12345678910class Solution &#123;    func searchInsert(_ nums: [Int], _ target: Int) -&gt; Int &#123;        for (i, n) in nums.enumerated() &#123;            if n &gt;= target &#123;                return i            &#125;        &#125;        return nums.count    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0035-en/"},{"title":"0035. 搜索插入位置","date":"2024-02-02T11:48:50.532Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n你可以假设数组中无重复元素。\n示例 1：\n\n输入： [1,3,5,6], 5\n输出： 2\n\n示例 2：\n\n输入： [1,3,5,6], 2\n输出： 1\n\n示例 3：\n\n输入： [1,3,5,6], 7\n输出： 4\n\n示例 4：\n\n输入： [1,3,5,6], 0\n输出： 0\n\n题解\n12345678910class Solution &#123;    func searchInsert(_ nums: [Int], _ target: Int) -&gt; Int &#123;        for (i, n) in nums.enumerated() &#123;            if n &gt;= target &#123;                return i            &#125;        &#125;        return nums.count    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0035/"},{"title":"0050. Pow(x, n)","date":"2024-02-02T11:48:50.532Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nImplement pow(x, n), which calculates x raised to the power n (x^n).\nExample 1:\n\nInput: 2.00000, 10\nOutput: 1024.00000\n\nExample 2:\n\nInput: 2.10000, 3\nOutput: 9.26100\n\nExample 3:\n\nInput: 2.00000, -2\nOutput: 0.25000\nExplanation: 2^(-2) = 1 / (2^2) = 1/4 = 0.25\n\nNote:\n\n-100.0 &lt; x &lt; 100.0\nn is a 32-bit signed integer, within the range [−2^31, 2^31 − 1]\n\nA\n123456789101112131415class Solution &#123;    func myPow(_ x: Double, _ n: Int) -&gt; Double &#123;        if n == 0 &#123;            return 1        &#125;        if n &lt; 0 &#123;            return 1 / myPow(x, -n)        &#125;        let m = myPow(x, n / 2)        if n &amp; 1 == 0 &#123;            return m * m        &#125;        return m * m * x    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0050-en/"},{"title":"0050. Pow(x, n)","date":"2024-02-02T11:48:50.533Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n实现 pow(x, n) ，即计算 x 的 n 次幂函数。\n示例 1：\n\n输入： 2.00000, 10\n输出： 1024.00000\n\n示例 2：\n\n输入： 2.10000, 3\n输出： 9.26100\n\n示例 3：\n\n输入： 2.00000, -2\n输出： 0.25000\n解释： 2^(-2) = 1 / (2^2) = 1/4 = 0.25\n\n说明：\n\n-100.0 &lt; x &lt; 100.0\nn 是 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1] 。\n\n题解\n123456789101112131415class Solution &#123;    func myPow(_ x: Double, _ n: Int) -&gt; Double &#123;        if n == 0 &#123;            return 1        &#125;        if n &lt; 0 &#123;            return 1 / myPow(x, -n)        &#125;        let m = myPow(x, n / 2)        if n &amp; 1 == 0 &#123;            return m * m        &#125;        return m * m * x    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0050/"},{"title":"0031. Gas Station","date":"2024-02-02T11:48:50.534Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English ｜ 简体中文\nQ\nThere are N gas stations along a circular route, where the amount of gas at station i is gas[i].\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.\nReturn the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.\nNote:\n\nIf there exists a solution, it is guaranteed to be unique.\nBoth input arrays are non-empty and have the same length.\nEach element in the input arrays is a non-negative integer.\n\nExample 1:\nInput:\ngas  = [1,2,3,4,5]\ncost = [3,4,5,1,2]\nOutput: 3\nExplanation:\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\nExample 2:\nInput:\ngas  = [2,3,4]\ncost = [3,4,3]\nOutput: -1\nExplanation:\nYou can’t start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet’s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can’t travel around the circuit once no matter where you start.\nA\n1234567891011121314class Solution &#123;    func canCompleteCircuit(_ gas: [Int], _ cost: [Int]) -&gt; Int &#123;        var total_tank = 0, current_tank = 0, index = 0        for i in 0..&lt;gas.count &#123;            total_tank += gas[i] - cost[i]            current_tank += gas[i] - cost[i]            if current_tank &lt; 0 &#123;                index = i + 1                current_tank = 0            &#125;        &#125;        return total_tank &gt;= 0 ? index : -1    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0134-en/"},{"title":"0134. 加油站","date":"2024-02-02T11:48:50.534Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2022-09-02T10:52:57.000Z","content":"English｜ 简体中文\n题目描述\n在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。\n你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。\n如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。\n说明：\n\n如果题目有解，该答案即为唯一答案。\n输入数组均为非空数组，且长度相同。\n输入数组中的元素均为非负数。\n\n示例 1:\n输入:\ngas  = [1,2,3,4,5]\ncost = [3,4,5,1,2]\n输出: 3\n解释:\n从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油\n开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油\n开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油\n开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油\n开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油\n开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。\n因此，3 可为起始索引。\n示例 2:\n输入:\ngas  = [2,3,4]\ncost = [3,4,3]\n输出: -1\n解释:\n你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。\n我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油\n开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油\n开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油\n你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。\n因此，无论怎样，你都不可能绕环路行驶一周。\n题解\n1234567891011121314class Solution &#123;    func canCompleteCircuit(_ gas: [Int], _ cost: [Int]) -&gt; Int &#123;        var total_tank = 0, current_tank = 0, index = 0        for i in 0..&lt;gas.count &#123;            total_tank += gas[i] - cost[i]            current_tank += gas[i] - cost[i]            if current_tank &lt; 0 &#123;                index = i + 1                current_tank = 0            &#125;        &#125;        return total_tank &gt;= 0 ? index : -1    &#125;&#125;\n","plink":"https://CHONG589.github.io/leetcode/0134/"},{"title":"LeetCode Solutions（Swift）","date":"2019-06-29T16:00:00.000Z","date_formatted":{"ll":"2019年6月30日","L":"2019/06/30","MM-DD":"06-30"},"updated":"2022-09-02T10:52:57.000Z","content":"简体中文 ｜ English ｜ \nEasy\n\n0001. Two Sum\n0007. Reverse Integer\n0009. Palindrome Number\n0013. Roman to Integer\n0014. Longest Common Prefix\n0020. Valid Parentheses\n0021. Merge Two Sorted Lists\n0026. Remove Duplicates from Sorted Array\n0027. Remove Element\n0028. Implement strStr()\n0035. Search Insert Position\n\nMedium\n\n0002. Add Two Numbers\n0003. Longest Substring Without Repeating Characters\n0005. Longest Palindromic Substring \n0006. ZigZag Conversion\n0008. String to Integer (atoi)\n0011. Container With Most Water\n0012. Integer to Roman\n0015. 3Sum\n0016. 3Sum Closest\n0017. Letter Combinations of a Phone Number\n0018. 4Sum\n0019. Remove Nth Node From End of List\n0022. Generate Parentheses\n0024. Swap Nodes in Pairs\n0029. Divide Two Integers\n0031. Next Permutation\n0050. Pow(x, n)\n0134. Gas Station\n\nHard\n\n0004. Median of Two Sorted Arrays\n0010. Regular Expression Matching\n0023. Merge k Sorted Lists\n\n","plink":"https://CHONG589.github.io/leetcode/index-en/"},{"title":"LeetCode 刷题记录（Swift）","date":"2019-06-29T16:00:00.000Z","date_formatted":{"ll":"2019年6月30日","L":"2019/06/30","MM-DD":"06-30"},"updated":"2022-09-02T10:52:57.000Z","content":"简体中文 ｜ English ｜ \n数学\n\n0002. 两数相加 - 中等\n0007. 整数反转 - 简单\n0008. 字符串转换整数（atoi） - 中等\n0009. 回文数 - 简单\n0012. 整数转罗马数字 - 中等\n0013. 罗马数字转整数 - 简单\n0029. 两数相除 - 中等\n0050. Pow(x, n) - 中等\n\n字符串\n\n0003. 无重复字符的最长字串 - 中等\n0005. 最长回文子串 - 中等\n0006. Z 字形变换 - 中等\n0008. 字符串转换整数（atoi） - 中等\n0010. 正则表达式匹配 - 困难\n0012. 整数转罗马数字 - 中等\n0013. 罗马数字转整数 - 简单\n0014. 最长公共前缀 - 简单\n0017. 电话号码的字母组合 - 中等\n0020. 有效的括号 - 简单\n0022. 括号生成 - 中等\n0028. 实现 strStr() - 简单\n\n数组\n\n0001. 两数之和 - 简单\n0004. 寻找两个有序数组的中位数 - 困难\n0011. 盛最多水的容器 - 中等\n0015. 三数之和 - 中等\n0016. 最接近的三数之和 - 中等\n0018. 四数之和 - 中等\n0026. 删除排序数组中的重复项 - 简单\n0027. 移除元素 - 简单\n0031. 下一个排列 - 中等\n0035. 搜索插入位置 - 简单\n\n双指针\n\n0003. 无重复字符的最长字串 - 中等\n0011. 盛最多水的容器 - 中等\n0015. 三数之和 - 中等\n0016. 最接近的三数之和 - 中等\n0018. 四数之和 - 中等\n0019. 删除链表的倒数第N个节点 - 中等\n0026. 删除排序数组中的重复项 - 简单\n0027. 移除元素 - 简单\n0028. 实现 strStr() - 简单\n\n链表\n\n0002. 两数相加 - 中等\n0019. 删除链表的倒数第N个节点 - 中等\n0021. 合并两个有序链表 - 简单\n0023. 合并K个排序链表 - 困难\n0024. 两两交换链表中的节点 - 中等\n\n哈希表\n\n0001. 两数之和 - 简单\n0003. 无重复字符的最长字串 - 中等\n0018. 四数之和 - 中等\n\n二分查找\n\n0004. 寻找两个有序数组的中位数 - 困难\n0029. 两数相除 - 中等\n0035. 搜索插入位置 - 简单\n0050. Pow(x, n) - 中等\n\n分治算法\n\n0004. 寻找两个有序数组的中位数 - 困难\n0023. 合并K个排序链表 - 困难\n\n回溯算法\n\n0010. 正则表达式匹配 - 困难\n0017. 电话号码的字母组合 - 中等\n0022. 括号生成 - 中等\n\n贪心算法\n\n0134. 加油站 - 中等\n\n动态规划\n\n0005. 最长回文子串 - 中等\n0010. 正则表达式匹配 - 困难\n\n","plink":"https://CHONG589.github.io/leetcode/"}]