{"title":"static","date":"2024-01-30T07:31:31.000Z","date_formatted":{"ll":"2024年1月30日","L":"2024/01/30","MM-DD":"01-30"},"author":"Chong","thumbnail":"2024/static用法/./thumb.png","link":"2024/static用法","comments":true,"updated":"2025-04-10T08:01:19.674Z","content":"<span id=\"more\"></span>\n<p>当与不同类型一起使用时，static 关键字具有不同的含义。<strong>static 编译时分配内存</strong>。</p>\n<h2 id=\"函数中的静态变量\">函数中的静态变量<a title=\"#函数中的静态变量\" href=\"#函数中的静态变量\"></a></h2>\n<p>当变量声明为 static 时，空间 <strong>将在程序的生命周期内分配</strong>。即使多次调用该函数，静态变量的空间也 <strong>只分配一次</strong>，前一次调用中的变量值通过下一次函数调用传递。这对于在 C / C ++ 或需要存储先前函数状态的任何其他应用程序非常有用。</p>\n<h2 id=\"类中的静态成员变量\">类中的静态成员变量<a title=\"#类中的静态成员变量\" href=\"#类中的静态成员变量\"></a></h2>\n<p>当我们在头文件中声明一个静态成员时，只是在告知编译器存在这样一个静态成员变量，但实际上并没有定义它（从某种意义上说，这与前置声明非常相似）。因为静态成员变量不属于类实例（它们的处理方式与全局变量类似，在程序启动时初始化），所以必须在类外部的全局作用域中显式定义静态成员。也是因为这个原因，<strong>静态变量不能使用构造函数初始化，使用类外的类名和范围解析运算符显式初始化</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span> </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Apple</span> &#123; </span><br><span class=\"line\"><span class=\"keyword\">public</span>: </span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">int</span> i; </span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">Apple</span>() &#123; </span><br><span class=\"line\">\t\t<span class=\"comment\">// Do nothing </span></span><br><span class=\"line\">\t&#125;; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> Apple::i = <span class=\"number\">1</span>; <span class=\"comment\">//类名和范围解析运算符显示初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span>  </span>&#123; </span><br><span class=\"line\">\tApple obj; </span><br><span class=\"line\">\t<span class=\"comment\">// prints value of i </span></span><br><span class=\"line\">\tcout &lt;&lt; obj.i; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>不过也有一些例外情况。首先，当静态成员是<code>const</code>整型（包括<code>char</code>和<code>bool</code>）或<code>const</code>枚举类型时，静态成员可以在类定义内部初始化：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span>  s_var&#123;<span class=\"number\">42</span>&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>从C++17开始，<code>static constexpr</code> 成员可以在类定义内部初始化（无需在外部进行初始化）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class A &#123;</span><br><span class=\"line\">    // 对于任何支持constexpr初始化的类，这都有效</span><br><span class=\"line\">    static constexpr std::array&lt;int , 3&gt; s_array&#123; 1, 2, 3 &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如果在成员函数中调用静态数据成员，那么该成员函数应声明为<code>static</code>。这点在下面解释了，<strong>允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数</strong>。</p>\n<h2 id=\"类对象为静态\">类对象为静态<a title=\"#类对象为静态\" href=\"#类对象为静态\"></a></h2>\n<p>就像变量一样，对象也在声明为 static 时具有范围，直到程序的生命周期。如果我们将对象声明为静态，现在让我们看看输出的变化。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span> </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Apple</span> &#123;  </span><br><span class=\"line\"><span class=\"keyword\">public</span>: </span><br><span class=\"line\">\t<span class=\"built_in\">Apple</span>() &#123; </span><br><span class=\"line\">\t\ti = <span class=\"number\">0</span>; </span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Inside Constructor\\n&quot;</span>; </span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\t~<span class=\"built_in\">Apple</span>() &#123; </span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Inside Destructor\\n&quot;</span>; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> i;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">\t<span class=\"type\">int</span> x = <span class=\"number\">0</span>; </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x==<span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">\t\t<span class=\"type\">static</span> Apple obj; </span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;End of main\\n&quot;</span>; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inside Constructor</span><br><span class=\"line\">End of main</span><br><span class=\"line\">Inside Destructor</span><br></pre></td></tr></table></figure>\n<p>您可以清楚地看到输出的变化。现在，在 main 结束后调用析构函数。这是因为静态对象的范围是贯穿程序的生命周期。</p>\n<h2 id=\"类中的静态成员函数\">类中的静态成员函数<a title=\"#类中的静态成员函数\" href=\"#类中的静态成员函数\"></a></h2>\n<p>静态成员函数可用于 <strong>处理类中的静态成员变量，或执行无需类实例的操作</strong>。不过，从概念和语义上讲，静态成员函数所执行的操作应与类密切相关。关于静态成员函数，有以下几个要点：</p>\n<ul>\n<li>静态成员函数没有<code>this</code>指针。</li>\n<li>静态成员函数不能是虚函数（virtual）。</li>\n<li>静态成员函数不能访问非静态成员。</li>\n<li>静态成员函数不能使用<code>const</code>和<code>volatile</code>限定符（静态变量是可以用 const 修饰的）。</li>\n</ul>\n<p>在实际应用中，静态成员函数意味着无需实例化类就可以调用它。如果<code>Foo</code>类中有一个静态函数<code>static void bar()</code>，你可以这样调用它：<code>Foo::bar()</code>，而无需实例化 <code>Foo</code> 类（顺便说一句，你也可以通过实例调用它：<code>aFoo.bar()</code>）。</p>\n<p><strong>允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数</strong>。</p>\n<p>由于<code>this</code>指针始终保存当前对象的内存地址，而调用静态成员根本不需要对象，所以静态成员函数不能有<code>this</code>指针。</p>\n<p>虚成员与任何特定类没有直接关系，只与实例相关。（根据定义）“虚函数” 是一种动态链接的函数，即在运行时根据给定对象的动态类型选择正确的实现。因此，如果没有对象，就不可能进行虚函数调用。</p>\n<p><strong>访问非静态成员函数要求对象已经构造，但对于静态调用，我们不会传递类的任何实例，甚至不能保证已经构造了任何实例</strong>。</p>\n<p>同样，<code>const</code> 和 <code>const volatile</code> 关键字用于修改对象是否可被修改以及如何被修改。由于静态调用不能保证已经构造了任何实例，所以这两个关键字操作的对象都不知道有没有。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span> </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Apple</span> &#123; </span><br><span class=\"line\"><span class=\"keyword\">public</span>: </span><br><span class=\"line\">\t<span class=\"comment\">// static member function </span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">printMsg</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;Welcome to Apple!&quot;</span>; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main function </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// invoking a static member function </span></span><br><span class=\"line\">    Apple::<span class=\"built_in\">printMsg</span>(); </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Welcome to Apple!</span><br></pre></td></tr></table></figure>\n<h2 id=\"限定访问范围\">限定访问范围<a title=\"#限定访问范围\" href=\"#限定访问范围\"></a></h2>\n<h3 id=\"解决变量冲突问题\">解决变量冲突问题<a title=\"#解决变量冲突问题\" href=\"#解决变量冲突问题\"></a></h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//proj.h</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//proj.c</span></span><br><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[%s]: i = %d\\n&quot;</span>,__FUNCTION__,i);</span><br><span class=\"line\">\t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//main.c</span></span><br><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[%s]: i = %d\\n&quot;</span>,__FUNCTION__,i);</span><br><span class=\"line\">\t<span class=\"built_in\">func</span>();\t</span><br><span class=\"line\">\t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这三个文件当中的全局变量 i 按理来说它们都只作用在本 .c 文件中，因为它们的作用范围和生命周期是不同的，但是编译后出现了错误。显示对 i 的定义重复定义了。所以 main.c 和 proj.c 链接后的 i 会导致作用范围一样，即导致冲突。编译 --&gt; 链接 --&gt; 装入，链接时会出现两个文件的 i。</p>\n<p>如果想要 main.c 和 proj.c 中的 i 变量作用在各自的 .c 文件中，则在各自定义 i 变量时加上关键字 static。像这样 <code>static int i = 10;</code>这样则当前文件修饰的变量只能在当前文件用，这样就不冲突了。</p>\n<p>同理如果一个文件访问另一个文件中加了 static 修饰的变量会出现 undefined reference 的编译错误。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// source1.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"type\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">char</span>* msg = <span class=\"string\">&quot;Hello World!\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">sayHello</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// source2.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">char</span> *msg;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s&quot;</span>, msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"防止函数对外扩展\">防止函数对外扩展<a title=\"#防止函数对外扩展\" href=\"#防止函数对外扩展\"></a></h3>\n<h4 id=\"普通做法会出现的问题\">普通做法会出现的问题<a title=\"#普通做法会出现的问题\" href=\"#普通做法会出现的问题\"></a></h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//proj.h</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//proj.c</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> i = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[%s]: i = %d\\n&quot;</span>,__FUNCTION__,i);</span><br><span class=\"line\">\t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//main.c</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> i = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[%s]: i = %d\\n&quot;</span>,__FUNCTION__,i);</span><br><span class=\"line\">\t<span class=\"built_in\">func</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于 static 修饰了函数，所以只能在该 .c 文件中使用，导致在 .h 文件声明时使用不了，而在 main.c 文件中又使用了 func(), 这样就导致未定义就使用 func() 。</p>\n<h4 id=\"解决方法\">解决方法<a title=\"#解决方法\" href=\"#解决方法\"></a></h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//proj.h</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">call_func</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//proj.c</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> i = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[%s]: i = %d\\n&quot;</span>,__FUNCTION__,i);</span><br><span class=\"line\">\t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">call_func</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">func</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//main.c</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> i = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[%s]: i = %d\\n&quot;</span>,__FUNCTION__,i);</span><br><span class=\"line\">\t<span class=\"built_in\">call_func</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>func() 函数还是只能在本文件使用，只不过借助了一个 call_func() 函数来执行 func()。这样就能保证 func() 在本文件中使用，而在其他文件中通过调用 call_func() 来执行 func().</p>\n<h2 id=\"什么是静态初始化顺序问题\">什么是静态初始化顺序问题<a title=\"#什么是静态初始化顺序问题\" href=\"#什么是静态初始化顺序问题\"></a></h2>\n<p>静态初始化顺序问题是C++中一个容易被许多人忽视、误解的微妙方面。由于该错误通常在<code>main()</code>函数被调用之前就发生了，所以很难察觉。</p>\n<p>在一个翻译单元（translation unit）中，静态或全局变量总是按照它们的定义顺序进行初始化。另一方面，对于哪个翻译单元先被初始化，并没有严格的顺序。</p>\n<p>假设你有一个翻译单元<code>A</code>，其中有一个静态变量<code>sA</code>，它的初始化依赖于翻译单元<code>B</code>中的静态变量<code>sB</code>。那么你有 50% 的失败几率。这就是静态初始化顺序问题。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Logger.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span>  <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\">std::string theLogger = <span class=\"string\">&quot;aNiceLogger&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// KeyBoard.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span>  <span class=\"string\">&lt;iostream&gt;</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span>  <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span>  std::string theLogger;</span><br><span class=\"line\">std::string theKeyboard = <span class=\"string\">&quot;The Keyboard with logger: &quot;</span> + theLogger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span>  <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;theKeyboard: &quot;</span> &lt;&lt; theKeyboard &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那我们看看不同的初始化顺序会产生什么样的结果：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zhangxf@mydevserver ~/static_fiasco $ g++ -c Logger.cpp</span><br><span class=\"line\">zhangxf@mydevserver ~/static_fiasco $ g++ -c Keyboard.cpp</span><br><span class=\"line\">zhangxf@mydevserver ~/static_fiasco $ g++ Logger.o Keyboard.o -o LoggerThenKeyboard</span><br><span class=\"line\">zhangxf@mydevserver ~/static_fiasco $ g++ Keyboard.o Logger.o -o KeyboardThenLogger </span><br><span class=\"line\">zhangxf@mydevserver ~/static_fiasco $ ./KeyboardThenLogger </span><br><span class=\"line\">theKeyboard: The Keyboard with logger: </span><br><span class=\"line\">zhangxf@mydevserver ~/static_fiasco $ ./LoggerThenKeyboard</span><br><span class=\"line\">theKeyboard: The Keyboard with logger: aNiceLogger</span><br></pre></td></tr></table></figure>\n<h2 id=\"如何解决静态初始化顺序问题？\">如何解决静态初始化顺序问题？<a title=\"#如何解决静态初始化顺序问题？\" href=\"#如何解决静态初始化顺序问题？\"></a></h2>\n<p>需要再次提醒的是，在一个翻译单元中，静态或全局变量总是按照它们的定义顺序进行初始化。另一方面，对于哪个翻译单元先被初始化，并没有严格的顺序。</p>\n<p>上面的例子中如果编译单元<code>Logger.cpp</code>先被初始化，那么没问题。但如果是键盘（对应的编译单元）先被初始化，就会出问题。</p>\n<p>可能最简单的解决方案是将<code>Logger.cpp</code>中的<code>theLogger</code>变量替换为一个函数，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::string <span class=\"title\">theLogger</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">static</span>  std::string aLogger = <span class=\"string\">&quot;aNiceLogger&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  aLogger;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在<code>Keyboard.cpp</code>中，我们只需确保对该函数使用<code>extern</code>，并且之后调用这个函数，而不是引用变量。这样做是可行的，因为局部静态变量<code>std::string aLogger</code>会在<code>theLogger()</code>函数第一次被调用时初始化。因此，可以保证在构造<code>theKeyboard</code>时，<code>theLogger</code>已经被初始化。</p>\n<p>如果在<code>theLogger</code>被构造之后，程序退出时另一个静态变量使用了<code>theLogger</code>，你可能会遇到其他问题。同样，对不同翻译单元中静态变量的依赖是代码质量不佳的表现……</p>\n<p>从C++20 开始，可以使用<code>constinit</code>来解决静态初始化顺序问题。在这种情况下，静态变量将在 <strong>编译时、链接之前进行初始化</strong>。你可以在这里查看相关解决方案。</p>\n","prev":{"title":"环境变量","link":"2024/环境变量"},"next":{"title":"scanf相关知识","link":"2024/scanf相关知识"},"plink":"https://CHONG589.github.io/2024/static用法/","toc":[{"id":"函数中的静态变量","title":"函数中的静态变量","index":"1"},{"id":"类中的静态成员变量","title":"类中的静态成员变量","index":"2"},{"id":"类对象为静态","title":"类对象为静态","index":"3"},{"id":"类中的静态成员函数","title":"类中的静态成员函数","index":"4"},{"id":"限定访问范围","title":"限定访问范围","index":"5"},{"id":"什么是静态初始化顺序问题","title":"什么是静态初始化顺序问题","index":"6"},{"id":"如何解决静态初始化顺序问题？","title":"如何解决静态初始化顺序问题？","index":"7"}]}