{"title":"指针与变量","date":"2024-02-02T13:55:50.000Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"updated":"2024-02-15T12:07:23.567Z","content":"<h4 id=\"1.-变量与地址\">1. 变量与地址<a title=\"#1.-变量与地址\" href=\"#1.-变量与地址\"></a></h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i = 1;</span><br><span class=\"line\">int *p = &amp;i;</span><br></pre></td></tr></table></figure>\n<p>p 就是一个指针变量，用来存放变量 i 的地址值，所以我们平常所说的定义一个指针指向一个值，其实就是定义一个指针变量来存放这个值的地址。<br>\n<code>int **q = &amp;p;</code></p>\n<p>p 是一个指针变量，q 是用来存放指针变量 p 的地址值的变量，即定义时一个 * 指存放地址的变量，** 指是用来存放指针变量的地址的变量。要满足两边的类型相同。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int *p;</span><br><span class=\"line\">float *q;</span><br><span class=\"line\">double *d;</span><br><span class=\"line\">char *c;</span><br></pre></td></tr></table></figure>\n<p>不管定义的是什么类型的指针变量(即我们通常说的指针)，是几级的指针，以及定义的结构体类型的指针，其在某一个平台上所占的空间是确定的大小，在 64 位的机器上占 8 个字节。</p>\n<p>不同类型的指针，其在运算时，如 *p 在做取值运算时，若 p 为 char ，则取一个字节，int 时，则取四个字节，所以什么类型的数据，要对应什么类型的指针，不然在取值时取得的大小与实际不符。</p>\n<h4 id=\"2.-指针与指针变量(上面也有解释)\">2. 指针与指针变量(上面也有解释)<a title=\"#2.-指针与指针变量(上面也有解释)\" href=\"#2.-指针与指针变量(上面也有解释)\"></a></h4>\n<blockquote>\n<p>指针：就是一个地址，是常量，不会变的。<br>\n指针变量：用来存放指针的变量，可以改变。<br>\n我们常说的某指针指向谁，哪个指针又指向谁，是指改变指针变量的值</p>\n</blockquote>\n<h4 id=\"3.-直接访问与间接访问\">3. 直接访问与间接访问<a title=\"#3.-直接访问与间接访问\" href=\"#3.-直接访问与间接访问\"></a></h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i = 1;</span><br><span class=\"line\">int *p = &amp;i;    </span><br><span class=\"line\">int **q = &amp;p;</span><br><span class=\"line\"></span><br><span class=\"line\"> i --&gt; 1                        q --&gt; 0x3000 --&gt; &amp;p</span><br><span class=\"line\">&amp;i --&gt; 0x2000                   &amp;q --&gt; 0x4000 </span><br><span class=\"line\"> p --&gt; 0x2000    --&gt; &amp;i         *q --&gt; *(&amp;p)  --&gt; &amp;i</span><br><span class=\"line\">&amp;p --&gt; 0x3000                  **q --&gt; *(*q)  --&gt; *(&amp;i) --&gt; 1</span><br><span class=\"line\">*p --&gt; *(0x2000) --&gt; 1</span><br></pre></td></tr></table></figure>\n<p><img src=\"/Learn/%E6%8C%87%E9%92%88%E4%B8%8E%E5%8F%98%E9%87%8F.htm/1.jpg\" alt class=\"φcx\"></p>\n<h4 id=\"4.-空指针与野指针\">4. 空指针与野指针<a title=\"#4.-空指针与野指针\" href=\"#4.-空指针与野指针\"></a></h4>\n<blockquote>\n<p>野指针：int *p = 0x2000; 这种直接赋地址的形式，因为你不知道这块地址是否可用，通常很危险。<br>\n空指针：int *p = NULL; NULL 即为位于地址 0 的位置，0 号地址不分配给任何进程，指针定义出来后暂时还不知道指向哪里时，则将它指向 NULL；</p>\n</blockquote>\n<h4 id=\"5.-空类型\">5. 空类型<a title=\"#5.-空类型\" href=\"#5.-空类型\"></a></h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *q = NULL;     </span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>任何类型的指针值都能够把自己的值赋给 void *， void * 也能够把当前自己的值赋给任何类型的指针。当自己不知道要用到什么类型的值时使用。</p>\n</blockquote>\n<h4 id=\"6.-定义与初始化的书写规则\">6. 定义与初始化的书写规则<a title=\"#6.-定义与初始化的书写规则\" href=\"#6.-定义与初始化的书写规则\"></a></h4>\n<h4 id=\"7.-指针运算\">7. 指针运算<a title=\"#7.-指针运算\" href=\"#7.-指针运算\"></a></h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*     &amp;   关系运算   ++   --</span><br></pre></td></tr></table></figure>\n<p>*p++：等同于：*p;  p += 1;</p>\n<p>解析: 但是，因为 ++ <strong>后置</strong>的时候，本身含义就是先运算后增加1（运算指的是p++作为一个整体与前面的 * 进行运算；增加1指的是p+1），所以实际上 *p++ 符号<strong>整体对外表现的值</strong>是 *p 的值，运算完成后 p 再加1.<br>\n*++p：等同于 p += 1;    *p;</p>\n<p>解析：由于 ++ 在 p 的前面，++ 前置的含义是，先 p 加1，得到一个新的p（它的值是原来p的值加1）。然后这个新的 p 再与前面的 * 结合.</p>\n<h4 id=\"8.-指针与数组\">8. 指针与数组<a title=\"#8.-指针与数组\" href=\"#8.-指针与数组\"></a></h4>\n<ul>\n<li>\n<p><strong>指针与一维数组</strong></p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a[3] = &#123;1,2,3&#125;;</span><br><span class=\"line\">int *p = a;</span><br><span class=\"line\">int i;</span><br></pre></td></tr></table></figure>\n<p>a[i] = *(a + i) = *(p + i) = p[i];<br>\n&amp;a[i] = a + i = p + i = &amp;p[i];</p>\n<p>这样看来指针(指针变量)好像是等价于一维数组的，但是它们是不完全等价的，首先，a 是地址，是一个常量，p 是指针变量，是一个变量，a++ 是不能运算的 (a = a + 1), 常量不能出现在运算符左边进行赋值操作，但 p++ 可以。</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p++    --&gt;  p = p + 1 --&gt; p 的指向已经改变</span><br><span class=\"line\">p + 1  --&gt;  p 的指向未改变  </span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><strong>指针与二维数组</strong><br>\n<strong>二维数组结合指针的理解</strong>: a[i][j] 相当于是数组名为 a[i],然后取第 j 个元素，即为 a[i][j],用指针的形式表示为：*(*(a + i) + j); (a + i) 是先按行移动指针，移动的 ‘1’ 就是一行，即一行 j 个元素，移到第 i 行的首地址，此时 (a + i) 还只是 a[i] 的函数名，即在第 i 个数组的函数名地址，要想取 a[i] 还要加一个 * 进行取值操作，结果为 a[i]（具体可参考<a href=\"https://chong589.github.io/2024/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84\" target=\"_blank\">二维数组的二次分配</a>）, 而 a[i] 又为 a[i][j] 的函数名，即地址，a[i] + j 为 a[i][j] 的地址，* 取值后成为 a[i][j].</p>\n<p><strong>二维数组的二次分配解析: 二维数组的行指针就是一个二级指针用于存储一级指针的地址，所以在分配行指针时大小就是一个指针变量的大小，它是存一级指针的地址。二维数组 a[i][j] 中，(a + i) 表示的就是取第 i 个二级指针变量里存的地址（就是一级指针的地址），而 *(a + i) 就是取一级指针里的内容，即变量的地址（为a[i]）</strong></p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a[2][3] = &#123;1,2,3,4,5,6&#125;;</span><br><span class=\"line\">int i, j;</span><br><span class=\"line\">int *p;</span><br></pre></td></tr></table></figure>\n<p><code>p = a</code> 是不允许的，因为 p 是在列指针上移动的，而 a 是在行指针上移动的，即 p + 1 和 a + 1 所表达的含义不一样，a + 1 是指加一行，p + 1 是加一个元素。</p>\n<p><code>p = *a</code> 即为 <code>*(a + 0)</code> 此种形式是可以的，此时 *a 取的是数组元素的地址,而不是存储元素地址的地址，使之在数组在列指针上移动，即每加 1 为一个元素大小。</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = *a;</span><br><span class=\"line\">for(int i = 0; i &lt; 6; i++)</span><br><span class=\"line\">    printf(&quot;%d &quot;,p[i]);</span><br><span class=\"line\">printf(&quot;\\n&quot;);</span><br></pre></td></tr></table></figure>\n<p>二维数组也可以用这种方式输出。</p>\n</li>\n<li>\n<p><strong>指针与字符数组</strong></p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char str[10] = &#123;&quot;hello world&quot;&#125;;</span><br><span class=\"line\">char *s; s = &quot;china&quot;;</span><br></pre></td></tr></table></figure>\n<p>C 语言中编译器会给字符串常量分配地址，如 “china”，存储在内存中的 0x3000, 0x3001, 0x3002, 0x3003, 0x3004, 0x3005; 字符串常量的本质表现是代表它的第一个字符的地址，即 0x3000; 所以 <code>s = &quot;china&quot;</code> 是可以的，此操作相当于 s = “china” = 0x3000; 但是 <code>str = &quot;hello world&quot;</code> 是不允许的，str 是地址常量，不能赋给它。</p>\n<p>所以 <code>printf(&quot;%s&quot;,s);</code> 是通过字符串首地址输出字符串，因为字符串在内存中是连续存放的，遇到 \\0 结束</p>\n<p>其实它与 <code>printf(&quot;%s&quot;,0x3000);</code> 是等效的，前者是用了一个指针变量存储 0x3000, 后者是直接用地址，后者与 <code>printf(&quot;%s&quot;,str)</code> 等价，因为 str 就是地址常量，则可以 s = str, 但不能 str = s;</p>\n<p>因为 s 为指针变量，本身就是可以存地址的，将 str 的地址赋给 s 就是将数组 str[] 的首地址给指针 s。 而 str = s , str 在定义的时候就已经分配了地址空间，即首地址是已经固定了的，而 str = s 这样是在改变它的地址了，肯定不可能。</p>\n<p><code>char *s = &quot;china&quot;;</code> 的本质是一个指针变量，只占八个字节(64位机器中)，用来保存第一个字符的地址(str 就是一个地址)，它可以用 <code>printf(&quot;%c&quot;,s[i]);</code> 逐个输出字符，或 <code>printf(&quot;%c&quot;,*s++);</code> s[i] 就是 *(s + i)；例：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char str[] = &quot;hello&quot;;</span><br><span class=\"line\">printf(&quot;%d %d\\n&quot;,sizeof(str),strlen(str));</span><br><span class=\"line\">strcpy(str,&quot;world&quot;);</span><br><span class=\"line\">puts(str);</span><br></pre></td></tr></table></figure>\n<p><code>sizeof(str)</code>为 6 字节，<code>strlen(str)</code> 为 5 字节，而<code>puts(str)</code>输出为 world,正确输出。<strong>strcpy 是将 world 复制到常量地址 str 开头的地址空间中</strong>。</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char *s = &quot;hello&quot;;</span><br><span class=\"line\">printf(&quot;%d %d\\n&quot;,sizeof(s),strlen(s));</span><br><span class=\"line\">strcpy(s,&quot;world&quot;);</span><br><span class=\"line\">puts(s);</span><br></pre></td></tr></table></figure>\n<p>这段程序会报段错误（Segmentation Fault），为什么数组 str 不会，而用指针 s 就会，这就要理解内存分配的问题了，要使用内存，必须先分配了才能使用。</p>\n<p>定义了指针要为其分配内存才能使用，我们平时直接指向变量、数组等，好像并没有分配内存也直接用了，其实你在定义变量、数组后，已经为变量，数组分配了空间，你让指针指向它们，是可以直接使用的。</p>\n<p>而字符串常量 “hello” 赋给指针的本质是将字符串所在的空间的首地址给指针，指针只存了首地址，并没有为指针分配空间，但是用 <code>char str[] = &quot;hello&quot;;</code>,定义数组时就已经为数组分配了空间了。所以用数组不会报错</p>\n<p>通过 strcpy 的源码可知</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//返回char*的原因是 可以在其他函数中直接调用。</span><br><span class=\"line\">char * strcpy(char *dst,const char *src) &#123;          // 源字符串参数用const修饰，防止修改源字符串 </span><br><span class=\"line\">    assert(dst != NULL &amp;&amp; src != NULL);             // 检查指针的有效性  </span><br><span class=\"line\"></span><br><span class=\"line\">    char *ret = dst;                                // 记下dst的初始地址防止找不到</span><br><span class=\"line\"></span><br><span class=\"line\">    while ((*dst++=*src++)!=&#x27;\\0&#x27;);                  // 将src中所有字符(包括&#x27;\\0&#x27;)一个字符一个字符的拷贝到dst(包括&#x27;\\0&#x27;)。在赋值完&#x27;\\0&#x27;后，循环停止</span><br><span class=\"line\"></span><br><span class=\"line\">    return ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>观察可知，在复制的过程中，dst++ 会移动，即 s++ ，而又没有为指针 s 分配内存，你这样做是访问未分配给你的内存，自然就报段错误</p>\n</li>\n</ul>\n<h4 id=\"9.-const-与-指针\">9. const 与 指针<a title=\"#9.-const-与-指针\" href=\"#9.-const-与-指针\"></a></h4>\n<ul>\n<li>\n<p><strong>const 的概念</strong><br>\nconst 关键字是一种修饰符。所谓“修饰符”，就是在编译器进行编译的过程中，给编译器一些“要求”或“提示”，但修饰符本身，并不产生任何实际代码。就 const 修饰符而言，它用来告诉编译器，被修饰的这些东西，具有“只读”的特点。在编译的过程中，一旦我们的代码试图去改变这些东西，编译器就应该给出错误提示。</p>\n</li>\n<li>\n<p><strong>与 define 的区别</strong><br>\ndefine 定义的对象没有数据类型，编译器只能机械地进行字符替换，没有类型安全检查，即会出现“边际问题”或者是“括号问题”。而 const 定义的是变量，有数据类型。如：我们想要这样定义</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define PI 3.14</span><br></pre></td></tr></table></figure>\n<p>但是我们不小心写成了</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define PI sdlkf</span><br></pre></td></tr></table></figure>\n<p>编译器也不会报错，而是编译时直接用该值替换，如果用 const 则不会，它本身就是变量，有数据类型，会进行安全检查，sdlkf 是 char ，而 3.14 为 float ，这样编译器就会报错。同样，define 还会出现括号问题,所以 const 既有变量的有点，又有 define 的优点。</p>\n</li>\n<li>\n<p><strong>const 变量</strong><br>\nconst 变量指的是，此变量的值是只读的，不应该被改变。如果我们在程序中试图修改 const 变量的值，在编译的时候，编译器将给出错误提示(即在代码中出现赋值给 const 变量的语句)。正因为 const 变量的值在给定以后不能改变，所以 <strong>const 变量必须被初始化</strong>。（如果不初始化，之后还怎么赋值呢？）如果我们不初始化 const 变量，编译时也会有错误提示。<br>\n定义形式：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const int a;</span><br><span class=\"line\">int const a;</span><br></pre></td></tr></table></figure>\n<p>这两种定义方式都是可以的，但是记得一定要初始化。</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const float pi = 3.14;</span><br><span class=\"line\">float *p = &amp;pi;</span><br><span class=\"line\">*p = 3.14159;</span><br></pre></td></tr></table></figure>\n<p>这样通过指针来改变 pi 的值编译器可以通过，但是这样也是非常危险的。会出现警告：初始化丢弃了指针目标类型的限定。正确的做法应该为 <code>const float *p = &amp;pi;</code>,即指向 const 变量的指针也应该定义成 const 类型。所以说 const 变量也不是不可以改变的。即不通过改变量来修改值，而是通过指针间接修改。</p>\n</li>\n<li>\n<p><strong>常量指针</strong><br>\n常量指针是指针指向的内容是常量</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const int *p;</span><br><span class=\"line\">int const *p;</span><br></pre></td></tr></table></figure>\n<p>可以结合以下方法记忆</p>\n<p><code>int *p;</code> 为整型指针，是指向整型的指针，自然 <code>const int *p</code> 就为指向常量的指针。</p>\n<p>常量指针说的是<strong>不能通过这个指针改变变量的值</strong>，但可以通过其他的引用来改变变量的值。</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int cnt = 5;</span><br><span class=\"line\">const int* num = &amp;cnt;</span><br><span class=\"line\">cnt=6;</span><br></pre></td></tr></table></figure>\n<p>即不能 <code>*num = 6;</code> 这样改变值，但可以 <code>cnt = 6;</code>来改变。如果 cnt 也加上 const 来限定就不可以这样来改了。<br>\n所以要想不改变一个变量的值，应该这样：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const float pi = 3.14;</span><br><span class=\"line\">const float *p = &amp;pi;</span><br></pre></td></tr></table></figure>\n<p>这样无论是用指针 p 还是用变量 pi 都无法修改 pi 的值。<br>\n常量指针指向<strong>地址中保存的值不能改变</strong>，但是<strong>指向的地址可以改变</strong>。</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int cnt = 5;</span><br><span class=\"line\">int tmp = 6;</span><br><span class=\"line\">const int* num = &amp;cnt;</span><br><span class=\"line\">num = &amp;tmp;</span><br></pre></td></tr></table></figure>\n<p>联想记忆：可以想象成它定义的是 *p ,而它表示指针指向的值，则表示值不能改变。</p>\n</li>\n<li>\n<p><strong>指针常量</strong><br>\n指针常量是指指针本身是个常量，不能再指向其他的地址，写法如下：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int *const p;</span><br><span class=\"line\">const int *const p;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，指针常量指向的<strong>地址不能改变</strong>，但是<strong>地址中保存的数值是可以改变</strong>的，可以通过其他指向该地址的指针来修改。</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int cnt = 5;</span><br><span class=\"line\">int *tmp = &amp;cnt;</span><br><span class=\"line\">int* const num = &amp;cnt;</span><br><span class=\"line\">*tmp = 6;</span><br></pre></td></tr></table></figure>\n<p>直接用 *num = 6; 也可以修改。<br>\n联想记忆：它定义的是 p ，表示一个地址，则为指向的地址不能改变。</p>\n</li>\n<li>\n<p><strong>指向常量的常指针</strong></p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const int *const p;</span><br></pre></td></tr></table></figure>\n<p>这相当于是常量指针与指针常量的结合，指针<strong>指向的位置</strong>不能改变并且也<strong>不能通过这个指针改变变量的值</strong>。</p>\n</li>\n</ul>\n<h4 id=\"10.-指针数组与数组指针(工作常用，指针函数、数组指针)\">10. 指针数组与数组指针(工作常用，指针函数、数组指针)<a title=\"#10.-指针数组与数组指针(工作常用，指针函数、数组指针)\" href=\"#10.-指针数组与数组指针(工作常用，指针函数、数组指针)\"></a></h4>\n<p><strong>数组指针</strong>：像整型指针为指向整型的指针，而数组指针则为指向数组的指针。</p>\n<blockquote>\n<p>【存储类型】 数据类型  (*指针名)【下标】  = 值</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int (*p)[3]; --&gt; type name; --&gt; int[3] *p;</span><br></pre></td></tr></table></figure>\n<p>type 可以是 int char double,以及结构体类型，上面这种为数组类型。int *p; p 每加一，p 移动一个 int 大小，而 <code>int (*p)[3]</code>即<code>int[3] *p</code>移动三个 int 大小。是数组间移动。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a[2][3] = &#123;1,2,3,4,5,6&#125;;</span><br><span class=\"line\">int i,j;</span><br><span class=\"line\">int *p = *a;</span><br><span class=\"line\">int (*q)[3] = a;</span><br></pre></td></tr></table></figure>\n<p>这种形式定义的 q 每加一，和 a 加一是一样的，q 加一，移动三个 int型元素大小，和二维数组的行指针一样。但要注意<strong>区别</strong>：a 是常量，q 是变量。<strong>二维数组的本质就是一个数组指针</strong>。</p>\n<p><strong>指针数组</strong>：数组中每个元素就是一个指针。</p>\n<blockquote>\n<p>【存储类型】 数据类型  * 数组名【下标】  = 值；</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int * arr[3];  --&gt;  TYPE NAME;</span><br></pre></td></tr></table></figure>\n<h4 id=\"11.-多级指针\">11. 多级指针<a title=\"#11.-多级指针\" href=\"#11.-多级指针\"></a></h4>\n","link":"Learn/指针与变量","comments":true,"plink":"https://CHONG589.github.io/Learn/指针与变量/","reward":true,"copyright":{"published":"2024年2月2日","updated":"2024年2月15日","author":"Chong","link":"<a href=\"https://CHONG589.github.io/Learn/指针与变量/\" title=\"指针与变量\">https://CHONG589.github.io/Learn/指针与变量/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}