{"title":"字符数组","date":"2024-02-02T13:50:00.000Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"author":"Chong","thumbnail":"2024/字符串/./thumb.png","link":"2024/字符串","comments":true,"updated":"2025-04-10T08:00:03.120Z","content":"<h1 id=\"概念\">概念<a title=\"#概念\" href=\"#概念\"></a></h1>\n<p>C 语言本身没有内置的字符串类型，字符串本质上是一种特殊类型的数组，它的组成元素类型为 char，除此之外不受制与数组长度的限制，以<code>'\\0'</code>作为结束标志，作为字符串结束的标志。（ <code>\\0</code> 作为一个特殊字符，它的 ASCII 值为 0，但是它不是<code>'0'</code>字符，<code>'0'</code>字符的 ASCII 值为 48）</p>\n<h1 id=\"字符串字面量-(字符串常量)\">字符串字面量 (字符串常量)<a title=\"#字符串字面量-(字符串常量)\" href=\"#字符串字面量-(字符串常量)\"></a></h1>\n<p>字符串字面量形如 <code>&quot;string&quot;</code>，也被称为字符串常量，编译器会将它末尾自动添加上字符串结尾标志 <code>\\0</code>。通常存储在内存的 ​<strong>​只读数据段​</strong>​（<code>.rodata</code> 只读数据段 或 <code>.text</code> 程序代码段）中，与程序的生命周期一致。说以静态形式存储在程序中也是对的。</p>\n<h1 id=\"初始化\">初始化<a title=\"#初始化\" href=\"#初始化\"></a></h1>\n<h2 id=\"使用字符串数组初始化\">使用字符串数组初始化<a title=\"#使用字符串数组初始化\" href=\"#使用字符串数组初始化\"></a></h2>\n<h3 id=\"字符串列表初始化\">字符串列表初始化<a title=\"#字符串列表初始化\" href=\"#字符串列表初始化\"></a></h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//必须显式添加 &#x27;\\0&#x27;</span></span><br><span class=\"line\"><span class=\"type\">char</span> a[] = &#123;<span class=\"string\">&#x27;h&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;o&#x27;</span>, <span class=\"string\">&#x27;!&#x27;</span>, <span class=\"string\">&#x27;\\0&#x27;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//不建议这样初始化：</span></span><br><span class=\"line\"><span class=\"type\">char</span> a[] = &#123;<span class=\"string\">&#x27;h&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;o&#x27;</span>, <span class=\"string\">&#x27;!&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p>因为如果是逐个字符初始化数组，比如 <code>char str[] = &#123;'h', 'e', 'l', 'l', 'o'&#125;;</code>，这时候数组的长度是 5，没有 <code>'\\0'</code> 结束符。这时候如果当作字符串使用，比如用 printf 打印，可能会导致越界访问，因为函数会一直找直到遇到 <code>'\\0'</code> 才停止。</p>\n<p>如果这样写：<code>char str[] = &quot;hello&quot;;</code>，这时候数组的长度会自动计算为 6，包括结尾的 <code>'\\0'</code>。这是因为用双引号的 <strong>字符串字面量</strong> 初始化数组时，编译器会自动添加结束符。所以这种情况下，即使不指定长度，数组会有 <code>'\\0'</code>。</p>\n<p>当指定数组大小，但是数组大小要足够，要预留 <code>'\\0'</code> 的位置时，这样即使没有显示的添加 <code>'\\0'</code>，编译器会自动在后面补 <code>'\\0'</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> a[<span class=\"number\">6</span>] = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//后面未初始化的部分会被自动设为 &#x27;\\0&#x27;</span></span><br><span class=\"line\"><span class=\"type\">char</span> a1[<span class=\"number\">10</span>] = <span class=\"string\">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"字面量的形式初始化数组\">字面量的形式初始化数组<a title=\"#字面量的形式初始化数组\" href=\"#字面量的形式初始化数组\"></a></h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> a[] = <span class=\"string\">&quot;hello!&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>这种情况下，数组会自动包含 <code>\\0</code>，长度是字符数加 1。</p>\n<h2 id=\"使用指针指向字符串字面量初始化\">使用指针指向字符串字面量初始化<a title=\"#使用指针指向字符串字面量初始化\" href=\"#使用指针指向字符串字面量初始化\"></a></h2>\n<p>str 是一个指针，指向存储在 ​<strong>​只读内存区​</strong>​ 的字符串字面量。末尾自动包含 <code>\\0</code>，可作为字符串安全使用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> *str = <span class=\"string\">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"动态内存分配\">动态内存分配<a title=\"#动态内存分配\" href=\"#动态内存分配\"></a></h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> *str = <span class=\"built_in\">malloc</span>(<span class=\"number\">6</span> *<span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>));</span><br><span class=\"line\"><span class=\"built_in\">strcpy</span>(str, <span class=\"string\">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n<h1 id=\"字符串数组和指针\">字符串数组和指针<a title=\"#字符串数组和指针\" href=\"#字符串数组和指针\"></a></h1>\n<ul>\n<li>\n<p>字符串数组形式：字符串常量存储在只读内存区中，使用字符串数组来对它进行存储时，编译器会自动将 <strong>字符串常量的内容</strong>（包括结尾的<code>\\0</code>）拷贝到数组所在的存储空间（栈或静态存储区，取决于数组的作用域）。</p>\n</li>\n<li>\n<p>指针形式：这种方法就是将字符串常量的首地址赋值给指针变量，即指针指向这个字符串，并没有拷贝，而是直接指向那段内存，但是不可以更改里面的内容，因为是只读数据段。</p>\n</li>\n</ul>\n<h1 id=\"注意问题\">注意问题<a title=\"#注意问题\" href=\"#注意问题\"></a></h1>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">11</span>] = &#123;<span class=\"string\">&quot;hello world&quot;</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">char</span> *s; s = <span class=\"string\">&quot;china&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//不能这样</span></span><br><span class=\"line\">str = <span class=\"string\">&quot;zeng chong&quot;</span></span><br></pre></td></tr></table></figure>\n<p>解释一下这几句都做了什么：</p>\n<p>首先在内存的只读数据段为 “hello world” 分配了内存，该内存只读，不能修改，然后在栈中为 char 型数组分配内存，大小为 11，然后将只读数据段中的字符串字面量的内容 “hello world&quot; 拷贝到数组 str 中（大小足够）。然后是第二句，在栈中分配了一个 char 型指针变量，在只读数据段为 ”china“ 分配内存，再让 s 指向 “china”。</p>\n<p>至于第三句为什么不行？因为 str 数组是分配在了栈中，数组的地址固定的，我们可以改变数组中的内容，相当于编译器在栈中分配了一个房子，房子容量是 11 个人，我们可以改变里面住谁（元素），但是在作用域内，房子地址已经分配在那里了，我们就不可以更改它的地址了，而第三句是将在只读数据段中的字面量地址赋值给数组，相当于改变数组的地址，这样显然是不行的。</p>\n<p>所以 <code>s = str</code> 是可以的，可以改变指针 s 的指向，但是 <code>str = s</code> 不行。</p>\n<p><code>char *s = &quot;china&quot;;</code> 的本质是一个指针变量，只占八个字节(64位机器中)，用来保存第一个字符的地址(str 就是一个地址)，它可以用 <code>printf(&quot;%c&quot;,s[i]);</code> 逐个输出字符，或 <code>printf(&quot;%c&quot;,*s++);</code> <code>s[i]</code> 就是 <code>*(s + i)</code>；例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[] = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d\\n&quot;</span>,<span class=\"keyword\">sizeof</span>(str),<span class=\"built_in\">strlen</span>(str));</span><br><span class=\"line\"><span class=\"built_in\">strcpy</span>(str,<span class=\"string\">&quot;world&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">puts</span>(str);</span><br></pre></td></tr></table></figure>\n<p><code>sizeof(str)</code>为 6 字节，<code>strlen(str)</code> 为 5 字节，而 <code>puts(str)</code> 输出为 world，正确输出。<strong>strcpy 是将 “world” 复制到数组 str 的地址空间中</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> *s = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d\\n&quot;</span>,<span class=\"keyword\">sizeof</span>(s),<span class=\"built_in\">strlen</span>(s));</span><br><span class=\"line\"><span class=\"built_in\">strcpy</span>(s,<span class=\"string\">&quot;world&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">puts</span>(s);</span><br></pre></td></tr></table></figure>\n<p>这段程序会报段错误（Segmentation Fault），为什么数组 str 不会，而用指针 s 就会，这就要理解内存分配的问题了，要使用内存，必须先分配了才能使用。</p>\n<p>这其实跟上面是一样的道理的，首先，在栈空间中分配了一个指针变量，然后字面量 “hello” 被分配在常量区中，然后将常量区的首地址赋给了 s，即 s 指向了 “hello”，s 指向的空间是位于常量区的，你更改不了它内存中的值，所以你这样会报错。</p>\n<p>如果 s 指向的是堆中的内存 (事先已经分配好了，再让 s 指向它)，或者通过 <code>s = malloc(10);</code> 在堆中分配内存，然后这时就可以调用 strcpy 就可以成功。</p>\n<h1 id=\"实现自己的-memcpy。\">实现自己的 memcpy。<a title=\"#实现自己的-memcpy。\" href=\"#实现自己的-memcpy。\"></a></h1>\n<p>首先 strcpy 是复制字符串的，而 memcpy 是内存拷贝的，任意类型的数据都能进行拷贝。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> * <span class=\"title\">memcpy</span> <span class=\"params\">( <span class=\"type\">void</span> * destination, <span class=\"type\">const</span> <span class=\"type\">void</span> * source, <span class=\"type\">size_t</span> num )</span></span>;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>参数中除了要复制的<code>字节数 num</code>，其他的参数类型基本都是 <code>void *</code>，返回值也是 <code>void *</code>。</li>\n<li>该函数是从 <code>source</code> 的位置开始向后复制 <code>num 个字节</code> 的数据到 <code>destination</code> 的内存位置。</li>\n<li>该函数在遇到 <code>'\\0'</code> 的时候并不会停下来。</li>\n<li><code>source</code> 和 <code>destination</code> 不能有任何的重叠。</li>\n</ol>\n<p><code>void *</code> 不能直接解引用，那么 **如何复制呢？**答案是进行类型强转，转换成<code>char *</code>，一个一个字节地复制过去。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">myMemcpy</span><span class=\"params\">(<span class=\"type\">void</span> *dest, <span class=\"type\">const</span> <span class=\"type\">void</span> *src, <span class=\"type\">size_t</span> num)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(dest);</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(src);</span><br><span class=\"line\">    <span class=\"type\">char</span> *pDest = dest;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> *pSrc = src;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(num--) &#123;</span><br><span class=\"line\">        *pDest++ = *pSrc++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"memmove-实现\">memmove 实现<a title=\"#memmove-实现\" href=\"#memmove-实现\"></a></h1>\n<p>memcpy 如果 src 和 dest 中有内存重叠的情况是不能拷贝成功的，下面是会出现的几种情况。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 如下所示，src &lt; dest &amp;&amp; src + n &gt; dest 时，有内存重叠，这样拷贝是不成功的，</span><br><span class=\"line\">\t需要从后往前拷贝。</span><br><span class=\"line\">----------------------------       ======&gt;&gt; 从后往前拷贝</span><br><span class=\"line\"> |        |</span><br><span class=\"line\">src     dest</span><br><span class=\"line\"></span><br><span class=\"line\">2. dest &lt; src &amp;&amp; dest + n &gt; src 时，虽然这样也有重叠，但是这样从前往后拷贝是</span><br><span class=\"line\">\t不会出错的。</span><br><span class=\"line\">----------------------------       ======&gt;&gt; 从前往后拷贝</span><br><span class=\"line\"> |        |</span><br><span class=\"line\">dest     src</span><br><span class=\"line\"></span><br><span class=\"line\">3. src + n &lt; dest 的情况，即 src &lt; dest ，没有重叠</span><br><span class=\"line\">-----------------------------      ======&gt;&gt; 两种都可以</span><br><span class=\"line\"> |                  |</span><br><span class=\"line\">src                dest</span><br><span class=\"line\"></span><br><span class=\"line\">4. dest + n &lt; src 的情况，即 dest &lt; src ，没有重叠</span><br><span class=\"line\">-----------------------------      ======&gt;&gt; 两种都可以</span><br><span class=\"line\"> |                  |</span><br><span class=\"line\">dest               src</span><br></pre></td></tr></table></figure>\n<p>可以看到有四种情况，只有一种情况是只能用从后往前拷贝的，我们可以将 src &lt; dest 的情况都归类为从后往前拷贝，因为第三种情况两种拷贝方式都可以，然后其它情况就是从前往后拷贝的情况，即 src &gt;= dest。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">memmove</span><span class=\"params\">(<span class=\"type\">void</span> *dest, <span class=\"type\">const</span> <span class=\"type\">void</span> *src, <span class=\"type\">size_t</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(dest);</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(src);</span><br><span class=\"line\">    <span class=\"type\">char</span> *pDest = (<span class=\"type\">char</span> *)dest;</span><br><span class=\"line\">    <span class=\"type\">char</span> *pSrc = (<span class=\"type\">char</span> *)src;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(src &lt; dest) &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">//从后往前拷贝</span></span><br><span class=\"line\">\t    <span class=\"keyword\">while</span>(n--) &#123;</span><br><span class=\"line\">\t\t    *(dest + n) = *(src + n);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">//从前往后拷贝</span></span><br><span class=\"line\">\t    *dest++ = *src++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"strcpy-函数实现\">strcpy 函数实现<a title=\"#strcpy-函数实现\" href=\"#strcpy-函数实现\"></a></h1>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">char</span> *<span class=\"title\">strcpy</span><span class=\"params\">(<span class=\"type\">char</span> *dest, <span class=\"type\">const</span> <span class=\"type\">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>确保目标字符串 dest 有足够的空间来存储源字符串 src 的内容。</li>\n<li>调用 strcpy 函数，将源字符串 src 的内容(包括 ‘\\0’ )复制到目标字符串 dest 中。</li>\n<li>返回目标字符串 dest 的地址。</li>\n</ol>\n<p>strcpy 函数并不会检查目标字符串 dest 的容量是否足够，因此在使用 strcpy 函数时，务必确保目标字符串有足够的空间来存储源字符串的内容，以免发生缓冲区溢出的问题。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">char</span> *<span class=\"title\">myStrcpy</span><span class=\"params\">(<span class=\"type\">char</span> *dest, <span class=\"type\">const</span> <span class=\"type\">char</span> *src)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">assert</span>(dst != <span class=\"literal\">NULL</span> &amp;&amp; src != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t<span class=\"type\">char</span> *ret = dest<span class=\"number\">&#x27;</span></span><br><span class=\"line\">\t<span class=\"comment\">//拷贝的内容包括 &#x27;\\0&#x27;，遇到 &#x27;\\0&#x27; 后，</span></span><br><span class=\"line\">\t<span class=\"comment\">//先赋值给 dest，然后判断为 0，跳出循环。</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>((*dest++ = *src++) != <span class=\"string\">&#x27;\\0&#x27;</span>) ;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"strncpy-实现\">strncpy 实现<a title=\"#strncpy-实现\" href=\"#strncpy-实现\"></a></h1>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">char</span> *<span class=\"title\">mystrncpy</span> <span class=\"params\">(<span class=\"type\">char</span> *dest, <span class=\"type\">const</span> <span class=\"type\">char</span> *src, <span class=\"type\">size_t</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n &amp;&amp; (dest[i] = src[i]); i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//(dest[i] = src[i]) 作用是一边拷贝到 dest 中，一边用作判断，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//当 (dest[i] = src[i])的值为 \\0 即在 &amp;&amp; 运算中式子不成立，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//跳出循环,因为 有时 src 的长度会小于 n ，即 src 不够长, 那</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//就只拷贝 src 那么长的</span></span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (; i &lt; n; i++)</span><br><span class=\"line\">\t\tdest[i] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>若 src 没有 n 那么长，经过 <code>(dest[i] = src[i])</code> 将 <code>\\0</code> 复制到了 dest 中，且判断跳出循环，这时 <code>\\0</code> 是赋值到了字符串中的，当 src &gt; n 时，是因为 i &lt; n 这个条件不满足导致跳出，<code>\\0</code> 并无拷贝，最后应该将 <code>dest[i] = '\\0'</code>。</p>\n","prev":{"title":"指针与变量","link":"2024/指针与变量"},"next":{"title":"二维数组","link":"2024/二维数组"},"plink":"https://CHONG589.github.io/2024/字符串/","toc":[{"id":"概念","title":"概念","index":"1"},{"id":"字符串字面量-(字符串常量)","title":"字符串字面量 (字符串常量)","index":"2"},{"id":"初始化","title":"初始化","index":"3","children":[{"id":"使用字符串数组初始化","title":"使用字符串数组初始化","index":"3.1"},{"id":"使用指针指向字符串字面量初始化","title":"使用指针指向字符串字面量初始化","index":"3.2"},{"id":"动态内存分配","title":"动态内存分配","index":"3.3"}]},{"id":"字符串数组和指针","title":"字符串数组和指针","index":"4"},{"id":"注意问题","title":"注意问题","index":"5"},{"id":"实现自己的-memcpy。","title":"实现自己的 memcpy。","index":"6"},{"id":"memmove-实现","title":"memmove 实现","index":"7"},{"id":"strcpy-函数实现","title":"strcpy 函数实现","index":"8"},{"id":"strncpy-实现","title":"strncpy 实现","index":"9"}]}