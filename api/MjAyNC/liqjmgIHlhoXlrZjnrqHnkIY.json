{"title":"动态内存管理","date":"2024-02-05T08:40:25.000Z","date_formatted":{"ll":"2024年2月5日","L":"2024/02/05","MM-DD":"02-05"},"author":"Chong","thumbnail":"2024/动态内存管理/./thumb.png","link":"2024/动态内存管理","comments":true,"updated":"2024-02-05T16:06:26.823Z","content":"<p>在头文件 <code>#include &lt;stdlib.h&gt;</code> 中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *calloc (size_t nmemb, size_t size);   // 一个成员 size 大小空间，共分配给 nmemb 个成员</span><br><span class=\"line\">void *malloc (size_t size);</span><br><span class=\"line\">void free (void *ptr);</span><br><span class=\"line\">void *realloc (void *ptr, size_t size);     // 已分配的空间不够，重新分配 size 大小的空间(size 包含了原先的大小)</span><br></pre></td></tr></table></figure>\n<p><strong>原则：谁申请，谁释放</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    int *p = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    p = malloc (sizeof (int));      // 没必要这样 p = (int *)malloc (sizeof (int)); 加一个强制转换</span><br><span class=\"line\">                                    // void * 适合任何类型</span><br><span class=\"line\">    if (p == NULL) &#123;</span><br><span class=\"line\">        printf (&quot;malloc () error!&quot;);</span><br><span class=\"line\">        exit (1);                           // 分配失败，结束进程</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    *p = 11;</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;, *p);</span><br><span class=\"line\"></span><br><span class=\"line\">    free (p);                       // 释放空间                              </span><br><span class=\"line\"></span><br><span class=\"line\">    exit (0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>面试题</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void func (int *p, int n) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    p = malloc (n);</span><br><span class=\"line\">    if (p = NULL)</span><br><span class=\"line\">        exit (1);</span><br><span class=\"line\">    return ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    int num = 100;</span><br><span class=\"line\">    int *p = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    func (p, num);</span><br><span class=\"line\">    free (p);</span><br><span class=\"line\"></span><br><span class=\"line\">    exit (0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段程序的问题：main 中 p 指向了 NULL( NULL 在地址为 0 的位置)，然后传给形参，使 func 中的 p 也指向了 NULL ，即指向了地址为 0 的位置，然后 func 中为它的 p 分配了内存(计算机找到对应需要的连续空间，并把该空间的首地址给 func 中的 p)，这时其实两个 p 已经指向了不同的空间了(因为传参时形参是复制了一份实参的值，</p>\n<p>这里复制了指针的地址,使之也指向了 NULL,这时是两个指针，只不过是指向了同一个地址，但之后为另一个指针分配了空间，使 func 里的 p 指向了另一个空间)，在调用的函数运行完后，在该函数中的变量，指针变量会自动释放，因为这些变量只在该函数中存在，所以这样的话，func 中的 p 存的首地址就丢失了，但 func 里分配的空间</p>\n<p>又没释放，在 main 中释放的是一个空指针，这就导致了内存泄漏。</p>\n<p>改进方法：<br>\n第一种：采用二级指针</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void func (int **p, int n) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    *p = malloc (n);            // 这就相当于将分配内存的首地址给了 main 中的 p;</span><br><span class=\"line\">    if (p = NULL)</span><br><span class=\"line\">        exit (1);</span><br><span class=\"line\">    return ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    int num = 100;</span><br><span class=\"line\">    int *p = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    func (&amp;p, num);         // 传指针变量所在的地址</span><br><span class=\"line\">    free (p);</span><br><span class=\"line\"></span><br><span class=\"line\">    exit (0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二种方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *func (int *p, int n) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    p = malloc (n);</span><br><span class=\"line\">    if (p = NULL)</span><br><span class=\"line\">        exit (1);</span><br><span class=\"line\">    return p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    int num = 100;</span><br><span class=\"line\">    int *p = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    p = func (p, num);</span><br><span class=\"line\">    free (p);</span><br><span class=\"line\"></span><br><span class=\"line\">    exit (0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有关 free 的理解</p>\n<p>有时我们在已经释放的内存中再进行操作，如 free § 后，又进行 <code>*p = 123;</code>, 这是很严重的错误，因为这个空间很可能其他设备已经在使用。</p>\n<p>意识：在 free § 后，再 p = NULL;如果我们后面又对 p 进行了操作，程序会报段错误，这样就防止了污染其它空间。</p>\n","prev":{"title":"段错误","link":"2024/段错误"},"next":{"title":"构造类型","link":"2024/构造类型"},"plink":"https://CHONG589.github.io/2024/动态内存管理/","reward":true,"copyright":{"author":"Chong","link":"<a href=\"https://CHONG589.github.io/2024/动态内存管理/\" title=\"动态内存管理\">https://CHONG589.github.io/2024/动态内存管理/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}