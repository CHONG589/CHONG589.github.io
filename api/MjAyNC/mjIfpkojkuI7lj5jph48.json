{"title":"指针与变量","date":"2024-02-02T13:55:50.000Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"author":"Chong","thumbnail":"2024/指针与变量/./thumb.png","link":"2024/指针与变量","comments":true,"updated":"2024-12-25T08:18:22.000Z","content":"<h3 id=\"变量与地址\">变量与地址<a title=\"#变量与地址\" href=\"#变量与地址\"></a></h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> *p = &amp;i;</span><br></pre></td></tr></table></figure>\n<p><code>p</code> 就是一个指针变量，用来存放变量 <code>i</code> 的地址值，所以我们平常所说的定义一个指针指向一个值，其实就是定义一个指针变量来存放这个值的地址。</p>\n<p><code>int **q = &amp;p;</code></p>\n<p><code>p</code> 是一个指针变量，<code>q</code> 是用来存放指针变量 <code>p</code> 的地址值的变量，即定义时一个 <code>*</code> 指存放地址的变量，<code>**</code> 指是用来存放指针变量的地址的变量。要满足两边的类型相同。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> *p;</span><br><span class=\"line\"><span class=\"type\">float</span> *q;</span><br><span class=\"line\"><span class=\"type\">double</span> *d;</span><br><span class=\"line\"><span class=\"type\">char</span> *c;</span><br></pre></td></tr></table></figure>\n<p>不管定义的是什么类型的指针变量(即我们通常说的指针)，是几级的指针，以及定义的结构体类型的指针，其在某一个平台上所占的空间是确定的大小，在 64 位的机器上占 8 个字节。</p>\n<p>不同类型的指针，其在运算时，如 <code>*p</code> 在做取值运算时，若 <code>p</code> 为 <code>char</code> ，则取一个字节，<code>int</code> 时，则取四个字节，所以什么类型的数据，要对应什么类型的指针，不然在取值时取得的大小与实际不符。</p>\n<h3 id=\"指针与指针变量(上面也有解释)\">指针与指针变量(上面也有解释)<a title=\"#指针与指针变量(上面也有解释)\" href=\"#指针与指针变量(上面也有解释)\"></a></h3>\n<ul>\n<li>指针：就是一个地址，是常量，不会变的。</li>\n<li>指针变量：用来存放指针的变量，可以改变。</li>\n</ul>\n<p>我们常说的某指针指向谁，哪个指针又指向谁，是指改变指针变量的值</p>\n<h3 id=\"直接访问与间接访问\">直接访问与间接访问<a title=\"#直接访问与间接访问\" href=\"#直接访问与间接访问\"></a></h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> *p = &amp;i;    </span><br><span class=\"line\"><span class=\"type\">int</span> **q = &amp;p;</span><br><span class=\"line\"></span><br><span class=\"line\"> i --&gt; <span class=\"number\">1</span>                        q --&gt; <span class=\"number\">0x3000</span> --&gt; &amp;p</span><br><span class=\"line\">&amp;i --&gt; <span class=\"number\">0x2000</span>                   &amp;q --&gt; <span class=\"number\">0x4000</span> </span><br><span class=\"line\"> p --&gt; <span class=\"number\">0x2000</span>    --&gt; &amp;i         *q --&gt; *(&amp;p)  --&gt; &amp;i</span><br><span class=\"line\">&amp;p --&gt; <span class=\"number\">0x3000</span>                  **q --&gt; *(*q)  --&gt; *(&amp;i) --&gt; <span class=\"number\">1</span></span><br><span class=\"line\">*p --&gt; *(<span class=\"number\">0x2000</span>) --&gt; <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/2024/%E6%8C%87%E9%92%88%E4%B8%8E%E5%8F%98%E9%87%8F/1.jpg\" alt class=\"φcx\"></p>\n<h3 id=\"空指针与野指针\">空指针与野指针<a title=\"#空指针与野指针\" href=\"#空指针与野指针\"></a></h3>\n<ul>\n<li>野指针：int *p = 0x2000; 这种直接赋地址的形式，因为你不知道这块地址是否可用，通常很危险。</li>\n<li>空指针：int *p = NULL; NULL 即为位于地址 0 的位置，<strong>0 号地址不分配给任何进程</strong>，指针定义出来后暂时还不知道指向哪里时，则将它指向 NULL；</li>\n</ul>\n<h3 id=\"空类型\">空类型<a title=\"#空类型\" href=\"#空类型\"></a></h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> *q = <span class=\"literal\">NULL</span>;     </span><br></pre></td></tr></table></figure>\n<p>任何类型的指针值都能够把自己的值赋给 void *， void * 也能够把当前自己的值赋给任何类型的指针。当自己不知道要用到什么类型的值时使用。</p>\n<h3 id=\"定义与初始化的书写规则\">定义与初始化的书写规则<a title=\"#定义与初始化的书写规则\" href=\"#定义与初始化的书写规则\"></a></h3>\n<h3 id=\"指针运算\">指针运算<a title=\"#指针运算\" href=\"#指针运算\"></a></h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*     &amp;   关系运算   ++   --</span><br></pre></td></tr></table></figure>\n<p><code>*p++</code>：等同于：<code>*p;  p += 1;</code></p>\n<p><strong>解析:</strong> 但是，因为 ++ <strong>后置</strong>的时候，本身含义就是先运算后增加1（运算指的是<code>p++</code>作为一个整体与前面的 * 进行运算；增加 1 指的是 <code>p+1</code>），所以实际上 <code>*p++</code> 符号<strong>整体对外表现的值</strong>是 <code>*p</code> 的值，运算完成后 <code>p</code> 再加1.</p>\n<p><code>*++p</code>：等同于 <code>p += 1; *p;</code></p>\n<p><strong>解析：</strong> 由于 ++ 在 <code>p</code> 的前面，++ 前置的含义是，先 <code>p</code> 加1，得到一个新的 <code>p</code>（它的值是原来 <code>p</code> 的值加1）。然后这个新的 <code>p</code> 再与前面的 * 结合.</p>\n<h3 id=\"指针与数组\">指针与数组<a title=\"#指针与数组\" href=\"#指针与数组\"></a></h3>\n<h4 id=\"指针与一维数组\">指针与一维数组<a title=\"#指针与一维数组\" href=\"#指针与一维数组\"></a></h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a[<span class=\"number\">3</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> *p = a;</span><br><span class=\"line\"><span class=\"type\">int</span> i;</span><br></pre></td></tr></table></figure>\n<p><code>a[i] = *(a + i) = *(p + i) = p[i];</code> <code>&amp;a[i] = a + i = p + i = &amp;p[i];</code></p>\n<p>这样看来指针(指针变量)好像是等价于一维数组的，但是它们是不完全等价的，首先，<code>a</code> 是地址，是一个常量，<code>p</code> 是指针变量，是一个变量，<code>a++</code> 是不能运算的 (<code>a = a + 1</code>), 常量不能出现在运算符左边进行赋值操作，但 <code>p++</code> 可以。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p++    --&gt;  p = p + <span class=\"number\">1</span> --&gt; p 的指向已经改变</span><br><span class=\"line\">p + <span class=\"number\">1</span>  --&gt;  p 的指向未改变  </span><br></pre></td></tr></table></figure>\n<h4 id=\"指针与二维数组\">指针与二维数组<a title=\"#指针与二维数组\" href=\"#指针与二维数组\"></a></h4>\n<p><strong>二维数组结合指针的理解</strong></p>\n<p><code>a[i][j]</code> 相当于是数组名为 <code>a[i]</code>, 然后取第 j 个元素，即为 <code>a[i][j]</code>,用指针的形式表示为：<code>*(*(a + i) + j)</code>。 <br><br>\n<code>(a + i)</code> 是先按行移动指针，移动的 1 就是一行，即一行 j 个元素，移到第 i 行的首地址，此时 <code>(a + i)</code> 还只是 <code>a[i]</code> 的函数名（地址），即在第 i 个数组的函数名地址，要想取 <code>a[i]</code> 还要加一个 * 进行取值操作，结果为 <code>a[i]</code>（具体可参考<a href=\"https://chong589.github.io/2024/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84\" target=\"_blank\">二维数组的二次分配</a>）,而 <code>a[i]</code> 又为 <code>a[i][j]</code> 的函数名，即地址，<code>a[i] + j</code> 为 <code>a[i][j]</code> 的地址，* 取值后成为 <code>a[i][j]</code>。<br><br>\n<strong>二维数组的二次分配解析: 二维数组的行指针就是一个二级指针用于存储一级指针的地址，所以在分配行指针时大小就是一个指针变量的大小，它是存一级指针的地址。二维数组 a[i][j] 中，(a + i) 表示的就是取第 i 个二级指针变量里存的地址（就是一级指针的地址），而 *(a + i) 就是取一级指针里的内容，即变量的地址（为a[i]）</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a[<span class=\"number\">2</span>][<span class=\"number\">3</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> i, j;</span><br><span class=\"line\"><span class=\"type\">int</span> *p;</span><br></pre></td></tr></table></figure>\n<p><code>p = a</code> 是不允许的，因为 <code>p</code> 是在列指针上移动的，而 <code>a</code> 是在行指针上移动的，即 <code>p + 1</code> 和 <code>a + 1</code> 所表达的含义不一样，<code>a + 1</code> 是指加一行，<code>p + 1</code> 是加一个元素。<br><br>\n<code>p = *a</code> 即为 <code>*(a + 0)</code> 此种形式是可以的，此时 <code>*a</code> 取的是数组元素的地址,而不是存储元素地址的地址，使之在数组在列指针上移动，即每加 1 为一个元素大小。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = *a;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">6</span>; i++)</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>,p[i]);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>二维数组也可以用这种方式输出。</p>\n<h4 id=\"指针与字符数组\">指针与字符数组<a title=\"#指针与字符数组\" href=\"#指针与字符数组\"></a></h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">10</span>] = &#123;<span class=\"string\">&quot;hello world&quot;</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">char</span> *s; s = <span class=\"string\">&quot;china&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>C 语言中编译器会给字符串常量分配地址，如 <code>&quot;china&quot;</code>，存储在内存中的 <code>0x3000, 0x3001, 0x3002, 0x3003, 0x3004, 0x3005</code>;<br><br>\n字符串常量的本质表现是代表它的第一个字符的地址，即 <code>0x3000</code>; 所以 <code>s = &quot;china&quot;</code> 是可以的，此操作相当于 <code>s = &quot;china&quot; = 0x3000</code>; 但是 <code>str = &quot;hello world&quot;</code> 是不允许的，str 是地址常量，不能赋给它。<code>s</code> 是指针变量，存了字符串的首地址，而 <code>str</code> 是一个数组，分配了内存空间的，内存分配了后，空间地址就固定在那里了，那里有你需要的空间大小，你要用就把值存到那里去，而 <code>str = &quot;hello world&quot;</code>这样做是在改变数组地址，数组地址分配了就固定了，不能改变。<br><br>\n所以 <code>printf(&quot;%s&quot;,s);</code> 是通过字符串首地址输出字符串，因为字符串在内存中是连续存放的，遇到 \\0 结束。其实它与 <code>printf(&quot;%s&quot;,0x3000);</code> 是等效的，前者是用了一个指针变量存储 <code>0x3000</code>, 后者是直接用地址，后者与 <code>printf(&quot;%s&quot;,str)</code> 等价，<code>str</code>就是将数组首元素的地址给它，然后通过首地址输出字符串。因为 <code>str</code> 就是地址常量，则可以 <code>s = str</code>, 但不能 <code>str = s</code>;<br><br>\n因为 s 为指针变量，本身就是可以存地址的，将 str 的地址赋给 s 就是将数组 str[] 的首地址给指针 s。 而 <code>str = s</code> , str 在定义的时候就已经分配了地址空间，即首地址是已经固定了的，而 <code>str = s</code> 这样是在改变它的地址了，肯定不可能。<br><br>\n<code>char *s = &quot;china&quot;;</code> 的本质是一个指针变量，只占八个字节(64位机器中)，用来保存第一个字符的地址(str 就是一个地址)，它可以用 <code>printf(&quot;%c&quot;,s[i]);</code> 逐个输出字符，或 <code>printf(&quot;%c&quot;,*s++);</code> <code>s[i]</code> 就是 <code>*(s + i)</code>；例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[] = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d\\n&quot;</span>,<span class=\"keyword\">sizeof</span>(str),<span class=\"built_in\">strlen</span>(str));</span><br><span class=\"line\"><span class=\"built_in\">strcpy</span>(str,<span class=\"string\">&quot;world&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">puts</span>(str);</span><br></pre></td></tr></table></figure>\n<p><code>sizeof(str)</code>为 6 字节，<code>strlen(str)</code> 为 5 字节，而<code>puts(str)</code>输出为 world,正确输出。<strong>strcpy 是将 world 复制到常量地址 str 开头的地址空间中, 即将 world 复制到分配的数组空间中 ，str 的地址是不变的，只是变的是里面的内容</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> *s = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d\\n&quot;</span>,<span class=\"keyword\">sizeof</span>(s),<span class=\"built_in\">strlen</span>(s));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">strcpy</span>(s,<span class=\"string\">&quot;world&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">puts</span>(s);</span><br></pre></td></tr></table></figure>\n<p>这段程序会报段错误（Segmentation Fault），为什么数组 str 不会，而用指针 s 就会，这就要理解内存分配的问题了，要使用内存，必须先分配了才能使用。<br><br>\n定义了指针要为其分配内存才能使用，我们平时直接指向变量、数组等，好像并没有分配内存也直接用了，其实你在定义变量、数组后，已经为变量，数组分配了空间，你让指针指向它们，是可以直接使用的。<br><br>\n而字符串常量 “hello” 赋给指针的本质是将字符串所在的空间的首地址给指针，指针变量只存了首地址，只为指针变量分配了空间，这个空间就只能存一个地址，根本就不能存存复制过来的字符串。但是用 <code>char str[] = &quot;hello&quot;;</code>,定义数组时就已经为数组分配了空间了。所以用数组不会报错。<br><br>\n通过 strcpy 的源码可知</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//返回char*的原因是 可以在其他函数中直接调用。</span></span><br><span class=\"line\"><span class=\"comment\">// 源字符串参数用const修饰，防止修改源字符串 </span></span><br><span class=\"line\"><span class=\"type\">char</span> * <span class=\"title function_\">strcpy</span><span class=\"params\">(<span class=\"type\">char</span> *dst,<span class=\"type\">const</span> <span class=\"type\">char</span> *src)</span> &#123;   </span><br><span class=\"line\">\t<span class=\"comment\">// 检查指针的有效性</span></span><br><span class=\"line\">\tassert(dst != <span class=\"literal\">NULL</span> &amp;&amp; src != <span class=\"literal\">NULL</span>);               </span><br><span class=\"line\">\t<span class=\"comment\">// 记下dst的初始地址防止找不到</span></span><br><span class=\"line\">\t<span class=\"type\">char</span> *ret = dst;                                </span><br><span class=\"line\">\t<span class=\"comment\">// 将src中所有字符(包括&#x27;\\0&#x27;)一个字符一个字符的拷贝到dst(包括&#x27;\\0&#x27;)。在赋值完</span></span><br><span class=\"line\">\t<span class=\"comment\">// &#x27;\\0&#x27;后，循环停止</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((*dst++=*src++)!=<span class=\"string\">&#x27;\\0&#x27;</span>);                  </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>观察可知，在复制的过程中，<code>dst++</code> 会移动，即 <code>s++</code> ，而又没有为指针 <code>s</code> 分配内存，你这样做是访问未分配给你的内存，自然就报段错误。</p>\n<h3 id=\"const-与-指针\">const 与 指针<a title=\"#const-与-指针\" href=\"#const-与-指针\"></a></h3>\n<h4 id=\"const-的概念\">const 的概念<a title=\"#const-的概念\" href=\"#const-的概念\"></a></h4>\n<p>const 关键字是一种修饰符。所谓“修饰符”，就是在编译器进行编译的过程中，给编译器一些“要求”或“提示”，但修饰符本身，并不产生任何实际代码。就 const 修饰符而言，它用来告诉编译器，被修饰的这些东西，具有“只读”的特点。在编译的过程中，一旦我们的代码试图去改变这些东西，编译器就应该给出错误提示。</p>\n<h4 id=\"与-define-的区别\">与 define 的区别<a title=\"#与-define-的区别\" href=\"#与-define-的区别\"></a></h4>\n<p>define 定义的对象<strong>没有数据类型</strong>，编译器只能机械地进行字符替换，没有类型安全检查，即会出现“边际问题”或者是“括号问题”。而 const 定义的是变量，有数据类型。如：我们想要这样定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PI 3.14</span></span><br></pre></td></tr></table></figure>\n<p>但是我们不小心写成了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PI sdlkf</span></span><br></pre></td></tr></table></figure>\n<p>编译器也不会报错，而是编译时直接用该值替换，如果用 const 则不会，它本身就是变量，有数据类型，会进行安全检查，sdlkf 是 char ，而 3.14 为 float ，这样编译器就会报错。同样，define 还会出现括号问题,所以 const 既有变量的优点，又有 define 的优点。</p>\n<h4 id=\"const-变量\">const 变量<a title=\"#const-变量\" href=\"#const-变量\"></a></h4>\n<p>const 变量指的是，此变量的值是只读的，不应该被改变。如果我们在程序中试图修改 const 变量的值，在编译的时候，编译器将给出错误提示(即在代码中出现赋值给 const 变量的语句)。正因为 const 变量的值在给定以后不能改变，所以 <strong>const 变量必须被初始化</strong>。（如果不初始化，之后还怎么赋值呢？）如果我们不初始化 const 变量，编译时也会有错误提示。</p>\n<p>定义形式：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> a;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"type\">const</span> a;</span><br></pre></td></tr></table></figure>\n<p>这两种定义方式都是可以的，但是记得一定要初始化。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">float</span> pi = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"type\">float</span> *p = &amp;pi;</span><br><span class=\"line\">*p = <span class=\"number\">3.14159</span>;</span><br></pre></td></tr></table></figure>\n<p>这样通过指针来改变 pi 的值编译器可以通过，但是这样也是非常危险的。会出现警告：初始化丢弃了指针目标类型的限定。正确的做法应该为 <code>const float *p = &amp;pi;</code>,即指向 const 变量的指针也应该定义成 const 类型。所以说 const 变量也不是不可以改变的。即不通过改变量来修改值，而是通过指针间接修改。</p>\n<h4 id=\"常量指针\">常量指针<a title=\"#常量指针\" href=\"#常量指针\"></a></h4>\n<p>常量指针是指针指向的内容是常量</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> *p;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"type\">const</span> *p;</span><br></pre></td></tr></table></figure>\n<p>可以结合以下方法记忆</p>\n<p><code>int *p;</code> 为整型指针，是指向整型的指针，自然 <code>const int *p</code> 就为指向常量的指针。</p>\n<p>常量指针说的是<strong>不能通过这个指针改变变量的值</strong>，但可以通过其他的引用来改变变量的值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> cnt = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span>* num = &amp;cnt;</span><br><span class=\"line\">cnt=<span class=\"number\">6</span>;</span><br></pre></td></tr></table></figure>\n<p>即不能 <code>*num = 6;</code> 这样改变值，但可以 <code>cnt = 6;</code>来改变。如果 cnt 也加上 const 来限定就不可以这样来改了。</p>\n<p>所以要想不改变一个变量的值，应该这样：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">float</span> pi = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">float</span> *p = &amp;pi;</span><br></pre></td></tr></table></figure>\n<p>这样无论是用指针 p 还是用变量 pi 都无法修改 pi 的值。常量指针指向<strong>地址中保存的值不能改变</strong>，但是<strong>指向的地址可以改变</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> cnt = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> tmp = <span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span>* num = &amp;cnt;</span><br><span class=\"line\">num = &amp;tmp;</span><br></pre></td></tr></table></figure>\n<p>联想记忆：可以想象成它定义的是 *p ,而它表示指针指向的值，则表示值不能改变。</p>\n<h4 id=\"指针常量\">指针常量<a title=\"#指针常量\" href=\"#指针常量\"></a></h4>\n<p>指针常量是指指针本身是个常量，不能再指向其他的地址，写法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> *<span class=\"type\">const</span> p;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> *<span class=\"type\">const</span> p;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，指针常量指向的<strong>地址不能改变</strong>，但是<strong>地址中保存的数值是可以改变</strong>的，可以通过其他指向该地址的指针来修改。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> cnt = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> *tmp = &amp;cnt;</span><br><span class=\"line\"><span class=\"type\">int</span>* <span class=\"type\">const</span> num = &amp;cnt;</span><br><span class=\"line\">*tmp = <span class=\"number\">6</span>;</span><br></pre></td></tr></table></figure>\n<p>直接用 *num = 6; 也可以修改。 联想记忆：它定义的是 p ，表示一个地址，则为指向的地址不能改变。</p>\n<h4 id=\"指向常量的常指针\">指向常量的常指针<a title=\"#指向常量的常指针\" href=\"#指向常量的常指针\"></a></h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const int *const p;</span><br></pre></td></tr></table></figure>\n<p>这相当于是常量指针与指针常量的结合，指针<strong>指向的位置</strong>不能改变并且也<strong>不能通过这个指针改变变量的值</strong>。</p>\n<h3 id=\"指针数组与数组指针(工作常用，指针函数、数组指针)\">指针数组与数组指针(工作常用，指针函数、数组指针)<a title=\"#指针数组与数组指针(工作常用，指针函数、数组指针)\" href=\"#指针数组与数组指针(工作常用，指针函数、数组指针)\"></a></h3>\n<h4 id=\"数组指针\">数组指针<a title=\"#数组指针\" href=\"#数组指针\"></a></h4>\n<p>像整型指针为指向整型的指针，而数组指针则为指向数组的指针。</p>\n<p>【存储类型】 数据类型  (*指针名)【下标】  = 值</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> (*p)[<span class=\"number\">3</span>]; --&gt; type name; --&gt; <span class=\"type\">int</span>[<span class=\"number\">3</span>] *p;</span><br></pre></td></tr></table></figure>\n<p><code>type</code> 可以是 <code>int char double</code>,以及结构体类型，上面这种为数组类型。<code>int *p</code>; <code>p</code> 每加一，移动一个 <code>int</code> 大小，而 <code>int (*p)[3]</code>即<code>int[3] *p</code>移动三个 int 大小。是数组间移动。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a[<span class=\"number\">2</span>][<span class=\"number\">3</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> i,j;</span><br><span class=\"line\"><span class=\"type\">int</span> *p = *a;</span><br><span class=\"line\"><span class=\"type\">int</span> (*q)[<span class=\"number\">3</span>] = a;</span><br></pre></td></tr></table></figure>\n<p>这种形式定义的 q 每加一，和 a 加一是一样的，q 加一，移动三个 int型元素大小，和二维数组的行指针一样。但要注意<strong>区别</strong>：a 是常量，q 是变量。<strong>二维数组的本质就是一个数组指针</strong>。</p>\n<p>【存储类型】 数据类型  * 数组名【下标】  = 值；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> * arr[<span class=\"number\">3</span>];  --&gt;  TYPE NAME;</span><br></pre></td></tr></table></figure>\n<h3 id=\"多级指针\">多级指针<a title=\"#多级指针\" href=\"#多级指针\"></a></h3>\n","prev":{"title":"函数","link":"2024/函数"},"next":{"title":"二维数组","link":"2024/二维数组"},"plink":"https://CHONG589.github.io/2024/指针与变量/"}