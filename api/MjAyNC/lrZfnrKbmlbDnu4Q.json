{"title":"字符数组","date":"2024-02-02T13:50:00.000Z","date_formatted":{"ll":"2024年2月2日","L":"2024/02/02","MM-DD":"02-02"},"author":"Chong","thumbnail":"2024/字符数组/./thumb.png","link":"2024/字符数组","comments":true,"updated":"2024-02-15T10:34:03.584Z","content":"<h3 id=\"字符数组\">字符数组<a title=\"#字符数组\" href=\"#字符数组\"></a></h3>\n<h4 id=\"1.-初始化\">1. 初始化<a title=\"#1.-初始化\" href=\"#1.-初始化\"></a></h4>\n<h5 id=\"（1）单个字符初始化\">（1）单个字符初始化<a title=\"#（1）单个字符初始化\" href=\"#（1）单个字符初始化\"></a></h5>\n<p><code>char str[N] = &#123;'a','b','c'&#125;;</code></p>\n<h5 id=\"（2）字符串常量初始化\">（2）字符串常量初始化<a title=\"#（2）字符串常量初始化\" href=\"#（2）字符串常量初始化\"></a></h5>\n<ul>\n<li>\n<p><code>char str[N] = &quot;a&quot;;</code><br>\n这个要区别于一般的数组，虽然这里只有 “a” 一个字符，但是它占用了两块空间，末尾还有一个 \\0,表示结束标志(这个是只有字符数组才有’\\0’，像整型数组等是没有的)。所以即使你在输出时想输出 3 个字符，但它遇到 \\0 会自动结束。例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(int i = 0; i &lt; 3; i++)</span><br><span class=\"line\">  printf(&quot;%c&quot;,str[i]);</span><br></pre></td></tr></table></figure>\n<p>这时只会输出一个字符 ‘a’。</p>\n</li>\n<li>\n<p>在用 gets(str) 连续输入字符串时，也会出现和用 <code>scanf(&quot;%s&quot;,   str)</code> 一样的问题，即使输入的大小大于数组的大小时，也不会报错，会导致<strong>越界</strong>。并且它会自动在输入结束后加 \\0。<br>\n字符数组在初始化时只有在定义时才可以<code>char str[N] = &quot;hello&quot;;</code>而在定义完后，不能单独这样赋初值：<code>str = &quot;hello&quot;;</code>, str 表示地址，是一个常量，不能给常量赋值。</p>\n</li>\n</ul>\n<h4 id=\"2.-相关的函数\">2. 相关的函数<a title=\"#2.-相关的函数\" href=\"#2.-相关的函数\"></a></h4>\n<p>包含在 <code>#include &lt;string.h&gt;</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*strlen &amp; sizeof</span><br><span class=\"line\"> *strcpy &amp; strncpy</span><br><span class=\"line\"> *strcat &amp; strncat</span><br><span class=\"line\"> *strcmp &amp; strncmp</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>strlen 计算的长度不包含 ‘\\0’。</p>\n</li>\n<li>\n<p>sizeof 计算的是在内存中真正所占的字节数，即包含 ‘\\0’。<br>\n<code>char str[] = &quot;hello\\0abc&quot;;</code></p>\n</li>\n</ul>\n<p>用strlen(str) 所得出的结果是 5 个字节，而用 sizeof(str) 得出的结果是 10 个字节。</p>\n<ul>\n<li>\n<p>strcpy()<br>\n不能用 <code>str = &quot;hello&quot;;</code>这样赋值，但可用 strcpy(),复制以 '\\0’作为结束标志。接收拷贝值的容器必须有足够大小装拷贝的值。<br>\n<code>strcpy(str,&quot;abcde&quot;);</code></p>\n</li>\n<li>\n<p>strncpy()<br>\n防止目标接收容器不够大的情况<br>\n<code>char *strncpy(char *dest,const char *src,size_t n);</code><br>\nn 的大小一般设置成 dest 的大小减一。</p>\n</li>\n<li>\n<p>strcat() 连接</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char str[] = &quot;hello&quot;;</span><br><span class=\"line\">strcat(str,&quot; &quot;);</span><br><span class=\"line\">strcat(str,&quot;world!&quot;);</span><br><span class=\"line\">puts(str);</span><br></pre></td></tr></table></figure>\n<p>输出结构：hello world!</p>\n</li>\n<li>\n<p>strcpm() 比较的是 <strong>ASCII</strong><br>\n<code>int strcpm(const char *s1,const char *s2);</code><br>\ns1 == s2,返回为 0<br>\ns1 &lt; s2,返回为负值<br>\ns1 &gt; s2,返回正值<br>\n可以用 s1 - s2 理解</p>\n</li>\n</ul>\n<h4 id=\"3.-练习\">3. 练习<a title=\"#3.-练习\" href=\"#3.-练习\"></a></h4>\n<p>（1）单词计数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 单词间的间隔形式</span><br><span class=\"line\">// sldk   sdfasdf           fasldjf          asdlkfj</span><br><span class=\"line\">// sldkjf                       fasldjkf</span><br><span class=\"line\"></span><br><span class=\"line\">// 分隔符的后面是一个字母表示这是一个单词新开始的位置，</span><br><span class=\"line\">// 某一个字母的前面不是分隔符表示位于单词内部，不去计数。</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    char str[128];</span><br><span class=\"line\">    int count = 0;</span><br><span class=\"line\">    int flag = 0;                           // 标记前一个是否为一个字母</span><br><span class=\"line\"></span><br><span class=\"line\">    gets(str);                              // gets 遇到分隔符不会结束输入，scanf 的 %s 才会</span><br><span class=\"line\"></span><br><span class=\"line\">    for(int i = 0; str[i] != &#x27;\\0&#x27;; i++)&#123;</span><br><span class=\"line\">        if(str[i] == &#x27; &#x27;)                   // 表示当前字符为分隔符</span><br><span class=\"line\">            flag = 0;                       // 当前字符为分隔符，不是字母，flag 置0</span><br><span class=\"line\">        else                                // 当前字符为字母</span><br><span class=\"line\">            if(flag = 0)&#123;                   // 且前一个字符为分隔符，count++,将 flag = 1</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">                flag = 1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;count = %d\\n&quot;,count);</span><br><span class=\"line\"></span><br><span class=\"line\">    exit(0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","prev":{"title":"指针与变量","link":"2024/指针与变量"},"next":{"title":"二维数组","link":"2024/二维数组"},"plink":"https://CHONG589.github.io/2024/字符数组/","reward":true,"copyright":{"author":"Chong","link":"<a href=\"https://CHONG589.github.io/2024/字符数组/\" title=\"字符数组\">https://CHONG589.github.io/2024/字符数组/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}