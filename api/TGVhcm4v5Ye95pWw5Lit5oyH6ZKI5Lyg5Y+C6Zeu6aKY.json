{"title":"函数中指针传参问题","date":"2024-02-16T07:51:58.000Z","date_formatted":{"ll":"2024年2月16日","L":"2024/02/16","MM-DD":"02-16"},"updated":"2024-02-16T08:00:38.529Z","content":"<p>在函数中进行指针传参时，尤其要注意指针传过去后，在函数里的操作是不是在本指针下进行，有可能是在指针的复制品中进行的，函数执行完后，把里面的变量等被销毁，这样就相当于对传过来的指针什么操作都没有做。</p>\n<span id=\"more\"></span>\n<p>下面有几个关于这个的例子</p>\n<p>例一：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void func (int **p, int n) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    *p = malloc (n);            // 这就相当于将分配内存的首地址给了 main 中的 p;</span><br><span class=\"line\">    if (p = NULL)</span><br><span class=\"line\">        exit (1);</span><br><span class=\"line\">    return ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    int num = 100;</span><br><span class=\"line\">    int *p = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    func (&amp;p, num);         // 传指针变量所在的地址</span><br><span class=\"line\">    free (p);</span><br><span class=\"line\"></span><br><span class=\"line\">    exit (0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>例二：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void sqlist_create1 (sqlist **ptr) &#123;</span><br><span class=\"line\">    *ptr = malloc (sizeof (**ptr));</span><br><span class=\"line\"></span><br><span class=\"line\">    if (*ptr == NULL)</span><br><span class=\"line\">        return ;</span><br><span class=\"line\">    </span><br><span class=\"line\">    (*ptr) -&gt; last = -1;</span><br><span class=\"line\">    return ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sqlist *list = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    datatype arr[] = &#123;12, 23, 34, 45, 56&#125;;</span><br><span class=\"line\">    datatype arr1[] = &#123;78, 89, 56, 23, 10&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    sqlist_create (&amp;list);</span><br><span class=\"line\">    if (list == NULL) &#123;</span><br><span class=\"line\">        fprintf (stderr, &quot;sqlist_create () failed!\\n&quot;);</span><br><span class=\"line\">        exit (1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n<p>例三：</p>\n<p>有头节点的链表创造</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list *list_create () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    list *me;</span><br><span class=\"line\"></span><br><span class=\"line\">    me = malloc (sizeof (*me));</span><br><span class=\"line\">    if (me == NULL)</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    me -&gt; next = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    return me;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从这里可知，无论是有头节点还是无头节点，在创造链表的函数中，都有这个问题，要么是要把函数里创造好的链表传回来，要么就是用二级指针传参过去，即当在 main 函数中定义了一个指针后，不能只是这样将一个空指针传过去，这样只会是在函数中复制一个复制品，用二级指针则意味着是操作的就是这个指针。<strong>即指针为空时，要注意传参问题</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 注意：在操作无头节点时，函数的传参形式尤其要注意，比如在这里，me 是有可能被 free () 掉的，如果</span><br><span class=\"line\">// 最后，没将 me = q; me 就会丢失掉（即链表丢失），main 函数里调用 show 就会出现段错误，因为 me </span><br><span class=\"line\">// 已经被释放掉，你再访问就段错误了。而带头节点的就不会有此类问题，因为头指针一直都是指着头节点的，</span><br><span class=\"line\">// 而头节点无论怎么样都不会被释放掉或者是改变，在操作时会跳过头节点操作。</span><br><span class=\"line\"></span><br><span class=\"line\">node_st *jose_kill (node_st *me, int n) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    node_st *p, *q = me;</span><br><span class=\"line\">    int i;</span><br><span class=\"line\">    </span><br><span class=\"line\">    while (q -&gt; next != q) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (i = 1; i &lt; n; i++) &#123;</span><br><span class=\"line\">            p = q;</span><br><span class=\"line\">            q = q -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        printf (&quot;delete: %d\\n&quot;, q -&gt; data);</span><br><span class=\"line\">        p -&gt; next = q -&gt; next;</span><br><span class=\"line\">        free (q);</span><br><span class=\"line\">        q = p -&gt; next;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    me = q;</span><br><span class=\"line\">    return me;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的问题就是在 kill 的过程中会把 me 指向的节点 free () 掉，要把 me 重新指向后返回来，至于为什么还要返回，是因为当 me free () 后， me 就相当于空指针，什么都没有，则在实参传过来的什么都没指向，而最后将 me = q; 对它操作同上面的原理一样，要返回来。</p>\n<p>而关于销毁链表的函数不用，一是因为在一个一个销毁的过程中也没丢失头指针的指向，二是因为最后返回来的本来就是什么都没有的，只要把指针指向的空间 free () 掉就行。</p>\n<p>对于有头节点的删除节点不会有这个问题，始终有头节点在那，而无头结点的删除可能要注意一下。</p>\n","link":"Learn/函数中指针传参问题","comments":true,"plink":"https://CHONG589.github.io/Learn/函数中指针传参问题/","reward":true,"copyright":{"published":"2024年2月16日","updated":"2024年2月16日","author":"Chong","link":"<a href=\"https://CHONG589.github.io/Learn/函数中指针传参问题/\" title=\"函数中指针传参问题\">https://CHONG589.github.io/Learn/函数中指针传参问题/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}