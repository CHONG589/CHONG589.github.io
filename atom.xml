<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chong&#39;s Blog</title>
  
  <subtitle>林深时见鹿,海蓝时见鲸。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chong589.github.io/"/>
  <updated>2025-04-10T08:00:47.894Z</updated>
  <id>https://chong589.github.io/</id>
  
  <author>
    <name>zch</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>函数中指针传参问题</title>
    <link href="https://chong589.github.io/2024/%E5%87%BD%E6%95%B0%E4%B8%AD%E6%8C%87%E9%92%88%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98/"/>
    <id>https://chong589.github.io/2024/%E5%87%BD%E6%95%B0%E4%B8%AD%E6%8C%87%E9%92%88%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98/</id>
    <published>2024-02-16T07:51:58.000Z</published>
    <updated>2025-04-10T08:00:47.894Z</updated>
    
    <content type="html"><![CDATA[<p>在函数中进行指针传参时，尤其要注意指针传过去后，在函数里的操作是不是在本指针下进行，有可能是在指针的复制品中进行的，函数执行完后，把里面的变量等被销毁，这样就相当于对传过来的指针什么操作都没有做。</p><span id="more"></span><p>下面有几个关于这个的例子</p><ul><li>例一：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span> <span class="params">(<span class="type">int</span> **p, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这就相当于将分配内存的首地址给了 main 中的 p;</span></span><br><span class="line">    *p = <span class="built_in">malloc</span> (n);            </span><br><span class="line">    <span class="keyword">if</span> (p = <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 传指针变量所在的地址</span></span><br><span class="line">    func (&amp;p, num);         </span><br><span class="line">    <span class="built_in">free</span> (p);</span><br><span class="line">    <span class="built_in">exit</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>例二：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sqlist_create1</span> <span class="params">(sqlist **ptr)</span> &#123;</span><br><span class="line">    *ptr = <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (**ptr));</span><br><span class="line">    <span class="keyword">if</span> (*ptr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;  </span><br><span class="line">    (*ptr) -&gt; last = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">sqlist *<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">datatype arr[] = &#123;<span class="number">12</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">45</span>, <span class="number">56</span>&#125;;</span><br><span class="line">datatype arr1[] = &#123;<span class="number">78</span>, <span class="number">89</span>, <span class="number">56</span>, <span class="number">23</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">sqlist_create (&amp;<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;sqlist_create () failed!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><ul><li>例三：</li></ul><p>有头节点的链表创造</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> *<span class="title function_">list_create</span> <span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span> *me;</span><br><span class="line">    me = <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (*me));</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    me -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> me;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可知，无论是有头节点还是无头节点，在创造链表的函数中，都有这个问题，要么是要把函数里创造好的链表传回来，要么就是用二级指针传参过去，即当在 main 函数中定义了一个指针后，不能只是这样将一个空指针传过去，这样只会是在函数中复制一个复制品，用二级指针则意味着是操作的就是这个指针。<strong>即指针为空时，要注意传参问题</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：在操作无头节点时，函数的传参形式尤其要注意，比如在这里，me 是有可能被 free () 掉的，</span></span><br><span class="line"><span class="comment">// 如果最后，没将 me = q; me 就会丢失掉（即链表丢失），main 函数里调用 show 就会出现段错误，</span></span><br><span class="line"><span class="comment">// 因为 me 已经被释放掉，你再访问就段错误了。而带头节点的就不会有此类问题，因为头指针一直都是</span></span><br><span class="line"><span class="comment">// 指着头节点的，而头节点无论怎么样都不会被释放掉或者是改变，在操作时会跳过头节点操作。</span></span><br><span class="line"></span><br><span class="line">node_st *<span class="title function_">jose_kill</span> <span class="params">(node_st *me, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    node_st *p, *q = me;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (q -&gt; next != q) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            p = q;</span><br><span class="line">            q = q -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;delete: %d\n&quot;</span>, q -&gt; data);</span><br><span class="line">        p -&gt; next = q -&gt; next;</span><br><span class="line">        <span class="built_in">free</span> (q);</span><br><span class="line">        q = p -&gt; next;     </span><br><span class="line">    &#125;</span><br><span class="line">    me = q;</span><br><span class="line">    <span class="keyword">return</span> me;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的问题就是在 kill 的过程中会把 me 指向的节点 free () 掉，要把 me 重新指向后返回来，至于为什么还要返回，是因为当 me free () 后， me 就相当于空指针，什么都没有，则在实参传过来的什么都没指向，而最后将 me = q; 对它操作同上面的原理一样，要返回来。</p><p>而关于销毁链表的函数不用，一是因为在一个一个销毁的过程中也没丢失头指针的指向，二是因为最后返回来的本来就是什么都没有的，只要把指针指向的空间 free () 掉就行。</p><p>对于有头节点的删除节点不会有这个问题，始终有头节点在那，而无头结点的删除可能要注意一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在函数中进行指针传参时，尤其要注意指针传过去后，在函数里的操作是不是在本指针下进行，有可能是在指针的复制品中进行的，函数执行完后，把里面的变量等被销毁，这样就相当于对传过来的指针什么操作都没有做。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>重定义 typedef</title>
    <link href="https://chong589.github.io/2024/%E9%87%8D%E5%AE%9A%E4%B9%89-typedef/"/>
    <id>https://chong589.github.io/2024/%E9%87%8D%E5%AE%9A%E4%B9%89-typedef/</id>
    <published>2024-02-06T06:36:57.000Z</published>
    <updated>2025-04-10T08:00:57.410Z</updated>
    
    <content type="html"><![CDATA[<h3 id="typedef-与-define-的区别">typedef 与 define 的区别<a title="#typedef-与-define-的区别" href="#typedef-与-define-的区别"></a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IP int *</span></span><br><span class="line">IP p, q;    --&gt; <span class="type">int</span> *p, q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> *IP;</span><br><span class="line">IP p, q;    --&gt; <span class="type">int</span> *p, *q;</span><br></pre></td></tr></table></figure><p>define 只是简单的替换，typedef 是由编译器执行解释的，<code>#define</code> 语句是由预编译器进行处理的。</p><h3 id="typedef-的本质">typedef 的本质<a title="#typedef-的本质" href="#typedef-的本质"></a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ARR[<span class="number">6</span>];         --&gt; <span class="type">int</span> [<span class="number">6</span>] -&gt; ARR;  <span class="comment">// int [6] 为数组的本质</span></span><br><span class="line"></span><br><span class="line">ARR a; --&gt; <span class="type">int</span> a[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="title function_">FUNC</span> <span class="params">(<span class="type">int</span>)</span>;     --&gt; <span class="type">int</span> (<span class="type">int</span>)   FUNC;</span><br><span class="line">FUNC f; --&gt; <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>)</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> *<span class="title function_">FUNCP</span> <span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">FUNC p; --&gt; <span class="type">int</span> *<span class="title function_">p</span> <span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;typedef-与-define-的区别&quot;&gt;typedef 与 define 的区别&lt;a title=&quot;#typedef-与-define-的区别&quot; href=&quot;#typedef-与-define-的区别&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;figure class=&quot;hig
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>段错误</title>
    <link href="https://chong589.github.io/2024/%E6%AE%B5%E9%94%99%E8%AF%AF/"/>
    <id>https://chong589.github.io/2024/%E6%AE%B5%E9%94%99%E8%AF%AF/</id>
    <published>2024-02-06T05:10:50.000Z</published>
    <updated>2025-04-10T08:00:34.820Z</updated>
    
    <content type="html"><![CDATA[<p>段错误（Segmentation Fault）是一种常见的运行时错误，通常发生在<strong>访问未分配的内存</strong>或者<strong>试图读写不允许访问的内存区域</strong>时。虽然段错误本身是一个简单的错误，但却可能导致程序不可预测的行为，甚至是崩溃，在Linux中也会导致许多软件无法正常运行。</p><span id="more"></span><h3 id="段错误的原因">段错误的原因<a title="#段错误的原因" href="#段错误的原因"></a></h3><h4 id="未分配的内存">未分配的内存<a title="#未分配的内存" href="#未分配的内存"></a></h4><p>当程序试图<strong>访问未经分配的内存</strong>区域时，会触发段错误。这可能是因为 <em>忘记分配内存</em> 或者 <em>试图访问已经释放的内存</em>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *ptr;</span><br><span class="line">*ptr = 10;      // 未分配内存</span><br></pre></td></tr></table></figure><p>定义了指针要为其分配内存才能使用，我们平时直接指向变量、数组等，好像并没有分配内存也直接用了，其实你在定义变量、数组后，已经为变量，数组分配了空间，你让指针指向它们，是可以直接使用的。</p><h4 id="内存越界">内存越界<a title="#内存越界" href="#内存越界"></a></h4><p>尝试访问数组或其他数据结构的超出边界的元素，导致访问了不允许访问的内存区域。</p><h4 id="空指针引用">空指针引用<a title="#空指针引用" href="#空指针引用"></a></h4><p>试图使用空指针访问内存中的数据，导致段错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *ptr = NULL;</span><br><span class="line">int value = *ptr; // 空指针引用，导致段错误</span><br></pre></td></tr></table></figure><p>还有在释放了内存后，通常将指针指向 NULL, 防止之后访问该指针，如果之后又访问了该指针就会报段错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main () &#123;</span><br><span class="line"></span><br><span class="line">    int *p = NULL;</span><br><span class="line"></span><br><span class="line">    p = malloc (sizeof (int));      </span><br><span class="line">    if (p == NULL) &#123;</span><br><span class="line">        printf (&quot;malloc () error!&quot;);</span><br><span class="line">        exit (1);                          </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *p = 11;</span><br><span class="line">    printf(&quot;%d\n&quot;, *p);</span><br><span class="line">    free (p);                       // 释放空间</span><br><span class="line">    p = NULL;                       // 防止后面访问                              </span><br><span class="line">    exit (0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈溢出">栈溢出<a title="#栈溢出" href="#栈溢出"></a></h4><p>当递归函数调用层级太深或者局部变量占用过多栈空间时，可能导致栈溢出，触发段错误。</p><h4 id="未初始化的指针">未初始化的指针<a title="#未初始化的指针" href="#未初始化的指针"></a></h4><p>使用未初始化的指针进行内存访问，会引发段错误。</p><h4 id="内存保护">内存保护<a title="#内存保护" href="#内存保护"></a></h4><p>一些操作系统或硬件平台会对某些内存区域进行保护，试图修改这些区域的内容会导致段错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>; <span class="comment">// 尝试修改只读内存，导致段错误</span></span><br></pre></td></tr></table></figure><h4 id="文件操作错误">文件操作错误<a title="#文件操作错误" href="#文件操作错误"></a></h4><p>尝试读写一个不可访问的文件或者试图操作不存在的文件也可能引发段错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;段错误（Segmentation Fault）是一种常见的运行时错误，通常发生在&lt;strong&gt;访问未分配的内存&lt;/strong&gt;或者&lt;strong&gt;试图读写不允许访问的内存区域&lt;/strong&gt;时。虽然段错误本身是一个简单的错误，但却可能导致程序不可预测的行为，甚至是崩溃，在Linux中也会导致许多软件无法正常运行。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>动态内存管理</title>
    <link href="https://chong589.github.io/2024/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://chong589.github.io/2024/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2024-02-05T08:40:25.000Z</published>
    <updated>2025-04-10T08:00:25.243Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内存分配相关函数">内存分配相关函数<a title="#内存分配相关函数" href="#内存分配相关函数"></a></h3><p>在头文件 <code>#include &lt;stdlib.h&gt;</code> 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 一个成员 size 大小空间，共分配给 nmemb 个成员</span><br><span class="line">void *calloc (size_t nmemb, size_t size);   </span><br><span class="line">void *malloc (size_t size);</span><br><span class="line">void free (void *ptr);</span><br><span class="line">// 已分配的空间不够，重新分配 size 大小的空间(size 包含了原先的大小)</span><br><span class="line">void *realloc (void *ptr, size_t size);     </span><br></pre></td></tr></table></figure><h3 id="原则：谁申请，谁释放">原则：谁申请，谁释放<a title="#原则：谁申请，谁释放" href="#原则：谁申请，谁释放"></a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line"></span><br><span class="line">    int *p = NULL;</span><br><span class="line"></span><br><span class="line">    // 没必要这样 p = (int *)malloc (sizeof (int)); 加一个强制转换</span><br><span class="line">    // void * 适合任何类型</span><br><span class="line">    p = malloc (sizeof (int));      </span><br><span class="line">    if (p == NULL) &#123;</span><br><span class="line">    // 分配失败，结束进程</span><br><span class="line">        printf (&quot;malloc () error!&quot;);</span><br><span class="line">        exit (1);                           </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *p = 11;</span><br><span class="line">    printf(&quot;%d\n&quot;, *p);</span><br><span class="line">    free (p);             </span><br><span class="line">    exit (0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关面试题">相关面试题<a title="#相关面试题" href="#相关面试题"></a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void func (int *p, int n) &#123;</span><br><span class="line"></span><br><span class="line">    p = malloc (n);</span><br><span class="line">    if (p = NULL)</span><br><span class="line">        exit (1);</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line"></span><br><span class="line">    int num = 100;</span><br><span class="line">    int *p = NULL;</span><br><span class="line">    func (p, num);</span><br><span class="line">    free (p);</span><br><span class="line"></span><br><span class="line">    exit (0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段程序的问题：</strong></p><p>main 中 p 指向了 NULL( NULL 在地址为 0 的位置)，然后传给形参，使 func 中的 p 也指向了 NULL ，即指向了地址为 0 的位置。</p><p>然后 func 中为它的 p 分配了内存(计算机找到对应需要的连续空间，并把该空间的首地址给 func 中的 p)，这时其实两个 p 已经指向了不同的空间了(因为传参时形参是复制了一份实参的值,这里复制了指针的地址,使之也指向了 NULL,这时是两个指针，只不过是指向了同一个地址，但之后为另一个指针分配了空间，使 func 里的 p 指向了另一个空间)。</p><p>在调用的函数运行完后，在该函数中的变量，指针变量会自动释放，因为这些变量只在该函数中存在，所以这样的话，func 中的 p 存的首地址就丢失了，但 func 里分配的空间。</p><p>又没释放，在 main 中释放的是一个空指针，这就导致了内存泄漏。</p><p>改进方法：</p><p>第一种：采用二级指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void func (int **p, int n) &#123;</span><br><span class="line"></span><br><span class="line">    *p = malloc (n);            // 这就相当于将分配内存的首地址给了 main 中的 p;</span><br><span class="line">    if (p = NULL)</span><br><span class="line">        exit (1);</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line"></span><br><span class="line">    int num = 100;</span><br><span class="line">    int *p = NULL;</span><br><span class="line"></span><br><span class="line">    func (&amp;p, num);         // 传指针变量所在的地址</span><br><span class="line">    free (p);</span><br><span class="line"></span><br><span class="line">    exit (0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void *func (int *p, int n) &#123;</span><br><span class="line"></span><br><span class="line">    p = malloc (n);</span><br><span class="line">    if (p = NULL)</span><br><span class="line">        exit (1);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line"></span><br><span class="line">    int num = 100;</span><br><span class="line">    int *p = NULL;</span><br><span class="line"></span><br><span class="line">    p = func (p, num);</span><br><span class="line">    free (p);</span><br><span class="line"></span><br><span class="line">    exit (0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关 free 的理解：</p><p>有时我们在已经释放的内存中再进行操作，如 free § 后，又进行 <code>*p = 123;</code>, 这是很严重的错误，因为这个空间很可能其他设备已经在使用。</p><p>意识：在 free § 后，再 p = NULL;如果我们后面又对 p 进行了操作，程序会报段错误，这样就防止了污染其它空间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;内存分配相关函数&quot;&gt;内存分配相关函数&lt;a title=&quot;#内存分配相关函数&quot; href=&quot;#内存分配相关函数&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在头文件 &lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/code&gt; 中&lt;/p&gt;
&lt;figure class
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>构造类型</title>
    <link href="https://chong589.github.io/2024/%E6%9E%84%E9%80%A0%E7%B1%BB%E5%9E%8B/"/>
    <id>https://chong589.github.io/2024/%E6%9E%84%E9%80%A0%E7%B1%BB%E5%9E%8B/</id>
    <published>2024-02-04T09:47:18.000Z</published>
    <updated>2024-12-25T07:07:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="结构体">结构体<a title="#结构体" href="#结构体"></a></h3><h4 id="产生及意义">产生及意义<a title="#产生及意义" href="#产生及意义"></a></h4><h4 id="类型描述(不占存储空间)，描述是怎样一个结构，是一个类型，如-int、char">类型描述(不占存储空间)，描述是怎样一个结构，是一个类型，如 int、char<a title="#类型描述(不占存储空间)，描述是怎样一个结构，是一个类型，如-int、char" href="#类型描述(不占存储空间)，描述是怎样一个结构，是一个类型，如-int、char"></a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct 结构体名 &#123;</span><br><span class="line">数组类型 成员1；</span><br><span class="line">数据类型 成员2；</span><br><span class="line">......  </span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h4 id="嵌套定义">嵌套定义<a title="#嵌套定义" href="#嵌套定义"></a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct birthday_st &#123;</span><br><span class="line">int year;</span><br><span class="line">int month;</span><br><span class="line">int day;</span><br><span class="line">&#125;;</span><br><span class="line">struct student_st &#123;</span><br><span class="line">int id;</span><br><span class="line">char name[NAMESIZE];</span><br><span class="line">struct birthday_st birth;</span><br><span class="line">int math;</span><br><span class="line">int chinese;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct student_st &#123;</span><br><span class="line">int id;</span><br><span class="line">char name[NAMESIZE];</span><br><span class="line">struct birthday_st &#123;</span><br><span class="line">int year;</span><br><span class="line">int month;</span><br><span class="line">int day;</span><br><span class="line">&#125;birth;</span><br><span class="line">int math;</span><br><span class="line">int chinese;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="定义变量(变量、数组、指针)、初始化及成员引用">定义变量(变量、数组、指针)、初始化及成员引用<a title="#定义变量(变量、数组、指针)、初始化及成员引用" href="#定义变量(变量、数组、指针)、初始化及成员引用"></a></h4><ul><li><p>成员引用：变量名.成员名<br>像上面 <code>struct birthday_st birth</code> 定义变量的方式，这个变量名 birth 存的只是结构体的<em>首地址</em>。</p></li><li><p>成员引用：指针 -&gt; 成员名 <code>(*指针).成员名</code></p></li></ul><h4 id="占用内存空间大小">占用内存空间大小<a title="#占用内存空间大小" href="#占用内存空间大小"></a></h4><p><em>内存对齐</em></p><h4 id="函数传参（值，地址）">函数传参（值，地址）<a title="#函数传参（值，地址）" href="#函数传参（值，地址）"></a></h4><p>一般不用结构体的值(即整个结构体)传参，因为当结构体里的成员很多时，定义形参时也要相对应的大小，内存开销大，所以我们一般传指针，形参只需定义指针即可，而指针变量大小在同一机器中时是固定。</p><h3 id="共用体">共用体<a title="#共用体" href="#共用体"></a></h3><h4 id="产生及意义-1">产生及意义<a title="#产生及意义-1" href="#产生及意义-1"></a></h4><p>共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是<strong>任何时候只能有一个成员带有值</strong>。共用体提供了一种使用相同的内存位置的有效方式。</p><h4 id="类型描述">类型描述<a title="#类型描述" href="#类型描述"></a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">union [union tag] &#123;</span><br><span class="line">member definition;</span><br><span class="line">member definition;</span><br><span class="line">...</span><br><span class="line">member definition;</span><br><span class="line">&#125; [one or more union variables];</span><br></pre></td></tr></table></figure><p>union tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。</p><h4 id="嵌套定义-1">嵌套定义<a title="#嵌套定义-1" href="#嵌套定义-1"></a></h4><p>练习：对一个具有 32 位值的高 16 位和低 16 位进行相加</p><ul><li>方法一：根据共用体和结构体的特性进行解决</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">union &#123;</span><br><span class="line">struct &#123;</span><br><span class="line">uint16_t i;</span><br><span class="line">uint16_t j;</span><br><span class="line">&#125;x;</span><br><span class="line">uint32_t y;</span><br><span class="line">&#125;a;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">a.y = 0x11223344;</span><br><span class="line">printf(&quot;%x&quot;, a.x.i + a.x.j);</span><br><span class="line">exit (0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二：用位运算解决</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">uint32_t i = 0x11223344;</span><br><span class="line">printf(&quot;%x\n&quot;, (i &gt;&gt; 16) + i &amp; 0xffff);</span><br><span class="line">exit (0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义变量（变量、数组、指针），初始化及成员引用">定义变量（变量、数组、指针），初始化及成员引用<a title="#定义变量（变量、数组、指针），初始化及成员引用" href="#定义变量（变量、数组、指针），初始化及成员引用"></a></h4><p>跟结构体一样</p><h4 id="占用内存空间大小-1">占用内存空间大小<a title="#占用内存空间大小-1" href="#占用内存空间大小-1"></a></h4><p><strong>共用体占用的内存应足够存储共用体中最大的成员</strong></p><h4 id="函数传参（值，地址）-1">函数传参（值，地址）<a title="#函数传参（值，地址）-1" href="#函数传参（值，地址）-1"></a></h4><h4 id="位域">位域<a title="#位域" href="#位域"></a></h4><p>C 语言的位域（bit-field）是一种特殊的结构体成员，允许我们按位对成员进行定义，指定其占用的位数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">int i;</span><br><span class="line">int j;</span><br><span class="line">&#125;a;</span><br></pre></td></tr></table></figure><p>这种结构需要 8 字节的内存空间，但在实际上，在每个变量中，我们只存储 0 或 1，在这种情况下，C 语言提供了一种更好的利用内存空间的方式。如果您在结构内使用这样的变量，您可以定义变量的宽度来告诉编译器，您将只使用这些字节。例如，上面的结构可以重写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">int i: 1;</span><br><span class="line">int j: 1;</span><br><span class="line">&#125;a;</span><br></pre></td></tr></table></figure><p>现在，上面的结构中，a 变量将占用 4 个字节的内存空间(内存对齐的原因)，但是只有 2 位被用来存储值。如果您用了 32 个变量，每一个变量宽度为 1 位，那么 a 结构将使用 4 个字节，但只要您再多用一个变量，如果使用了 33 个变量，那么它将分配内存的下一段来存储第 33 个变量，这个时候就开始使用 8 个字节。</p><h3 id="枚举">枚举<a title="#枚举" href="#枚举"></a></h3><p>枚举是 C 语言中的一种基本数据类型，用于定义一组具有离散值的常量，它可以让数据更简洁，更易读。枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性。</p><p>定义一个枚举类型，需要使用 enum 关键字，后面跟着枚举类型的名称，以及用大括号 {} 括起来的一组枚举常量。每个枚举常量可以用一个标识符来表示，也可以为它们指定一个整数值，如果没有指定，那么默认从 0 开始递增。枚举语法定义格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum　枚举名　&#123;</span><br><span class="line">    枚举元素1,枚举元素2,……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define MON  1</span><br><span class="line">#define TUE  2</span><br><span class="line">#define WED  3</span><br><span class="line">#define THU  4</span><br><span class="line">#define FRI  5</span><br><span class="line">#define SAT  6</span><br><span class="line">#define SUN  7</span><br></pre></td></tr></table></figure><p>这个看起来代码量就比较多，接下来我们看看使用枚举的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum DAY &#123;</span><br><span class="line">      MON=1, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。</p><p>可以用 enum 当成宏来使用，enum 在预处理后，里面的值不会替换，这样在查看哪里错的时候，这样才能更直观的知道这个变量是干嘛的，而不是被替换成了值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;结构体&quot;&gt;结构体&lt;a title=&quot;#结构体&quot; href=&quot;#结构体&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h4 id=&quot;产生及意义&quot;&gt;产生及意义&lt;a title=&quot;#产生及意义&quot; href=&quot;#产生及意义&quot;&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&quot;类型描述(不占存储空间)，描述是
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>函数</title>
    <link href="https://chong589.github.io/2024/%E5%87%BD%E6%95%B0/"/>
    <id>https://chong589.github.io/2024/%E5%87%BD%E6%95%B0/</id>
    <published>2024-02-02T14:01:05.000Z</published>
    <updated>2025-04-10T07:58:27.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义">定义<a title="#定义" href="#定义"></a></h1><blockquote><p>数据类型 函数名 (形参说明)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>argc 是一个计数器，计算从终端传了多少个参数过来。argv[] 是一个列表，用来保存传过来的参数。</p><h1 id="函数的传参">函数的传参<a title="#函数的传参" href="#函数的传参"></a></h1><ul><li>值传参</li><li>地址传参</li><li>全局变量</li></ul><h1 id="函数的调用">函数的调用<a title="#函数的调用" href="#函数的调用"></a></h1><h2 id="嵌套调用">嵌套调用<a title="#嵌套调用" href="#嵌套调用"></a></h2><h2 id="递归调用-(面试常考，非常考验编程功底)">递归调用 (面试常考，非常考验编程功底)<a title="#递归调用-(面试常考，非常考验编程功底)" href="#递归调用-(面试常考，非常考验编程功底)"></a></h2><h3 id="阶乘">阶乘<a title="#阶乘" href="#阶乘"></a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归出口</span></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> n * func (n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">res = func(n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d! = %d\n&quot;</span>,n,res);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="斐波那契数列">斐波那契数列<a title="#斐波那契数列" href="#斐波那契数列"></a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1, 1, 2, 3, 5, 8, 13, 21, 34......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//n = (n - 1) + (n - 2)</span></span><br><span class="line"><span class="comment">//(n == 1 || n == 2)  ---&gt;   return 1;  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入你要求的斐波那契数列的项数：\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">res = fib(n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fib[%d] = %d\n&quot;</span>,n,res);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数与数组">函数与数组<a title="#函数与数组" href="#函数与数组"></a></h1><h2 id="数组传参方式">数组传参方式<a title="#数组传参方式" href="#数组传参方式"></a></h2><p>传参时传的是数组的首地址，所以还要传数组的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_arr</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">print_arr(a, <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(*a));</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 print_arr 函数中，接收数组的是一个指针变量，也就是接收的是数组首地址，实际上这个函数是不知道数组的大小的，只知道数组首地址，而在定义函数时用 <code>sizeof(p) / sizeof(*p)</code> 是不可行的，sizeof§ 肯定是 8 字节 (在 64 位机器中)，这是固定的，这算出来的是接收地址的指针变量的大小，并不是数组的大小。所以在传参时要传数组的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_arr</span> <span class="params">(<span class="type">int</span> p[], <span class="type">int</span> n)</span></span><br></pre></td></tr></table></figure><p><strong>数组退化成指针</strong>：定义时这样写成数组的形式，看似好像是把整个数组传过去了，实则不然，它的含义仍然是指针变量，跟上面是一样的。</p><p>所以在形参中定义成数组的形式和在 main 函数中定义时是不一样的，作为形参时，它就是指针变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[N] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是传入实参时，形参对应接收的类型</span></span><br><span class="line">实参： a      *a     a[<span class="number">0</span>]    &amp;a[<span class="number">3</span>]    p[i]    p      *p       p+<span class="number">1</span></span><br><span class="line">   *(a+<span class="number">0</span>)           *(p+i)         *(p+<span class="number">0</span>)</span><br><span class="line">形参：<span class="type">int</span> *   <span class="type">int</span>    <span class="type">int</span>     <span class="type">int</span> *    <span class="type">int</span>     <span class="type">int</span>*   <span class="type">int</span>      <span class="type">int</span>*     </span><br></pre></td></tr></table></figure><h2 id="数组逆序实现">数组逆序实现<a title="#数组逆序实现" href="#数组逆序实现"></a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span> <span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span> i, j, tmp, mid;</span><br><span class="line"></span><br><span class="line">mid = (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= mid; i++)&#123;</span><br><span class="line">j = n - <span class="number">1</span> -i;</span><br><span class="line">tmp = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//puts(a);     puts 是用于输出 char * </span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(*a); i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">func(a, <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(*a));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(*a); i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数与二维数组">函数与二维数组<a title="#函数与二维数组" href="#函数与二维数组"></a></h2><h3 id="方式一：">方式一：<a title="#方式一：" href="#方式一："></a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M   3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N   4</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_arr</span> <span class="params">(<span class="type">int</span> *p, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果 print_arr 直接传 a，那么在形参中定义时是这样：int (*p)[N]。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a[M][N] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;</span><br><span class="line"></span><br><span class="line">print_arr(&amp;a[<span class="number">0</span>][<span class="number">0</span>], M * N);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里函数的形参采用的是一级指针接收，传入的实参不能直接传 a, a 为二维数组，为行指针，一级指针只能在列指针中移动，所以实参应转化为列指针 <code>&amp;a[0][0]</code> 传入, 把二维数组当成一个大的一维数组，个数为 <code>M * N</code> 。这里 <code>&amp;a[0][0]</code> 还可以为 <code>*a 、a[0]、*(a + 0)</code>。</p><h3 id="方式二：">方式二：<a title="#方式二：" href="#方式二："></a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M   3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N   4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组 a 的本质就是一个数组指针，指向数组的指针</span></span><br><span class="line"><span class="comment">//void print_arr(int p[][N], int m, int n)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_arr</span> <span class="params">(<span class="type">int</span> (*p)[N], <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;      </span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果为：8，所以也是一个指针变量，不过这个指向的是一个数组，数组大小为 N 个元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(p) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(p));   </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%4d &quot;</span>, *(*(p + i) + j)); </span><br><span class="line"><span class="comment">//printf(&quot;%4d &quot;, p[i][j]);     </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[M][N] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(a) = %d\n&quot;</span>,<span class="keyword">sizeof</span>(a));      <span class="comment">// 结果为 48</span></span><br><span class="line">print_arr(a, M, N);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想在实参中传入一个二维数组，而不是把它当成一维数组传入，那么在函数定义时的形参中要有与二维数组相对应的类型，前面已学过 <strong>二维数组的本质就是数组指针</strong>，所以要接收一个二维数组，就应该在形参中用数组指针接收，a + 1 和 p + 1 效果是一样的，都是行指针。<code>int (*p)[N]</code> 中 N 为二维数组的列数。将二维数组接收过来后，对应的行数和列数也接收过来了，接下来就跟平时处理二维数组时一样。</p><p>同样，跟一维数组一样，传过来的数组，接收的是首地址，同样不知道大小，所以还要传大小参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[M][N] = &#123;&#125;;</span><br><span class="line"><span class="type">int</span> *p = *a;</span><br><span class="line"><span class="type">int</span> (*q)[N] = a;</span><br><span class="line"></span><br><span class="line">实参：a[i][j]  *(a+i)+j   a[i]+j   p[i]   *p    q[i][j]    *q       q           p+<span class="number">3</span></span><br><span class="line">形参：<span class="type">int</span>       <span class="type">int</span>*       <span class="type">int</span>*    <span class="type">int</span>    <span class="type">int</span>    <span class="type">int</span>       <span class="type">int</span>*   <span class="title function_">int</span> <span class="params">(*)</span>[N]    <span class="type">int</span>*    </span><br></pre></td></tr></table></figure><h3 id="练习题">练习题<a title="#练习题" href="#练习题"></a></h3><h4 id="求每个学生的平均成绩">求每个学生的平均成绩<a title="#求每个学生的平均成绩" href="#求每个学生的平均成绩"></a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M   3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N   5</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_arr</span> <span class="params">(<span class="type">float</span> (*p)[N], <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;  科目一  科目二  科目三   科目四  平均\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%7.2f &quot;</span>, *(*(p + i) + j));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求每个学生的平均成绩，并把平均成绩写在后面</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">average</span> <span class="params">(<span class="type">float</span> (*p)[N], <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line"><span class="type">float</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">tmp += p[i][j]; </span><br><span class="line">&#125;</span><br><span class="line">p[i][<span class="number">4</span>] = tmp / (N - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> a[M][N] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">average(a, M, N);</span><br><span class="line">print_arr(a, M, N);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/%E5%87%BD%E6%95%B0/1.png" alt class="φcx"></p><h4 id="求总平均成绩和把指定学生的四科成绩打印出来">求总平均成绩和把指定学生的四科成绩打印出来<a title="#求总平均成绩和把指定学生的四科成绩打印出来" href="#求总平均成绩和把指定学生的四科成绩打印出来"></a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M   3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N   4</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">average_scope</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">sum += p[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum / n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find_num</span><span class="params">(<span class="type">int</span> (*p)[N], <span class="type">int</span> num)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(*(p + num) + i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[M][N] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">float</span> ave;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ave = average_scope(*a, M * N);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ave = %.2f\n&quot;</span>, ave);</span><br><span class="line"></span><br><span class="line">find_num(a, num);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数与字符数组">函数与字符数组<a title="#函数与字符数组" href="#函数与字符数组"></a></h2><p>[[05_字符串]]</p><h1 id="函数与指针">函数与指针<a title="#函数与指针" href="#函数与指针"></a></h1><h2 id="指针函数-(返回值为指针)">指针函数 (返回值为指针)<a title="#指针函数-(返回值为指针)" href="#指针函数-(返回值为指针)"></a></h2><p>根据 Type name 可知，指针函数是定义函数，所以为</p><blockquote><p>定义形式：返回值 函数名 (形参)  如：<code>int *fun (int)</code></p></blockquote><p>用途：例如前面 find_num 的实现，它只让你找到第几个学生的成绩，并没有让你输出，你却遍历输出那个学生的成绩，显然不是最完美的解决方案，这时就可以用返回一个指向函数的指针。</p><p>理论上的实现方式 (返回了整个数组)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*)[N] find_num (<span class="type">int</span> (*p)[N], <span class="type">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">return</span> (p + num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把指针 p 移动到第 num 的学生的位置，由于 p 为行指针，所以理论上要这样写返回值就也要为对应的类型，即也要行指针，所以返回值为 <code>int (*)[N]</code>，但是我们就只是想要得到第 num 行的那些数据，根本不需整个二维数组的形式返回来，只需在 num 行使用列指针即可，所以可以这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M   3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N   4</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * <span class="title function_">find_num</span> <span class="params">(<span class="type">int</span> (*p)[N], <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; M - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;       <span class="comment">// 不能写 -1，因为返回类型为指针</span></span><br><span class="line">    <span class="keyword">return</span> *(p + num);     <span class="comment">// 也可 p[num];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a[M][N] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *res;</span><br><span class="line"></span><br><span class="line">    res = find_num(a, num);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, res[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not find!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="函数指针">函数指针<a title="#函数指针" href="#函数指针"></a></h2><p>记忆：整型指针为指针指向整型，那么函数指针自然就是指向函数的指针。</p><p>根据 Type name 可知，函数指针是定义指针，所以为</p><blockquote><p>定义形式：<code>类型 (*指针名)(形参)</code>  如: `int (*p)(int);</p></blockquote><blockquote><p>类型：int (int) --&gt; 函数和形参的类型，即返回类型。<br>name:  <code>*p</code> ，即定义指针<br>两个合起来就为 <code>int (*p)(int);</code>，即函数指针。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> (*p) (<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    p = add;            <span class="comment">// 也可 p = &amp;add; 函数名跟数组名一样，就是个地址</span></span><br><span class="line">    <span class="comment">//ret = add(a, b);  // 原来的写法</span></span><br><span class="line">    ret = p(a, b);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ret);  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数指针数组">函数指针数组<a title="#函数指针数组" href="#函数指针数组"></a></h2><blockquote><p>指针数组：数组中每个元素就是一个指针，如：<code>int *arr[N]</code><br>函数指针：指向函数的指针，如：<code>int (*p)(int) </code><br>函数指针数组：数组中每个元素都是一个指向函数的指针</p></blockquote><p>可以理解为定义指针数组，返回值为一个函数，也可以理解为定义一个数组，返回值为函数指针。</p><blockquote><p>定义：类型 <code>(*数组名[下标])  (形参)</code> 如：<code>int (*arr[N]) (int);</code><br>类型：<code>int (int)</code> --&gt; 函数和形参的类型<br>name: <code>*arr[N] </code><br>两个合起来就为 <code>int (*arr[N])(int);</code></p></blockquote><h2 id="指向指针函数的函数指针数组">指向指针函数的函数指针数组<a title="#指向指针函数的函数指针数组" href="#指向指针函数的函数指针数组"></a></h2><p>这样理解：其实就是函数指针数组，只不过将这个返回值是函数改成返回值为指向函数的指针。</p><blockquote><p>指针数组：<code>*arr[N]</code><br>指针函数：<code>int *func(int)</code><br>将指针函数改为匿名函数，即 <code>int *(int)</code>，将它作为返回值，即：<code>int *(*arr[N])(int)</code></p></blockquote><h1 id="总结">总结<a title="#总结" href="#总结"></a></h1><p>自己的理解：为什么不能直接调用函数，而是特地定义指针来，因为函数名是地址常量，函数指针是指针变量，有区别，就跟前面学的指针变量跟数组名一样的区别。</p><p>老师讲解：传参时如果传一个函数名过去(因为可能要用到某函数，将此函数传过去用)，这时形参就要定义一个同类型的来接收。</p><blockquote><p>传整形数     ----&gt;    整型指针接收<br>传数组名     ----&gt;    指针接收<br>函数名         ----&gt;    指向函数的指针来接收</p></blockquote><p>如：快速排序的封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span> <span class="params">(<span class="type">void</span> *base, <span class="type">size_t</span> nmemb, <span class="type">size_t</span> size, <span class="type">int</span> (*compar) (<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span>;</span><br></pre></td></tr></table></figure><p>此方式定义为函数指针，返回值为函数，总之就是为了满足传参的要求，这些函数叫 <strong>回调函数</strong>。</p><blockquote><p><strong>数组指针</strong>：像整型指针为指向整型的指针，而数组指针则为指向数组的指针。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Type name</span><br><span class="line">Type ---&gt; 数组 ---&gt; <span class="type">int</span>[N]</span><br><span class="line">name ---&gt; 指针 ---&gt; *p</span><br><span class="line">Type name ---&gt; <span class="type">int</span> (*p)[N];</span><br></pre></td></tr></table></figure><blockquote><p><strong>指针数组</strong>：数组中每个元素就是一个指针。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Type ---&gt; <span class="type">int</span> *</span><br><span class="line">name ---&gt; arr[N]</span><br><span class="line">Type name ---&gt; <span class="type">int</span> *arr[N]</span><br></pre></td></tr></table></figure><blockquote><p><strong>指针函数</strong>：定义函数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值 函数名 （形参）</span><br><span class="line">返回值 ---&gt; <span class="type">int</span> *</span><br><span class="line">函数名 ---&gt; func</span><br><span class="line"><span class="type">int</span> *<span class="title function_">func</span><span class="params">(<span class="type">int</span>)</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>函数指针</strong>：指向函数的指针，定义指针</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Type name</span><br><span class="line">Type ---&gt; <span class="type">int</span> (<span class="type">int</span>)</span><br><span class="line">name ---&gt; *p</span><br><span class="line"><span class="title function_">int</span> <span class="params">(*p)</span> <span class="params">(<span class="type">int</span>)</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>函数指针数组</strong>：数组中每个元素都是一个指向函数的指针</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">指针数组：<span class="type">int</span> *arr[N]</span><br><span class="line">函数指针</span><br><span class="line">：<span class="type">int</span> (*p) (<span class="type">int</span>)</span><br><span class="line">只需将函数指针的指针名改为数组的形式就可</span><br><span class="line"><span class="type">int</span> (*arr[N])(<span class="type">int</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong>指向指针函数的函数指针数组</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *(*func[N])(<span class="type">int</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;定义&lt;a title=&quot;#定义&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;数据类型 函数名 (形参说明)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>指针与变量</title>
    <link href="https://chong589.github.io/2024/%E6%8C%87%E9%92%88%E4%B8%8E%E5%8F%98%E9%87%8F/"/>
    <id>https://chong589.github.io/2024/%E6%8C%87%E9%92%88%E4%B8%8E%E5%8F%98%E9%87%8F/</id>
    <published>2024-02-02T13:55:50.000Z</published>
    <updated>2025-04-10T07:59:20.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1.-变量与地址">1. 变量与地址<a title="#1.-变量与地址" href="#1.-变量与地址"></a></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;i;</span><br></pre></td></tr></table></figure><p>p 就是一个指针变量，用来存放变量 i 的地址值，所以我们平常所说的定义一个指针指向一个值，其实就是定义一个指针变量来存放这个值的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> **q = &amp;p;</span><br></pre></td></tr></table></figure><p>p 是一个指针变量，q 是用来存放指针变量 p 的地址值的变量，即定义时一个 <code>*</code> 指存放地址的变量，<code>**</code> 指是用来存放指针变量的地址的变量。要满足两边的类型相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">float</span> *q;</span><br><span class="line"><span class="type">double</span> *d;</span><br><span class="line"><span class="type">char</span> *c;</span><br></pre></td></tr></table></figure><p>不管定义的是什么类型的指针变量 (即我们通常说的指针)，是几级的指针，以及定义的结构体类型的指针，其在某一个平台上所占的空间是确定的大小，在 64 位的机器上占 8 个字节。</p><p>不同类型的指针，其在运算时，如 <code>*p</code> 在做取值运算时，若 p 为 char ，则取一个字节，int 时，则取四个字节，所以什么类型的数据，要对应什么类型的指针，不然在取值时取得的大小与实际不符。</p><h1 id="2.-指针与指针变量(上面也有解释)">2. 指针与指针变量(上面也有解释)<a title="#2.-指针与指针变量(上面也有解释)" href="#2.-指针与指针变量(上面也有解释)"></a></h1><blockquote><p>指针：就是一个地址，是常量，不会变的。<br>指针变量：用来存放指针的变量，可以改变。<br>我们常说的某指针指向谁，哪个指针又指向谁，是指改变指针变量的值。</p></blockquote><h1 id="3.-直接访问与间接访问">3. 直接访问与间接访问<a title="#3.-直接访问与间接访问" href="#3.-直接访问与间接访问"></a></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;i;    </span><br><span class="line"><span class="type">int</span> **q = &amp;p;</span><br><span class="line"></span><br><span class="line"> i --&gt; <span class="number">1</span>                        q --&gt; <span class="number">0x3000</span> --&gt; &amp;p</span><br><span class="line">&amp;i --&gt; <span class="number">0x2000</span>                   &amp;q --&gt; <span class="number">0x4000</span> </span><br><span class="line"> p --&gt; <span class="number">0x2000</span>    --&gt; &amp;i         *q --&gt; *(&amp;p)  --&gt; &amp;i</span><br><span class="line">&amp;p --&gt; <span class="number">0x3000</span>                  **q --&gt; *(*q)  --&gt; *(&amp;i) --&gt; <span class="number">1</span></span><br><span class="line">*p --&gt; *(<span class="number">0x2000</span>) --&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="/2024/%E6%8C%87%E9%92%88%E4%B8%8E%E5%8F%98%E9%87%8F/1.jpg" alt class="φcx"></p><h1 id="4.-空指针与野指针">4. 空指针与野指针<a title="#4.-空指针与野指针" href="#4.-空指针与野指针"></a></h1><blockquote><p>野指针：<code>int *p = 0x2000;</code> 这种直接赋地址的形式，因为你不知道这块地址是否可用，通常很危险。<br>空指针：<code>int *p = NULL;</code> NULL 即为位于地址 0 的位置，<strong>0 号地址不分配给任何进程</strong>，指针定义出来后暂时还不知道指向哪里时，则将它指向 NULL；</p></blockquote><h1 id="5.-空类型">5. 空类型<a title="#5.-空类型" href="#5.-空类型"></a></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *q = <span class="literal">NULL</span>;     </span><br></pre></td></tr></table></figure><blockquote><p>任何类型的指针值都能够把自己的值赋给 <code>void *</code>， <code>void *</code> 也能够把当前自己的值赋给任何类型的指针。当自己不知道要用到什么类型的值时使用。</p></blockquote><h1 id="6.-定义与初始化的书写规则">6. 定义与初始化的书写规则<a title="#6.-定义与初始化的书写规则" href="#6.-定义与初始化的书写规则"></a></h1><h1 id="7.-指针运算">7. 指针运算<a title="#7.-指针运算" href="#7.-指针运算"></a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*     &amp;   关系运算   ++   --</span><br></pre></td></tr></table></figure><p><code>*p++</code>：等同于：<code>*p;  p += 1;</code></p><p><strong>解析:</strong> 但是，因为 ++ <strong>后置</strong> 的时候，本身含义就是先运算后增加1（运算指的是 p++ 作为一个整体与前面的 <code>*</code> 进行运算；增加 1 指的是 p + 1），所以实际上 <code>*p++</code> 符号 <strong>整体对外表现的值</strong> 是 <code>*p</code> 的值，运算完成后  p 再加 1。</p><p><code>*++p</code>：等同于 <code>p += 1; *p;</code></p><p><strong>解析：</strong> 由于 ++ 在 <code>p</code> 的前面，++ 前置的含义是，先 p 加1，得到一个新的 p（它的值是原来 p 的值加1）。然后这个新的 p 再与前面的  <code>*</code> 结合。</p><h1 id="8.-指针与数组">8. 指针与数组<a title="#8.-指针与数组" href="#8.-指针与数组"></a></h1><h2 id="指针与一维数组">指针与一维数组<a title="#指针与一维数组" href="#指针与一维数组"></a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = a;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">a[i] = *(a + i) = *(p + i) = p[i];</span><br><span class="line">&amp;a[i] = a + i = p + i = &amp;p[i];</span><br></pre></td></tr></table></figure><p>这样看来指针 (指针变量) 好像是等价于一维数组的，但是它们是不完全等价的，<strong>首先，a 是地址，是一个常量，p 是指针变量，是一个变量，a++ 是不能运算的 (a = a + 1)，常量不能出现在运算符左边进行赋值操作，但 p++ 可以</strong> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p++    --&gt;  p = p + 1        --&gt; p 的指向已经改变</span><br><span class="line">p + 1  --&gt;  p 的指向未改变  </span><br></pre></td></tr></table></figure><h2 id="指针与二维数组">指针与二维数组<a title="#指针与二维数组" href="#指针与二维数组"></a></h2><h3 id="二维数组结合指针的理解">二维数组结合指针的理解<a title="#二维数组结合指针的理解" href="#二维数组结合指针的理解"></a></h3><p><code>a[i][j]</code> 相当于是数组名为 <code>a[i]</code>，然后取第 j 个元素，即为 <code>a[i][j]</code>，用指针的形式表示为：<code>*(*(a + i) + j)</code>。</p><p>(a + i) 是先按行移动指针，移动的 1 就是一行，即一行 j 个元素，移到第 i 行的首地址，此时 (a + i) 还只是 <code>a[i]</code> 的函数名（地址），即在第 i 个数组的函数名地址，a + i 只是一个地址，要取 <code>a[i]</code>，还要加 <code>*</code>，即 <code>*(a + i)</code>（具体可参考 <a href="https://chong589.github.io/2024/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84" target="_blank">二维数组的二次分配</a>），而 <code>a[i]</code> 又为 <code>a[i][j]</code> 的函数名，即地址，<code>a[i] + j</code> 为 <code>a[i][j]</code> 的地址，<code>*</code> 取值后成为 <code>a[i][j]</code>。</p><p><strong>二维数组的二次分配解析：二维数组的行指针就是一个二级指针用于存储一级指针的地址，所以在分配行指针时大小就是一个指针变量的大小，它是存一级指针的地址。二维数组 <code>a[i][j]</code> 中，<code>(a + i)</code> 表示的就是取第 i 个二级指针变量里存的地址（就是一级指针的地址），而 <code>*(a + i)</code> 就是取一级指针里的内容，即变量的地址（为 <code>a[i]</code> ）</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">int</span> *p;</span><br></pre></td></tr></table></figure><p>p = a 是不允许的，因为 p 是在列指针上移动的，而 a 是在行指针上移动的，即 p + 1 和 a + 1 所表达的含义不一样，a + 1 是指加一行，p + 1 是加一个元素。</p><p><code>p = *a</code> 即为 <code>*(a + 0)</code> 此种形式是可以的，此时 <code>*a</code> 取的是数组元素的地址,而不是存储元素地址的地址，使之在数组在列指针上移动，即每加 1 为一个元素大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = *a;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>二维数组也可以用这种方式输出。</p><h1 id="9.-指针数组与数组指针(工作常用，指针函数、数组指针)">9. 指针数组与数组指针(工作常用，指针函数、数组指针)<a title="#9.-指针数组与数组指针(工作常用，指针函数、数组指针)" href="#9.-指针数组与数组指针(工作常用，指针函数、数组指针)"></a></h1><p><strong>数组指针</strong>：像整型指针为指向整型的指针，而数组指针则为指向数组的指针。</p><blockquote><p>【存储类型】 数据类型  <code>(*指针名)[下标]  = 值</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>]; --&gt; type name; --&gt; <span class="type">int</span>[<span class="number">3</span>] *p;</span><br></pre></td></tr></table></figure><p>type 可以是 <code>int char double</code>，以及结构体类型，上面这种为数组类型。<code>int *p</code>；p 每加一，移动一个 int 大小，而 <code>int (*p)[3]</code> 即 <code>int[3] *p</code> 移动三个 int 大小。是数组间移动。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="type">int</span> *p = *a;</span><br><span class="line"><span class="type">int</span> (*q)[<span class="number">3</span>] = a;</span><br></pre></td></tr></table></figure><p>这种形式定义的 q 每加一，和 a 加一是一样的，q 加一，移动三个 int型元素大小，和二维数组的行指针一样。但要注意 <strong>区别</strong>：<strong>a 是常量，q 是变量，二维数组的本质就是一个数组指针</strong>。</p><blockquote><p>【存储类型】 数据类型  * 数组名【下标】  = 值；</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr[<span class="number">3</span>];  --&gt;  TYPE NAME;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1.-变量与地址&quot;&gt;1. 变量与地址&lt;a title=&quot;#1.-变量与地址&quot; href=&quot;#1.-变量与地址&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>字符数组</title>
    <link href="https://chong589.github.io/2024/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://chong589.github.io/2024/%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2024-02-02T13:50:00.000Z</published>
    <updated>2025-04-10T08:00:03.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念">概念<a title="#概念" href="#概念"></a></h1><p>C 语言本身没有内置的字符串类型，字符串本质上是一种特殊类型的数组，它的组成元素类型为 char，除此之外不受制与数组长度的限制，以<code>'\0'</code>作为结束标志，作为字符串结束的标志。（ <code>\0</code> 作为一个特殊字符，它的 ASCII 值为 0，但是它不是<code>'0'</code>字符，<code>'0'</code>字符的 ASCII 值为 48）</p><h1 id="字符串字面量-(字符串常量)">字符串字面量 (字符串常量)<a title="#字符串字面量-(字符串常量)" href="#字符串字面量-(字符串常量)"></a></h1><p>字符串字面量形如 <code>&quot;string&quot;</code>，也被称为字符串常量，编译器会将它末尾自动添加上字符串结尾标志 <code>\0</code>。通常存储在内存的 ​<strong>​只读数据段​</strong>​（<code>.rodata</code> 只读数据段 或 <code>.text</code> 程序代码段）中，与程序的生命周期一致。说以静态形式存储在程序中也是对的。</p><h1 id="初始化">初始化<a title="#初始化" href="#初始化"></a></h1><h2 id="使用字符串数组初始化">使用字符串数组初始化<a title="#使用字符串数组初始化" href="#使用字符串数组初始化"></a></h2><h3 id="字符串列表初始化">字符串列表初始化<a title="#字符串列表初始化" href="#字符串列表初始化"></a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//必须显式添加 &#x27;\0&#x27;</span></span><br><span class="line"><span class="type">char</span> a[] = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;!&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议这样初始化：</span></span><br><span class="line"><span class="type">char</span> a[] = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;!&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>因为如果是逐个字符初始化数组，比如 <code>char str[] = &#123;'h', 'e', 'l', 'l', 'o'&#125;;</code>，这时候数组的长度是 5，没有 <code>'\0'</code> 结束符。这时候如果当作字符串使用，比如用 printf 打印，可能会导致越界访问，因为函数会一直找直到遇到 <code>'\0'</code> 才停止。</p><p>如果这样写：<code>char str[] = &quot;hello&quot;;</code>，这时候数组的长度会自动计算为 6，包括结尾的 <code>'\0'</code>。这是因为用双引号的 <strong>字符串字面量</strong> 初始化数组时，编译器会自动添加结束符。所以这种情况下，即使不指定长度，数组会有 <code>'\0'</code>。</p><p>当指定数组大小，但是数组大小要足够，要预留 <code>'\0'</code> 的位置时，这样即使没有显示的添加 <code>'\0'</code>，编译器会自动在后面补 <code>'\0'</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">6</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后面未初始化的部分会被自动设为 &#x27;\0&#x27;</span></span><br><span class="line"><span class="type">char</span> a1[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="字面量的形式初始化数组">字面量的形式初始化数组<a title="#字面量的形式初始化数组" href="#字面量的形式初始化数组"></a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[] = <span class="string">&quot;hello!&quot;</span>;</span><br></pre></td></tr></table></figure><p>这种情况下，数组会自动包含 <code>\0</code>，长度是字符数加 1。</p><h2 id="使用指针指向字符串字面量初始化">使用指针指向字符串字面量初始化<a title="#使用指针指向字符串字面量初始化" href="#使用指针指向字符串字面量初始化"></a></h2><p>str 是一个指针，指向存储在 ​<strong>​只读内存区​</strong>​ 的字符串字面量。末尾自动包含 <code>\0</code>，可作为字符串安全使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="动态内存分配">动态内存分配<a title="#动态内存分配" href="#动态内存分配"></a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str = <span class="built_in">malloc</span>(<span class="number">6</span> *<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="字符串数组和指针">字符串数组和指针<a title="#字符串数组和指针" href="#字符串数组和指针"></a></h1><ul><li><p>字符串数组形式：字符串常量存储在只读内存区中，使用字符串数组来对它进行存储时，编译器会自动将 <strong>字符串常量的内容</strong>（包括结尾的<code>\0</code>）拷贝到数组所在的存储空间（栈或静态存储区，取决于数组的作用域）。</p></li><li><p>指针形式：这种方法就是将字符串常量的首地址赋值给指针变量，即指针指向这个字符串，并没有拷贝，而是直接指向那段内存，但是不可以更改里面的内容，因为是只读数据段。</p></li></ul><h1 id="注意问题">注意问题<a title="#注意问题" href="#注意问题"></a></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">11</span>] = &#123;<span class="string">&quot;hello world&quot;</span>&#125;;</span><br><span class="line"><span class="type">char</span> *s; s = <span class="string">&quot;china&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能这样</span></span><br><span class="line">str = <span class="string">&quot;zeng chong&quot;</span></span><br></pre></td></tr></table></figure><p>解释一下这几句都做了什么：</p><p>首先在内存的只读数据段为 “hello world” 分配了内存，该内存只读，不能修改，然后在栈中为 char 型数组分配内存，大小为 11，然后将只读数据段中的字符串字面量的内容 “hello world&quot; 拷贝到数组 str 中（大小足够）。然后是第二句，在栈中分配了一个 char 型指针变量，在只读数据段为 ”china“ 分配内存，再让 s 指向 “china”。</p><p>至于第三句为什么不行？因为 str 数组是分配在了栈中，数组的地址固定的，我们可以改变数组中的内容，相当于编译器在栈中分配了一个房子，房子容量是 11 个人，我们可以改变里面住谁（元素），但是在作用域内，房子地址已经分配在那里了，我们就不可以更改它的地址了，而第三句是将在只读数据段中的字面量地址赋值给数组，相当于改变数组的地址，这样显然是不行的。</p><p>所以 <code>s = str</code> 是可以的，可以改变指针 s 的指向，但是 <code>str = s</code> 不行。</p><p><code>char *s = &quot;china&quot;;</code> 的本质是一个指针变量，只占八个字节(64位机器中)，用来保存第一个字符的地址(str 就是一个地址)，它可以用 <code>printf(&quot;%c&quot;,s[i]);</code> 逐个输出字符，或 <code>printf(&quot;%c&quot;,*s++);</code> <code>s[i]</code> 就是 <code>*(s + i)</code>；例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,<span class="keyword">sizeof</span>(str),<span class="built_in">strlen</span>(str));</span><br><span class="line"><span class="built_in">strcpy</span>(str,<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(str);</span><br></pre></td></tr></table></figure><p><code>sizeof(str)</code>为 6 字节，<code>strlen(str)</code> 为 5 字节，而 <code>puts(str)</code> 输出为 world，正确输出。<strong>strcpy 是将 “world” 复制到数组 str 的地址空间中</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,<span class="keyword">sizeof</span>(s),<span class="built_in">strlen</span>(s));</span><br><span class="line"><span class="built_in">strcpy</span>(s,<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(s);</span><br></pre></td></tr></table></figure><p>这段程序会报段错误（Segmentation Fault），为什么数组 str 不会，而用指针 s 就会，这就要理解内存分配的问题了，要使用内存，必须先分配了才能使用。</p><p>这其实跟上面是一样的道理的，首先，在栈空间中分配了一个指针变量，然后字面量 “hello” 被分配在常量区中，然后将常量区的首地址赋给了 s，即 s 指向了 “hello”，s 指向的空间是位于常量区的，你更改不了它内存中的值，所以你这样会报错。</p><p>如果 s 指向的是堆中的内存 (事先已经分配好了，再让 s 指向它)，或者通过 <code>s = malloc(10);</code> 在堆中分配内存，然后这时就可以调用 strcpy 就可以成功。</p><h1 id="实现自己的-memcpy。">实现自己的 memcpy。<a title="#实现自己的-memcpy。" href="#实现自己的-memcpy。"></a></h1><p>首先 strcpy 是复制字符串的，而 memcpy 是内存拷贝的，任意类型的数据都能进行拷贝。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="title">memcpy</span> <span class="params">( <span class="type">void</span> * destination, <span class="type">const</span> <span class="type">void</span> * source, <span class="type">size_t</span> num )</span></span>;</span><br></pre></td></tr></table></figure><ol><li>参数中除了要复制的<code>字节数 num</code>，其他的参数类型基本都是 <code>void *</code>，返回值也是 <code>void *</code>。</li><li>该函数是从 <code>source</code> 的位置开始向后复制 <code>num 个字节</code> 的数据到 <code>destination</code> 的内存位置。</li><li>该函数在遇到 <code>'\0'</code> 的时候并不会停下来。</li><li><code>source</code> 和 <code>destination</code> 不能有任何的重叠。</li></ol><p><code>void *</code> 不能直接解引用，那么 **如何复制呢？**答案是进行类型强转，转换成<code>char *</code>，一个一个字节地复制过去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">myMemcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(dest);</span><br><span class="line">    <span class="built_in">assert</span>(src);</span><br><span class="line">    <span class="type">char</span> *pDest = dest;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pSrc = src;</span><br><span class="line">    <span class="keyword">while</span>(num--) &#123;</span><br><span class="line">        *pDest++ = *pSrc++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="memmove-实现">memmove 实现<a title="#memmove-实现" href="#memmove-实现"></a></h1><p>memcpy 如果 src 和 dest 中有内存重叠的情况是不能拷贝成功的，下面是会出现的几种情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. 如下所示，src &lt; dest &amp;&amp; src + n &gt; dest 时，有内存重叠，这样拷贝是不成功的，</span><br><span class="line">需要从后往前拷贝。</span><br><span class="line">----------------------------       ======&gt;&gt; 从后往前拷贝</span><br><span class="line"> |        |</span><br><span class="line">src     dest</span><br><span class="line"></span><br><span class="line">2. dest &lt; src &amp;&amp; dest + n &gt; src 时，虽然这样也有重叠，但是这样从前往后拷贝是</span><br><span class="line">不会出错的。</span><br><span class="line">----------------------------       ======&gt;&gt; 从前往后拷贝</span><br><span class="line"> |        |</span><br><span class="line">dest     src</span><br><span class="line"></span><br><span class="line">3. src + n &lt; dest 的情况，即 src &lt; dest ，没有重叠</span><br><span class="line">-----------------------------      ======&gt;&gt; 两种都可以</span><br><span class="line"> |                  |</span><br><span class="line">src                dest</span><br><span class="line"></span><br><span class="line">4. dest + n &lt; src 的情况，即 dest &lt; src ，没有重叠</span><br><span class="line">-----------------------------      ======&gt;&gt; 两种都可以</span><br><span class="line"> |                  |</span><br><span class="line">dest               src</span><br></pre></td></tr></table></figure><p>可以看到有四种情况，只有一种情况是只能用从后往前拷贝的，我们可以将 src &lt; dest 的情况都归类为从后往前拷贝，因为第三种情况两种拷贝方式都可以，然后其它情况就是从前往后拷贝的情况，即 src &gt;= dest。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memmove</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(dest);</span><br><span class="line">    <span class="built_in">assert</span>(src);</span><br><span class="line">    <span class="type">char</span> *pDest = (<span class="type">char</span> *)dest;</span><br><span class="line">    <span class="type">char</span> *pSrc = (<span class="type">char</span> *)src;</span><br><span class="line">    <span class="keyword">if</span>(src &lt; dest) &#123;</span><br><span class="line">    <span class="comment">//从后往前拷贝</span></span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    *(dest + n) = *(src + n);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//从前往后拷贝</span></span><br><span class="line">    *dest++ = *src++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="strcpy-函数实现">strcpy 函数实现<a title="#strcpy-函数实现" href="#strcpy-函数实现"></a></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>确保目标字符串 dest 有足够的空间来存储源字符串 src 的内容。</li><li>调用 strcpy 函数，将源字符串 src 的内容(包括 ‘\0’ )复制到目标字符串 dest 中。</li><li>返回目标字符串 dest 的地址。</li></ol><p>strcpy 函数并不会检查目标字符串 dest 的容量是否足够，因此在使用 strcpy 函数时，务必确保目标字符串有足够的空间来存储源字符串的内容，以免发生缓冲区溢出的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">myStrcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span> </span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(dst != <span class="literal">NULL</span> &amp;&amp; src != <span class="literal">NULL</span>);</span><br><span class="line"><span class="type">char</span> *ret = dest<span class="number">&#x27;</span></span><br><span class="line"><span class="comment">//拷贝的内容包括 &#x27;\0&#x27;，遇到 &#x27;\0&#x27; 后，</span></span><br><span class="line"><span class="comment">//先赋值给 dest，然后判断为 0，跳出循环。</span></span><br><span class="line"><span class="keyword">while</span>((*dest++ = *src++) != <span class="string">&#x27;\0&#x27;</span>) ;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="strncpy-实现">strncpy 实现<a title="#strncpy-实现" href="#strncpy-实现"></a></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">mystrncpy</span> <span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n &amp;&amp; (dest[i] = src[i]); i++) &#123;</span><br><span class="line"><span class="comment">//(dest[i] = src[i]) 作用是一边拷贝到 dest 中，一边用作判断，</span></span><br><span class="line"><span class="comment">//当 (dest[i] = src[i])的值为 \0 即在 &amp;&amp; 运算中式子不成立，</span></span><br><span class="line"><span class="comment">//跳出循环,因为 有时 src 的长度会小于 n ，即 src 不够长, 那</span></span><br><span class="line"><span class="comment">//就只拷贝 src 那么长的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; n; i++)</span><br><span class="line">dest[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若 src 没有 n 那么长，经过 <code>(dest[i] = src[i])</code> 将 <code>\0</code> 复制到了 dest 中，且判断跳出循环，这时 <code>\0</code> 是赋值到了字符串中的，当 src &gt; n 时，是因为 i &lt; n 这个条件不满足导致跳出，<code>\0</code> 并无拷贝，最后应该将 <code>dest[i] = '\0'</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;概念&lt;a title=&quot;#概念&quot; href=&quot;#概念&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;C 语言本身没有内置的字符串类型，字符串本质上是一种特殊类型的数组，它的组成元素类型为 char，除此之外不受制与数组长度的限制，以&lt;code&gt;&#39;&#92;0&#39;&lt;/code&gt;作为结束
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>二维数组</title>
    <link href="https://chong589.github.io/2024/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
    <id>https://chong589.github.io/2024/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</id>
    <published>2024-02-02T12:18:01.000Z</published>
    <updated>2024-12-25T06:58:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二维数组的分配">二维数组的分配<a title="#二维数组的分配" href="#二维数组的分配"></a></h3><p>假设要为一个 m * n 的数组分配内存空间</p><h4 id="1.-一次分配">1. 一次分配<a title="#1.-一次分配" href="#1.-一次分配"></a></h4><p><img src="/2024/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/1.png" alt class="φcx"></p><p>这种分配就是把它当作一维数组来分配，通过 i 和 j 的值，计算出具体位置。该分配的内存必须是连续的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int *arr = (int *)malloc(sizeof(int) * m * n);</span><br><span class="line"></span><br><span class="line">for(int i = 0; i &lt; m; i ++)&#123;</span><br><span class="line">    for(int j = 0; j &lt; n; j ++)&#123;</span><br><span class="line">        arr[i * n + j] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意每个元素的下标和 i 、j 的关系</strong></p><h3 id="#2.-二次分配">#2. 二次分配<a title="##2.-二次分配" href="##2.-二次分配"></a></h3><p><img src="/2024/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/2.png" alt class="φcx"></p><p>首先分配一个指针数组 <code>*arr[i]</code>,以行为单位，一行表示一个指针，该指针数组中的每个元素都是一个数组指针，该指针又指向一个一维数组。<strong>后面再对该数组指针分配内存空间</strong>(即对一维数组分配)，这种二维内存的分配是分两次来分配的，因此分配的内存是不连续的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 为指针数组分配内存</span><br><span class="line">int **arr = (int **)malloc(sizeof(int *) * m);</span><br><span class="line">// 为每个指向数组的指针分配空间，即每个指针只需一个指针变量接收，共有 m 个。</span><br><span class="line"></span><br><span class="line">// 再为每个指针数组分配内存空间</span><br><span class="line">for(int i = 0; i &lt; m; i ++)&#123;</span><br><span class="line">    arr[i] = (int *)malloc(sizeof(int) * n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;二维数组的分配&quot;&gt;二维数组的分配&lt;a title=&quot;#二维数组的分配&quot; href=&quot;#二维数组的分配&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;假设要为一个 m * n 的数组分配内存空间&lt;/p&gt;
&lt;h4 id=&quot;1.-一次分配&quot;&gt;1. 一次分配&lt;a title=&quot;#1.-一次
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>环境变量</title>
    <link href="https://chong589.github.io/2024/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>https://chong589.github.io/2024/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</id>
    <published>2024-01-31T15:03:55.000Z</published>
    <updated>2024-12-25T07:38:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们平时在装有些软件时，要配置环境变量，那么为什么要配置？它起什么作用？</p><span id="more"></span><h3 id="什么是环境变量">什么是环境变量<a title="#什么是环境变量" href="#什么是环境变量"></a></h3><p>是在操作系统中一个具有特定名字的对象，它包含了一个或多个应用程序所将使用到的信息, 例如: 如系统临时文件夹位置、系统文件夹位置、某些应用软件文件的路径等等…</p><p>当要求系统运行一个程序但是又没有告诉它这个程序所在的完整路径时，系统<strong>默认会在当前目录</strong>下面寻找这个程序,如果找不到就会到环境变量中的 path 中指定的路径去找, 所以我们用户可以通过设置环境变量，来更好的运行程序!</p><p>例：当我们在 cmd 命令行窗口中输入 <code>qq</code> 时：</p><div align="center"><img src="/2024/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/1.png" width="100%" height="100%"></div><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;qq&#x27; is not recognized as an internal or external command</span><br></pre></td></tr></table></figure><p>所以这种方式不能打开 QQ 程序的，如果我们非要在 cmd 中打开 QQ 程序，我们要进入并且找到这个程序的 bin 目录下的 qq.exe 执行程序！</p><p>我电脑中的 QQ 路径为：<code>D:\Program Files (x86)\QQ\QQ\Bin</code></p><p>在 cmd 中进入该路径且输入<code>QQ.exe</code></p><div align="center"><img src="/2024/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/2.png" width="100%" height="100%"></div><p>所以我们是可以通过命令行中进入到执行程序的位置进行打开该程序，这个效果跟你在桌面点击快捷方式是一个效果。如果关掉 cmd 后重新打开，再次输入 QQ 其实又是同样的问题，这就意味着你要从 cmd 打开 QQ 必须每次按照刚才的步骤进行打开，并且你还必须要切换到这个 QQ 的 bin 目录下才行，这样就很麻烦了（当然这只是个例子，我们完全可以通过快捷方式打开程序）。</p><p>那么有没有办法让我们在随便哪个目录中都可以直接使用 cmd 输入一个 QQ 就可以打开的办法呢?</p><p>这时就要使用到<strong>环境变量</strong>！你只要把刚刚那个 bin 目录的路径添加到环境变量中的系统变量下的 <strong>path</strong> 就可以了，这里的 path 也就是环境变量中用来指定<strong>可执行文件的绝对路径</strong>，这里配置了很多路径，彼此之间用分号隔开!这里操作以 windows 10 为例，步骤如下：</p><p><code>右键点击此电脑 ---&gt; 属性 ---&gt; 高级系统设置 ---&gt; 环境变量</code></p><div align="center"><img src="/2024/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/3.png" width="100%" height="100%"></div><p>然后找到<code>系统环境变量 ---&gt; Path ---&gt; 编辑 ---&gt; 新建</code></p><div align="center"><img src="/2024/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/4.png" width="100%" height="100%"></div><div align="center"><img src="/2024/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/5.png" width="100%" height="100%"></div><p>复制你 QQ 安装目录下的 bin 路径到新建的对话框中</p><div align="center"><img src="/2024/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/6.png" width="100%" height="100%"></div><div align="center"><img src="/2024/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/7.png" width="100%" height="100%"></div><p>最后全部点击确定即可！这时你就可以在 cmd 中的任意目录、任意盘符下进行打开这个应用程序了！</p><p>总之，<strong>环境变量</strong> 的主要作用就是规定了某些系统文件的所在位置！</p><h3 id="用户变量和系统变量的区别">用户变量和系统变量的区别<a title="#用户变量和系统变量的区别" href="#用户变量和系统变量的区别"></a></h3><ul><li><p>用户变量：在环境变量中的用户变量配置只会当前所登录的系统用户生效, 也就是说登录的系统用户可以对他自己所配置的环境变量参数进行增删改 , 不同用户的用户变量之间是独立存在的,并且互不干扰的</p></li><li><p>系统环境变量：在环境变量中系统变量的配置会对所有用户都会有效, 也就是说如果系统变量被修改了，那么任何一个用户都将受到影响!但是只有管理员账户才有权限进行系统变量的设置, 普通系统用户是不能够去修改系统变量的</p></li></ul><h3 id="如何自定义环境变量命令">如何自定义环境变量命令<a title="#如何自定义环境变量命令" href="#如何自定义环境变量命令"></a></h3><p>当我们想通过 cmd 来运行一个自己定义的命令时，就会出现不是内部或外部命令，也不是可运行的程序 或批处理文件的提示信息!</p><p>但是如果我们在cmd中输入一个 shutdown 命令则可以完全正常执行!</p><div align="center"><img src="/2024/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/8.png" width="100%" height="100%"></div><p>这个原因也很简单,正因为 shutdown 在环境变量中定义了它这个命令所在的路径,而test这个命令则没有!</p><p>shutdown命令的默认路径是在 <code>C:\Windows\System32</code> 目录下, 包括一些常见的cmd命令其实都在这个目录下</p><div align="center"><img src="/2024/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/9.png" width="100%" height="100%"></div><p>而 <code>C:\Windows\System32</code> 这个路径也是默认安装系统的时候就被定义在了环境变量当中, 就跟之前定义 QQ 应用程序也是一个道理！</p><p>所以根据这个道理我们也可以自定义一个环境变量来进行调用！要知道变量就是一个可变化的量 我们就利用这个特点来自己定义一个系统变量然后调用它来打开某个应用程序</p><p>我这里要打开微信，当然你完全可以依照之前的办法在 path 中把微信的 WeChat.exe 路径加入到其中, 但是这样子做不够灵活！我们可以先在系统变量中定义一个 weixin 然后值设置为微信目录地址！</p><div align="center"><img src="/2024/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/10.png" width="100%" height="100%"></div><div align="center"><img src="/2024/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/11.png" width="100%" height="100%"></div><p>设置好后，我们现在就可以对它进行调用！在 path 中把刚刚自定义好的 weixin 这个变量加入到其中，格式为 <code>%变量名%</code></p><div align="center"><img src="/2024/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/12.png" width="100%" height="100%"></div><p>这样一来以后你只需要去修改变量的值 path 中就会自动获取到了！接下来就可以去 cmd 中尝试一下打开这个应用程序</p><p><strong>！！！但是这样在 cmd 中用 weixin 启动不成功，即使在变量值中改成 <code>D:\Program Files (x86)\WeChat\WeChat</code> 也还是不行，网上查了一些原因也没解决</strong></p><h3 id="为什么编程开发要配置环境变量">为什么编程开发要配置环境变量<a title="#为什么编程开发要配置环境变量" href="#为什么编程开发要配置环境变量"></a></h3><p>知道什么是环境变量以后，现在应该明白我们在开发 java、python、php 之前需要配置的环境变量的原因了吧！</p><p>比如 Java 我们就需要把 JDK 的 bin 目录添加到环境变量的 path 中，这样我们就可以在任意目录下使用 bin 下面的 .exe 可执行程序 javac.exe</p><p>javac.exe 用来处理 .java 源代码文件，是把源代码文件编译为字节码文件的一个工具,经过 javac.exe 这个工具编译 java 源代码文件后形成的 .class 就是字节码文件</p><p>java.exe 用来处理 .class 字节码文件进行执行的，也就是 JVM 解释执行 java 程序, 从而实现 java 程序的运行</p><p>而他们都在 bin 目录下, 这都是为了能够方便的使用这些开发语言所带有的编译解释工具和命令, 所以我们才要配置环境变量。如果环境变量配置不成功，在 cmd 中去输入 java 就会提示找不到某某的关键词</p><p>所以在开始学习 java 或者其他一些开发语言的时候，为了操作方便必须要配置一下环境变量 从而达到能够正常运行 java 的环境, 其他一些语言也是以此类推!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们平时在装有些软件时，要配置环境变量，那么为什么要配置？它起什么作用？&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>static</title>
    <link href="https://chong589.github.io/2024/static%E7%94%A8%E6%B3%95/"/>
    <id>https://chong589.github.io/2024/static%E7%94%A8%E6%B3%95/</id>
    <published>2024-01-30T07:31:31.000Z</published>
    <updated>2025-04-10T08:01:19.674Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>当与不同类型一起使用时，static 关键字具有不同的含义。<strong>static 编译时分配内存</strong>。</p><h2 id="函数中的静态变量">函数中的静态变量<a title="#函数中的静态变量" href="#函数中的静态变量"></a></h2><p>当变量声明为 static 时，空间 <strong>将在程序的生命周期内分配</strong>。即使多次调用该函数，静态变量的空间也 <strong>只分配一次</strong>，前一次调用中的变量值通过下一次函数调用传递。这对于在 C / C ++ 或需要存储先前函数状态的任何其他应用程序非常有用。</p><h2 id="类中的静态成员变量">类中的静态成员变量<a title="#类中的静态成员变量" href="#类中的静态成员变量"></a></h2><p>当我们在头文件中声明一个静态成员时，只是在告知编译器存在这样一个静态成员变量，但实际上并没有定义它（从某种意义上说，这与前置声明非常相似）。因为静态成员变量不属于类实例（它们的处理方式与全局变量类似，在程序启动时初始化），所以必须在类外部的全局作用域中显式定义静态成员。也是因为这个原因，<strong>静态变量不能使用构造函数初始化，使用类外的类名和范围解析运算符显式初始化</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> i; </span><br><span class="line"></span><br><span class="line"><span class="built_in">Apple</span>() &#123; </span><br><span class="line"><span class="comment">// Do nothing </span></span><br><span class="line">&#125;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Apple::i = <span class="number">1</span>; <span class="comment">//类名和范围解析运算符显示初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">Apple obj; </span><br><span class="line"><span class="comment">// prints value of i </span></span><br><span class="line">cout &lt;&lt; obj.i; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>不过也有一些例外情况。首先，当静态成员是<code>const</code>整型（包括<code>char</code>和<code>bool</code>）或<code>const</code>枚举类型时，静态成员可以在类定义内部初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span>  s_var&#123;<span class="number">42</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从C++17开始，<code>static constexpr</code> 成员可以在类定义内部初始化（无需在外部进行初始化）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    // 对于任何支持constexpr初始化的类，这都有效</span><br><span class="line">    static constexpr std::array&lt;int , 3&gt; s_array&#123; 1, 2, 3 &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果在成员函数中调用静态数据成员，那么该成员函数应声明为<code>static</code>。这点在下面解释了，<strong>允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数</strong>。</p><h2 id="类对象为静态">类对象为静态<a title="#类对象为静态" href="#类对象为静态"></a></h2><p>就像变量一样，对象也在声明为 static 时具有范围，直到程序的生命周期。如果我们将对象声明为静态，现在让我们看看输出的变化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="built_in">Apple</span>() &#123; </span><br><span class="line">i = <span class="number">0</span>; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Inside Constructor\n&quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line">~<span class="built_in">Apple</span>() &#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Inside Destructor\n&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">if</span> (x==<span class="number">0</span>) &#123; </span><br><span class="line"><span class="type">static</span> Apple obj; </span><br><span class="line">&#125; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;End of main\n&quot;</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inside Constructor</span><br><span class="line">End of main</span><br><span class="line">Inside Destructor</span><br></pre></td></tr></table></figure><p>您可以清楚地看到输出的变化。现在，在 main 结束后调用析构函数。这是因为静态对象的范围是贯穿程序的生命周期。</p><h2 id="类中的静态成员函数">类中的静态成员函数<a title="#类中的静态成员函数" href="#类中的静态成员函数"></a></h2><p>静态成员函数可用于 <strong>处理类中的静态成员变量，或执行无需类实例的操作</strong>。不过，从概念和语义上讲，静态成员函数所执行的操作应与类密切相关。关于静态成员函数，有以下几个要点：</p><ul><li>静态成员函数没有<code>this</code>指针。</li><li>静态成员函数不能是虚函数（virtual）。</li><li>静态成员函数不能访问非静态成员。</li><li>静态成员函数不能使用<code>const</code>和<code>volatile</code>限定符（静态变量是可以用 const 修饰的）。</li></ul><p>在实际应用中，静态成员函数意味着无需实例化类就可以调用它。如果<code>Foo</code>类中有一个静态函数<code>static void bar()</code>，你可以这样调用它：<code>Foo::bar()</code>，而无需实例化 <code>Foo</code> 类（顺便说一句，你也可以通过实例调用它：<code>aFoo.bar()</code>）。</p><p><strong>允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数</strong>。</p><p>由于<code>this</code>指针始终保存当前对象的内存地址，而调用静态成员根本不需要对象，所以静态成员函数不能有<code>this</code>指针。</p><p>虚成员与任何特定类没有直接关系，只与实例相关。（根据定义）“虚函数” 是一种动态链接的函数，即在运行时根据给定对象的动态类型选择正确的实现。因此，如果没有对象，就不可能进行虚函数调用。</p><p><strong>访问非静态成员函数要求对象已经构造，但对于静态调用，我们不会传递类的任何实例，甚至不能保证已经构造了任何实例</strong>。</p><p>同样，<code>const</code> 和 <code>const volatile</code> 关键字用于修改对象是否可被修改以及如何被修改。由于静态调用不能保证已经构造了任何实例，所以这两个关键字操作的对象都不知道有没有。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="comment">// static member function </span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Welcome to Apple!&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// main function </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// invoking a static member function </span></span><br><span class="line">    Apple::<span class="built_in">printMsg</span>(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Apple!</span><br></pre></td></tr></table></figure><h2 id="限定访问范围">限定访问范围<a title="#限定访问范围" href="#限定访问范围"></a></h2><h3 id="解决变量冲突问题">解决变量冲突问题<a title="#解决变量冲突问题" href="#解决变量冲突问题"></a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//proj.h</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//proj.c</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%s]: i = %d\n&quot;</span>,__FUNCTION__,i);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%s]: i = %d\n&quot;</span>,__FUNCTION__,i);</span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个文件当中的全局变量 i 按理来说它们都只作用在本 .c 文件中，因为它们的作用范围和生命周期是不同的，但是编译后出现了错误。显示对 i 的定义重复定义了。所以 main.c 和 proj.c 链接后的 i 会导致作用范围一样，即导致冲突。编译 --&gt; 链接 --&gt; 装入，链接时会出现两个文件的 i。</p><p>如果想要 main.c 和 proj.c 中的 i 变量作用在各自的 .c 文件中，则在各自定义 i 变量时加上关键字 static。像这样 <code>static int i = 10;</code>这样则当前文件修饰的变量只能在当前文件用，这样就不冲突了。</p><p>同理如果一个文件访问另一个文件中加了 static 修饰的变量会出现 undefined reference 的编译错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// source1.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sayHello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// source2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *msg;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="防止函数对外扩展">防止函数对外扩展<a title="#防止函数对外扩展" href="#防止函数对外扩展"></a></h3><h4 id="普通做法会出现的问题">普通做法会出现的问题<a title="#普通做法会出现的问题" href="#普通做法会出现的问题"></a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//proj.h</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//proj.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%s]: i = %d\n&quot;</span>,__FUNCTION__,i);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%s]: i = %d\n&quot;</span>,__FUNCTION__,i);</span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 static 修饰了函数，所以只能在该 .c 文件中使用，导致在 .h 文件声明时使用不了，而在 main.c 文件中又使用了 func(), 这样就导致未定义就使用 func() 。</p><h4 id="解决方法">解决方法<a title="#解决方法" href="#解决方法"></a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//proj.h</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_func</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//proj.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%s]: i = %d\n&quot;</span>,__FUNCTION__,i);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%s]: i = %d\n&quot;</span>,__FUNCTION__,i);</span><br><span class="line"><span class="built_in">call_func</span>();</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>func() 函数还是只能在本文件使用，只不过借助了一个 call_func() 函数来执行 func()。这样就能保证 func() 在本文件中使用，而在其他文件中通过调用 call_func() 来执行 func().</p><h2 id="什么是静态初始化顺序问题">什么是静态初始化顺序问题<a title="#什么是静态初始化顺序问题" href="#什么是静态初始化顺序问题"></a></h2><p>静态初始化顺序问题是C++中一个容易被许多人忽视、误解的微妙方面。由于该错误通常在<code>main()</code>函数被调用之前就发生了，所以很难察觉。</p><p>在一个翻译单元（translation unit）中，静态或全局变量总是按照它们的定义顺序进行初始化。另一方面，对于哪个翻译单元先被初始化，并没有严格的顺序。</p><p>假设你有一个翻译单元<code>A</code>，其中有一个静态变量<code>sA</code>，它的初始化依赖于翻译单元<code>B</code>中的静态变量<code>sB</code>。那么你有 50% 的失败几率。这就是静态初始化顺序问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Logger.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;string&gt;</span></span></span><br><span class="line">std::string theLogger = <span class="string">&quot;aNiceLogger&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KeyBoard.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span>  std::string theLogger;</span><br><span class="line">std::string theKeyboard = <span class="string">&quot;The Keyboard with logger: &quot;</span> + theLogger;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;theKeyboard: &quot;</span> &lt;&lt; theKeyboard &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们看看不同的初始化顺序会产生什么样的结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">zhangxf@mydevserver ~/static_fiasco $ g++ -c Logger.cpp</span><br><span class="line">zhangxf@mydevserver ~/static_fiasco $ g++ -c Keyboard.cpp</span><br><span class="line">zhangxf@mydevserver ~/static_fiasco $ g++ Logger.o Keyboard.o -o LoggerThenKeyboard</span><br><span class="line">zhangxf@mydevserver ~/static_fiasco $ g++ Keyboard.o Logger.o -o KeyboardThenLogger </span><br><span class="line">zhangxf@mydevserver ~/static_fiasco $ ./KeyboardThenLogger </span><br><span class="line">theKeyboard: The Keyboard with logger: </span><br><span class="line">zhangxf@mydevserver ~/static_fiasco $ ./LoggerThenKeyboard</span><br><span class="line">theKeyboard: The Keyboard with logger: aNiceLogger</span><br></pre></td></tr></table></figure><h2 id="如何解决静态初始化顺序问题？">如何解决静态初始化顺序问题？<a title="#如何解决静态初始化顺序问题？" href="#如何解决静态初始化顺序问题？"></a></h2><p>需要再次提醒的是，在一个翻译单元中，静态或全局变量总是按照它们的定义顺序进行初始化。另一方面，对于哪个翻译单元先被初始化，并没有严格的顺序。</p><p>上面的例子中如果编译单元<code>Logger.cpp</code>先被初始化，那么没问题。但如果是键盘（对应的编译单元）先被初始化，就会出问题。</p><p>可能最简单的解决方案是将<code>Logger.cpp</code>中的<code>theLogger</code>变量替换为一个函数，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">theLogger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span>  std::string aLogger = <span class="string">&quot;aNiceLogger&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>  aLogger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>Keyboard.cpp</code>中，我们只需确保对该函数使用<code>extern</code>，并且之后调用这个函数，而不是引用变量。这样做是可行的，因为局部静态变量<code>std::string aLogger</code>会在<code>theLogger()</code>函数第一次被调用时初始化。因此，可以保证在构造<code>theKeyboard</code>时，<code>theLogger</code>已经被初始化。</p><p>如果在<code>theLogger</code>被构造之后，程序退出时另一个静态变量使用了<code>theLogger</code>，你可能会遇到其他问题。同样，对不同翻译单元中静态变量的依赖是代码质量不佳的表现……</p><p>从C++20 开始，可以使用<code>constinit</code>来解决静态初始化顺序问题。在这种情况下，静态变量将在 <strong>编译时、链接之前进行初始化</strong>。你可以在这里查看相关解决方案。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;当与不同类型一起使用时，static 关键字具有不同的含义。&lt;strong&gt;static 编译时分配内存&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;函数中的静态变量&quot;&gt;函数中的静态变量&lt;a title=&quot;#函数中的静态变量&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>scanf相关知识</title>
    <link href="https://chong589.github.io/2024/scanf%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>https://chong589.github.io/2024/scanf%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</id>
    <published>2024-01-30T07:08:35.000Z</published>
    <updated>2024-12-25T06:39:27.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="使用-scanf-的注意事项">使用 scanf 的注意事项<a title="#使用-scanf-的注意事项" href="#使用-scanf-的注意事项"></a></h3><h4 id="scanf-里面不能像-printf-那样在里面输入-\n,因为在-scanf-中你在里面写了什么，在输入的时候你要原模原样的输入回去。">scanf 里面不能像 printf 那样在里面输入 \n,因为在 scanf 中你在里面写了什么，在输入的时候你要原模原样的输入回去。<a title="#scanf-里面不能像-printf-那样在里面输入-\n,因为在-scanf-中你在里面写了什么，在输入的时候你要原模原样的输入回去。" href="#scanf-里面不能像-printf-那样在里面输入-\n,因为在-scanf-中你在里面写了什么，在输入的时候你要原模原样的输入回去。"></a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这时你输入 i 和 j 时中间就要输入逗号才能正确输入。</span></span><br><span class="line">scacnf(<span class="string">&quot;%d,%d&quot;</span>,&amp;i,&amp;j);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这时你就要在输入 i 和 j 的中间要加上一个空格。</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;i,&amp;j);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这时你在输入 i 后还要输入 \n 才能结束。</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果你在里面没有输入其他，则你输入 i 和 j 时的间隔符可以</span></span><br><span class="line"><span class="comment">//是空格、回车、Tab。</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;i,&amp;j);</span><br></pre></td></tr></table></figure><h4 id="scanf-在用-%s-输入字符串时，输入的字符串中不能有空格、tab、回车键等，它会作为当前输入的结束，即空格、tab、回车键后面的字符不会再输入进去。">scanf 在用 %s 输入字符串时，输入的字符串中<strong>不能有空格、Tab、回车键</strong>等，它会作为当前输入的结束，即空格、Tab、回车键后面的字符不会再输入进去。<a title="#scanf-在用-%s-输入字符串时，输入的字符串中不能有空格、tab、回车键等，它会作为当前输入的结束，即空格、tab、回车键后面的字符不会再输入进去。" href="#scanf-在用-%s-输入字符串时，输入的字符串中不能有空格、tab、回车键等，它会作为当前输入的结束，即空格、tab、回车键后面的字符不会再输入进去。"></a></h4><ul><li><p>用 %s 也是非常危险的操作，当你输入的字符串超过了接收数组容量时，它不会报错，而是原样输入进去，这样就发生了<strong>越界</strong>现象，使之存到了这个数组之外的空间中</p></li><li><p>scanf 会返回一个值，当你在 scanf中输入两个值时，<code>scanf(&quot;%d%d&quot;,&amp;i,&amp;j);</code>如果正确输入，则会返回2，若输入错误，则返回不是2的值。所以它在放入循环中时要进行输入是否正确判断，若输入的格式不对，如本来要输入整型值的你输入字符类型，那么你输入错误，则会从你上一次输入的值中取。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">while(1)&#123;</span><br><span class="line">int ret = scanf(&quot;%d&quot;,&amp;i);</span><br><span class="line">if(ret != 1)</span><br><span class="line">break;</span><br><span class="line">printf(&quot;i = %d\n&quot;,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;i))&#123;</span><br><span class="line">printf(&quot;i = %d\n&quot;,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你没进行判断跳出，只要中间你输入一个错误，它就会一直输出你上一次输入的值，一直死循环。</p><h4 id="在用连续的-scanf-时，输入一个字符后，按回车确定的回车符会被下一个-scanf-吸收。（常常会在循环中遇到这种问题，导致出错）">在用连续的 scanf 时，输入一个字符后，按回车确定的回车符会被下一个 scanf 吸收。（常常会在循环中遇到这种问题，导致出错）<a title="#在用连续的-scanf-时，输入一个字符后，按回车确定的回车符会被下一个-scanf-吸收。（常常会在循环中遇到这种问题，导致出错）" href="#在用连续的-scanf-时，输入一个字符后，按回车确定的回车符会被下一个-scanf-吸收。（常常会在循环中遇到这种问题，导致出错）"></a></h4><p>这种错误尤其是在循环中要求输入的字符为 char 时，因为回车符就是 char 。当在连续两个 scanf 使用时,当输入的是 int 时不会。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;j);</span><br></pre></td></tr></table></figure><p>这样输入时，你输入第一个值 i 时，然后回车确定，再输入 j 时，此时 j 接收的是回车符。可以用 getchra() 吃掉一个回车符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;i);</span><br><span class="line">getchar();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;j);</span><br></pre></td></tr></table></figure><h3 id="总结">总结<a title="#总结" href="#总结"></a></h3><ul><li><p>所以在循环中有输入规定格式的值时，要判断输入的值正不正确，即判断 scanf 返回的值，可以将加入到 while(scanf()) 中判断。</p></li><li><p>当输入的值为 char 时，要注意输入后确定的回车符，也会被当作输入值输入进去，要用一个来吸收回车符，输入值为 int 时，不会被吸收，因为回车符为 char。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h3 id=&quot;使用-scanf-的注意事项&quot;&gt;使用 scanf 的注意事项&lt;a title=&quot;#使用-scanf-的注意事项&quot; href=&quot;#使用-scanf-的注意事项&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h4 id=&quot;scanf-里面不能
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>编程注意的问题</title>
    <link href="https://chong589.github.io/2024/%E7%BC%96%E7%A8%8B%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://chong589.github.io/2024/%E7%BC%96%E7%A8%8B%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2024-01-28T13:28:43.000Z</published>
    <updated>2025-04-10T08:00:18.091Z</updated>
    
    <content type="html"><![CDATA[<p>我们平时编程时经常会忽略一些细节，导致项目出现问题，且有些很难发现。</p><span id="more"></span><h4 id="1.-头文件正确包含的重要性">1. 头文件正确包含的重要性<a title="#1.-头文件正确包含的重要性" href="#1.-头文件正确包含的重要性"></a></h4><p>在程序中使用 <strong>malloc 函数</strong> 时，在程序开头未写头文件 <strong><code>#include&lt;stdlib.h&gt;</code></strong>，这时 gcc 没有看到 malloc 函数头文件的时候，也就看不到它的原型，那它会<strong>默认 malloc 的返回值为 int 型</strong>，如以下程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认 malloc 函数的返回值为 int 型后，而程序中接收的是 int* 型指针，这样就会报错。有人会这样解决问题：<code>p = (int*)malloc(sizeof(int));</code>,使用强制转换类型，有时有些编译器不会报错，但是以后经过移植或换个环境等的时候，这个问题就会出现，导致很难找出来。通过 man malloc 查看可知：</p><p><img src="/2024/%E7%BC%96%E7%A8%8B%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/malloc.png" alt="malloc函数" class="φcx"></p><p>malloc 函数返回的是 void* 类型的值，而 void 可以转变为大部分的类型，所以可以这样写 <code>p = malloc(sizeof(int))</code>。</p><p>以后使用 gcc 编译时可以用参数 -Wall ,它会显示全部错误，你只要按照出现的错误一个个解决，后面出现的大部分错误都是来源于这，因为你不把这些错误用 -Wall 打印出来，gcc 有些错误在你编译时没有非常严重的错误，它是会忽略的。</p><p>例：<code>gcc hello.c -Wall</code></p><h4 id="2.-以函数为单位来进行程序编写">2. 以函数为单位来进行程序编写<a title="#2.-以函数为单位来进行程序编写" href="#2.-以函数为单位来进行程序编写"></a></h4><h4 id="3.-声明部分-+-实现部分">3. 声明部分 + 实现部分<a title="#3.-声明部分-+-实现部分" href="#3.-声明部分-+-实现部分"></a></h4><h4 id="4.-对于宏定义的理解">4. 对于宏定义的理解<a title="#4.-对于宏定义的理解" href="#4.-对于宏定义的理解"></a></h4><p><code>#define</code> 处理在程序的预处理阶段，占编译时间，特点是，一改全改。缺点：<strong>不检查语法</strong>，只是单纯的宏体与宏名之间的替换。例如以下程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define ADD 2 + 3</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">        printf(&quot;%d\n&quot;,ADD * ADD);</span><br><span class="line">        exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：11</p><p>明显结果不是我们想要的 25，我们用 gcc 的预编译命令 <code>gcc -E defind.c</code> 查看</p><p><code>printf(&quot;%d\n&quot;,ADD * ADD);</code></p><p><code>printf(&quot;%d\n&quot;,2+3 * 2+3);</code></p><p>从这里可知宏定义就只是在预编译时单纯的将宏体替换宏名。这里想要正确输出，则要这样定义：<code>#define ADD (2+3)</code></p><p>带参数形式的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAX(a,b)   (a &gt; b ? a : b)</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">        int i = 5, j = 3;</span><br><span class="line">        printf(&quot;%d\n&quot;,MAX(i,j));</span><br><span class="line">        exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：5</p><p>但是逻辑上 a 和 b 也应该各自加上括号，因为传参时的数要考虑到运算的优先级,因为无论是 a 还是 b 在这里都是单独的个体，且可以是 a = 1 + 3 的形式，这样组合起来就要考虑优先级问题，1 + 3 是要自己单独运算的。</p><p><code>#define MAX(a,b)   ((a) &gt; (b) ? (a) : (b))</code></p><p>当程序改成如下后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAX(a,b)   ((a) &gt; (b) ? (a) : (b))</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">        </span><br><span class="line">        int i = 5, j = 3;            </span><br><span class="line">        printf(&quot;i = %d\tj = %d\n&quot;,i,j);</span><br><span class="line">        printf(&quot;%d\n&quot;,MAX(i++,j++));</span><br><span class="line">        printf(&quot;i = %d\tj = %d\n&quot;,i,j);</span><br><span class="line">        exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将参数改成 i++ 和 j++。结果输出如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = 5j = 3</span><br><span class="line">6</span><br><span class="line">i = 7j = 4</span><br></pre></td></tr></table></figure><p>理论上 i = 5 和 j = 3 先进行比较，然后各自自增，i 大，则第二行的输出结果为 i 自增后的结果6（先比较后自增），第三行应为 i = 6，j = 4.可结果不是。</p><p>预编译的结果为</p><p><code>printf(&quot;%d\n&quot;,((i++) &gt; (j++) ? (i++) : (j++)));</code></p><p>根据这串语句可知，i 和 j 先比较，然后各自自增，由于 i 大，则执行 ？ 后面的 i++，这样 i 就再次自增了一次，所以第三行的 i 为自增了两次的。</p><p>解决方法：像函数的参数一样，用变量接收自增后的结果，而不是在比较完后，又将参数 i++ 执行一次，而是执行的是 i++的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define MAX(a,b)   (&#123;</span><br><span class="line">                        int A = a, B = b;</span><br><span class="line">                        ((A) &gt; (B) ? (A) : (B));</span><br><span class="line">                    &#125;)</span><br><span class="line"></span><br><span class="line">i = 5j = 3</span><br><span class="line">5</span><br><span class="line">i = 6j = 4</span><br></pre></td></tr></table></figure><p>预编译结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d\n&quot;,(&#123;int A = i++, B = j++; ((A) &gt; (B) ? (A) : (B));&#125;));</span><br></pre></td></tr></table></figure><p>有时参数未必都是 int 型，则可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define MAX(a,b)   (&#123;typeof(a) A = a, B = b; ((A) &gt; (B) ? (A) : (B));&#125;)</span><br></pre></td></tr></table></figure><p>用 a 的类型定义 A , B。用 typeof() 函数获取类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们平时编程时经常会忽略一些细节，导致项目出现问题，且有些很难发现。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
